# ブランチの作成タイミングの検討

**仕様書 ID:** 68ff98ee-95c5-47ac-9805-7c87fae55d19
**フェーズ:** completed
**作成日時:** 2025/11/20 17:56:09
**更新日時:** 2025/11/20 18:54:11

---

## 1. 背景と目的

### 背景

仕様書の作成時にブランチを作成すべきと考えています。しかし、ブランチを切り替えるとデータベースの不整合が起きる可能性があります。データベースにレコードはありますが、仕様書ファイルは存在しない状態が発生し得ます。この状態を管理するカラムが必要になると考えます。現状では仕様書作成時にブランチを作成しないため、これも問題です。

### 目的

本仕様書は、以下の 3 つの課題を解決するための設計方針を決定することを目的とします。

1. **ブランチ作成タイミングの最適化**
   - 仕様書作成時に自動的に作業ブランチを作成する機能の実装

2. **データベース整合性の保証**
   - ブランチ切り替え時に発生し得る「データベースレコードは存在するが仕様書ファイルが存在しない」状態を防止する仕組みの設計

3. **ブランチ間の仕様書の状態管理**
   - 仕様書がどのブランチで作成されたか、どのブランチで参照可能かを管理するデータモデルの設計

---

## 2. 対象ユーザー

本機能の対象ユーザーは以下の通りです。

1. **cc-craft-kit の開発者**
   - 仕様駆動開発（SDD）ワークフローに従って開発を進める開発者
   - Git ブランチを適切に管理しながら、仕様書と実装を同期させたい開発者

2. **チーム開発における複数の開発者**
   - 同一リポジトリで複数の仕様書を並行開発する開発者
   - ブランチ切り替え時にデータベース不整合を避けたい開発者

3. **cc-craft-kit のメンテナー**
   - ブランチ管理の仕組みを理解し、トラブルシューティングを行う必要があるメンテナー

---

## 3. 受け入れ基準

### 必須要件

- [ ] ブランチ作成タイミングの仕様が明確に定義されている
- [ ] データベース整合性を保証する仕組みが設計されている
- [ ] ブランチ間の仕様書の状態管理の仕組みが設計されている
- [ ] 既存の仕様書作成フローとの互換性が保たれている
- [ ] Git ブランチ管理のベストプラクティスに準拠している

### 機能要件

- [ ] 仕様書作成時に、適切なブランチ名（例: `spec/<spec-id>` または `feature/<spec-name>`）で自動的に作業ブランチが作成される
- [ ] ブランチ切り替え時に、そのブランチで参照可能な仕様書のみが表示される
- [ ] ブランチ間で仕様書の状態（作成中、レビュー中、マージ済みなど）が追跡可能である
- [ ] 仕様書がマージされた後、main/develop ブランチで正しく参照できる
- [ ] ブランチ削除時に、孤立した仕様書レコードが自動的にクリーンアップされる

### 非機能要件

- [ ] ブランチ切り替え時のデータベース整合性チェックが 1 秒以内に完了する
- [ ] データベースに `branch_name` カラムを追加してもパフォーマンスが劣化しない（インデックス設計を含む）
- [ ] 複数の Claude Code インスタンスから同時にブランチ作成しても競合が発生しない
- [ ] 既存の仕様書データに対して、マイグレーションスクリプトで `branch_name` を自動設定できる
- [ ] エラーハンドリングが適切に実装され、ブランチ作成失敗時にデータベースがロールバックされる

---

## 4. 制約条件

### 技術的制約

1. **SQLite の単一ファイル制約**
   - cc-craft-kit は SQLite を使用しており、データベースファイル（`.cc-craft-kit/cc-craft-kit.db`）は Git 管理されていない
   - ブランチ切り替え時にデータベースファイルは切り替わらないため、ブランチ A で作成した仕様書のレコードがブランチ B でも参照可能になる

2. **仕様書ファイルの Git 管理**
   - 仕様書ファイル（`.cc-craft-kit/specs/*.md`）は Git 管理対象である
   - ブランチ切り替え時に、仕様書ファイルはブランチの状態に応じて切り替わる

3. **不整合シナリオ**

   **シナリオ 1: ブランチ A で仕様書作成後、ブランチ B に切り替え**

   ```bash
   # ブランチ A で仕様書作成
   git checkout -b feature/spec-a
   /cft:spec-create "仕様書A" "説明"
   # => データベースにレコード挿入 + specs/<spec-id>.md ファイル作成

   # ブランチ B に切り替え
   git checkout feature/spec-b
   # => specs/<spec-id>.md ファイルは存在しないが、データベースレコードは残る
   # => /cft:spec-list で "仕様書A" が表示されるが、ファイルを開くとエラー
   ```

   **シナリオ 2: main ブランチで仕様書作成後、feature ブランチに切り替え**

   ```bash
   # main ブランチで仕様書作成
   git checkout main
   /cft:spec-create "仕様書M" "説明"

   # feature ブランチに切り替え
   git checkout -b feature/new-feature
   # => specs/<spec-id>.md ファイルは存在する（main から引き継がれる）
   # => データベースレコードも存在する
   # => 問題なく参照可能
   ```

4. **Git ワークフローとの整合性**
   - プロジェクトは GitHub Flow + develop ブランチを採用しており、以下のブランチ戦略を持つ
     - main: 本番リリース済み
     - develop: 次期リリース候補
     - feature/*: 新機能開発
     - fix/*: バグ修正
   - 仕様書作成時にブランチを自動作成する場合、既存のブランチ戦略と矛盾しないようにする必要がある

### 設計上の制約

1. **後方互換性**
   - 既存の仕様書データ（`branch_name` カラムがない）に対して、マイグレーションで適切なブランチ名を設定する必要がある

2. **パフォーマンス**
   - `/cft:spec-list` などのコマンド実行時に、毎回 Git ブランチ情報を取得するとパフォーマンスの劣化を招く可能性がある
   - データベースにブランチ情報をキャッシュする仕組みが必要

3. **複数 Claude Code インスタンス**
   - 複数の Claude Code を同時起動して使用する場合、ブランチ作成の競合を招く可能性がある
   - WAL モード + busy_timeout で対処可能だが、トランザクション設計を慎重に行う必要がある

---

## 5. 依存関係

### 内部依存

- **データベーススキーマ** (`src/core/database/schema.ts`)
  - `specs` テーブルに `branch_name` カラムを追加する必要がある
  - マイグレーションスクリプト（`src/core/database/migrations/`）を作成する必要がある

- **仕様書作成コマンド** (`src/commands/spec/create.ts`)
  - 仕様書作成時にブランチを自動作成するロジックを追加する必要がある

- **仕様書一覧コマンド** (`src/commands/spec/list.ts`)
  - 現在のブランチで参照可能な仕様書のみをフィルタリングするロジックを追加する必要がある

- **Git 統合** (`src/core/workflow/git-integration.ts`)
  - ブランチ作成ロジックを再利用する必要がある

### 外部依存

- **Git リポジトリ**
  - Git リポジトリが初期化されている必要がある
  - リモートリポジトリとの同期が正常に動作している必要がある

- **環境変数**
  - `PROTECTED_BRANCHES` 設定と矛盾しないようにブランチを作成する必要がある

---

## 6. 参考情報

### 関連ドキュメント

- [CLAUDE.md - Git ワークフロー基本方針](./CLAUDE.md#git-ワークフロー基本方針)
- [CLAUDE.md - データベース接続の安全性](./CLAUDE.md#データベース接続の安全性)
- [CLAUDE.md - .cc-craft-kit/ ディレクトリのファイル管理](./CLAUDE.md#cc-craft-kit-ディレクトリのファイル管理)

### 関連 Issue

- GitHub Issue #227: <https://github.com/B16B1RD/cc-craft-kit/issues/227>

### 参考実装

- `src/core/workflow/git-integration.ts` - 既存の Git 自動コミット機能
- `src/commands/spec/create.ts` - 仕様書作成コマンド
- `src/core/database/schema.ts` - データベーススキーマ定義

### 技術的背景

1. **SQLite のブランチ管理の課題**
   - SQLite はファイルベースのデータベースであり、Git では管理されない
   - ブランチ切り替え時にデータベースファイルは切り替わらない
   - この課題は、多くの Git ベースの開発ツールで共通の問題である

2. **解決策の例**
   - **オプション A**: データベースに `branch_name` カラムを追加し、クエリ時にフィルタリング
   - **オプション B**: ブランチごとに異なるデータベースファイルを使用（`.cc-craft-kit/db/<branch-name>.db`）
   - **オプション C**: 仕様書ファイルをマスターデータとし、データベースはキャッシュとして扱う（起動時にファイルからデータベースを再構築）

3. **推奨アプローチ**
   - **オプション A** を推奨（データベースに `branch_name` カラムを追加）
   - 理由:
     - 実装が最もシンプル
     - 既存のデータベース設計を大きく変更しない
     - パフォーマンスへの影響が最小限
     - 複数ブランチ間の仕様書を横断検索する場合にも対応可能

---

## 7. 設計

### 7.1 データモデル設計

#### データベーススキーマ変更

**現在の `specs` テーブル:**

```typescript
export interface SpecsTable {
  id: string; // UUID
  name: string;
  description: string | null;
  phase: 'requirements' | 'design' | 'tasks' | 'implementation' | 'completed';
  spec_file_path: string;
  created_at: string;
  updated_at: string;
}
```

**変更後の `specs` テーブル:**

```typescript
export interface SpecsTable {
  id: string; // UUID
  name: string;
  description: string | null;
  phase: 'requirements' | 'design' | 'tasks' | 'implementation' | 'completed';
  spec_file_path: string;
  branch_name: string; // 追加: 仕様書が作成されたブランチ名
  created_at: string;
  updated_at: string;
}
```

**インデックス設計:**

```sql
-- ブランチ名での高速検索を実現
CREATE INDEX idx_specs_branch_name ON specs(branch_name);

-- フェーズとブランチの複合検索を最適化
CREATE INDEX idx_specs_phase_branch ON specs(phase, branch_name);
```

#### マイグレーションスクリプト

**ファイル名:** `src/core/database/migrations/00X_add_branch_name_to_specs.ts`

```typescript
import { Kysely } from 'kysely';
import { Database } from '../schema.js';
import { execSync } from 'child_process';

export async function up(db: Kysely<Database>): Promise<void> {
  // 1. カラム追加（デフォルト値 'main'）
  await db.schema
    .alterTable('specs')
    .addColumn('branch_name', 'text', (col) => col.notNull().defaultTo('main'))
    .execute();

  // 2. 現在のブランチ名を取得
  let currentBranch = 'main';
  try {
    currentBranch = execSync('git rev-parse --abbrev-ref HEAD', { encoding: 'utf-8' }).trim();
  } catch (error) {
    console.warn('Git ブランチ名の取得に失敗しました。デフォルト値 "main" を使用します。');
  }

  // 3. 既存レコードのブランチ名を更新
  await db.updateTable('specs').set({ branch_name: currentBranch }).execute();

  // 4. インデックス作成
  await db.schema.createIndex('idx_specs_branch_name').on('specs').column('branch_name').execute();
  await db.schema
    .createIndex('idx_specs_phase_branch')
    .on('specs')
    .columns(['phase', 'branch_name'])
    .execute();
}

export async function down(db: Kysely<Database>): Promise<void> {
  await db.schema.dropIndex('idx_specs_phase_branch').execute();
  await db.schema.dropIndex('idx_specs_branch_name').execute();
  await db.schema.alterTable('specs').dropColumn('branch_name').execute();
}
```

### 7.2 ブランチ作成タイミング設計

#### 採用方針: 仕様書作成時に自動作成

**理由:**

- 仕様書は最初から独立したブランチで管理すべき
- 後からブランチを作成するとコミット履歴が複雑になる
- 仕様駆動開発のワークフローに合致

#### ブランチ命名規則

**オプション 1: `spec/<spec-id>` 形式（推奨）**

```bash
spec/68ff98ee-95c5-47ac-9805-7c87fae55d19
```

- メリット: 一意性が保証される、仕様書 ID からブランチを特定可能
- デメリット: ブランチ名が長い、人間にとって読みにくい

**オプション 2: `feature/<spec-name>` 形式**

```bash
feature/branch-creation-timing
```

- メリット: 人間にとって読みやすい、GitHub Flow の慣習に従う
- デメリット: 仕様書名の重複時に衝突の可能性、日本語の仕様書名の扱いが難しい

**最終決定: オプション 1 を採用**

仕様書 ID の先頭 8 文字を使用して、一意性と可読性のバランスを取る。

```bash
spec/68ff98ee
```

#### ブランチ作成フロー

```typescript
// src/commands/spec/create.ts の変更案
export async function createSpec(name: string, description?: string): Promise<void> {
  const db = getDatabase();
  const specId = uuidv4();
  const shortSpecId = specId.substring(0, 8);
  const branchName = `spec/${shortSpecId}`;

  try {
    // 1. Git リポジトリの存在確認
    execSync('git rev-parse --is-inside-work-tree', { stdio: 'ignore' });

    // 2. ブランチ作成（保護ブランチチェックを含む）
    execSync(`git checkout -b ${branchName}`, { stdio: 'inherit' });
  } catch (error) {
    console.warn(`ブランチ作成に失敗しました: ${error.message}`);
    console.warn('仕様書はブランチなしで作成されます。');
    // ブランチ作成失敗はエラーとせず、処理を継続
  }

  // 3. データベーストランザクション開始
  await db.transaction().execute(async (trx) => {
    try {
      // 4. データベースレコード作成
      await trx
        .insertInto('specs')
        .values({
          id: specId,
          name,
          description: description ?? null,
          phase: 'requirements',
          spec_file_path: `.cc-craft-kit/specs/${specId}.md`,
          branch_name: branchName,
          created_at: formatDate(new Date()),
          updated_at: formatDate(new Date()),
        })
        .execute();

      // 5. 仕様書ファイル作成
      const specContent = generateSpecTemplate(specId, name, description);
      await writeFileWithFsync(`.cc-craft-kit/specs/${specId}.md`, specContent);

      // 6. イベント発火
      const eventBus = await getEventBusAsync();
      await eventBus.emit(eventBus.createEvent('spec.created', specId, { name, branchName }));
    } catch (error) {
      // 7. エラー時のロールバック
      console.error('仕様書作成に失敗しました:', error.message);

      // ブランチを削除
      try {
        execSync(`git checkout develop && git branch -D ${branchName}`, { stdio: 'ignore' });
      } catch {}

      throw error; // トランザクションロールバック
    }
  });
}
```

### 7.3 ブランチフィルタリング設計

#### 仕様書一覧コマンドの変更

**方針:** 現在のブランチで参照可能な仕様書のみを表示する。

**参照可能ブランチのルール:**

1. **現在のブランチで作成された仕様書**
2. **main ブランチで作成された仕様書**（全ブランチで参照可能）
3. **develop ブランチで作成された仕様書**（全ブランチで参照可能）

```typescript
// src/commands/spec/list.ts の変更案
import { execSync } from 'child_process';

export async function listSpecs(phase?: string, limit?: number): Promise<void> {
  const db = getDatabase();

  // 現在のブランチ名を取得
  let currentBranch = 'main';
  try {
    currentBranch = execSync('git rev-parse --abbrev-ref HEAD', { encoding: 'utf-8' }).trim();
  } catch (error) {
    console.warn('Git ブランチ名の取得に失敗しました。');
  }

  // クエリ構築
  let query = db
    .selectFrom('specs')
    .selectAll()
    .where((eb) =>
      eb.or([
        eb('branch_name', '=', currentBranch), // 現在のブランチ
        eb('branch_name', '=', 'main'), // main ブランチ（全ブランチで参照可能）
        eb('branch_name', '=', 'develop'), // develop ブランチ（全ブランチで参照可能）
      ])
    );

  if (phase) {
    query = query.where('phase', '=', phase);
  }

  if (limit) {
    query = query.limit(limit);
  }

  const specs = await query.execute();

  // ファイル存在確認
  const validSpecs = specs.filter((spec) => {
    const filePath = path.join(process.cwd(), spec.spec_file_path);
    return fs.existsSync(filePath);
  });

  // 表示処理
  // ...
}
```

### 7.4 エラーハンドリング設計

#### ブランチ作成失敗時の対処

**シナリオ 1: Git リポジトリが未初期化**

```typescript
try {
  execSync('git rev-parse --is-inside-work-tree', { stdio: 'ignore' });
} catch (error) {
  console.warn('Git リポジトリが初期化されていません。仕様書はブランチなしで作成されます。');
  // branchName = 'main' として処理を継続
}
```

**シナリオ 2: ブランチ名が既に存在**

```typescript
try {
  execSync(`git checkout -b ${branchName}`, { stdio: 'inherit' });
} catch (error) {
  if (error.message.includes('already exists')) {
    console.error(`ブランチ ${branchName} は既に存在します。`);
    throw new Error(`Duplicate branch name: ${branchName}`);
  }
}
```

**シナリオ 3: 保護ブランチでの実行**

```typescript
const currentBranch = execSync('git rev-parse --abbrev-ref HEAD', { encoding: 'utf-8' }).trim();
const protectedBranches = (process.env.PROTECTED_BRANCHES || 'main,develop').split(',');

if (protectedBranches.includes(currentBranch)) {
  console.warn(`保護ブランチ ${currentBranch} では仕様書作成時にブランチを作成しません。`);
  // ブランチ作成をスキップし、現在のブランチ名を使用
}
```

#### トランザクションロールバック

データベースレコード作成、ファイル作成、ブランチ作成のいずれかが失敗した場合、すべてをロールバックする。

```typescript
await db.transaction().execute(async (trx) => {
  try {
    // データベースレコード作成
    await trx.insertInto('specs').values({ ... }).execute();

    // ファイル作成
    await writeFileWithFsync(specFilePath, content);

    // イベント発火
    await eventBus.emit(...);
  } catch (error) {
    // ファイル削除
    if (fs.existsSync(specFilePath)) {
      fs.unlinkSync(specFilePath);
    }

    // ブランチ削除
    try {
      execSync(`git checkout develop && git branch -D ${branchName}`, { stdio: 'ignore' });
    } catch {}

    throw error; // データベーストランザクションもロールバック
  }
});
```

### 7.5 パフォーマンス最適化

#### インデックス戦略

1. **`idx_specs_branch_name`**: ブランチ名での単一検索を高速化
2. **`idx_specs_phase_branch`**: フェーズとブランチの複合検索を高速化

#### キャッシュ戦略

現在のブランチ名をコマンド実行ごとに取得すると、`git rev-parse` の実行コストが発生する。

**解決策: プロセスごとにキャッシュ**

```typescript
// src/core/git/branch-cache.ts
let cachedBranchName: string | null = null;

export function getCurrentBranch(options: { cache: boolean } = { cache: true }): string {
  if (options.cache && cachedBranchName !== null) {
    return cachedBranchName;
  }

  try {
    const branchName = execSync('git rev-parse --abbrev-ref HEAD', { encoding: 'utf-8' }).trim();
    cachedBranchName = branchName;
    return branchName;
  } catch (error) {
    return 'main';
  }
}

export function clearBranchCache(): void {
  cachedBranchName = null;
}
```

### 7.6 後方互換性とマイグレーション

#### 既存仕様書へのブランチ名設定

マイグレーションスクリプトで、既存の仕様書レコードに `branch_name` を設定する。

**設定ルール:**

1. 現在のブランチ名を取得
2. すべての既存レコードに現在のブランチ名を設定
3. ユーザーに通知メッセージを表示

```bash
# マイグレーション実行後のメッセージ例
✓ Migration completed: added branch_name column to specs table
ℹ All existing specs have been assigned to branch 'develop'
ℹ If you need to reassign specs to different branches, use the database directly
```

#### データベース整合性チェックの拡張

`npx tsx .cc-craft-kit/scripts/repair-database.ts` にブランチ整合性チェックを追加する。

**チェック項目:**

1. `branch_name` が NULL のレコードがないか
2. `branch_name` に記載されたブランチが Git リポジトリに存在するか（警告のみ）
3. ファイルが存在しないレコードの `branch_name` が正しいか

---

## 8. 実装タスクリスト

以下のタスクを順番に実装します。各タスクは独立して実装可能ですが、依存関係があるため順序を守る必要があります。

### タスク 1: データベーススキーマを変更

**目的:** `specs` テーブルに `branch_name` カラムを追加する。

**対象ファイル:** `src/core/database/schema.ts`

**作業内容:**

1. `SpecsTable` インターフェースに `branch_name: string` を追加
2. TypeScript の型定義を更新

**受け入れ基準:**

- [ ] `SpecsTable` インターフェースに `branch_name` カラムが追加されている
- [ ] TypeScript のコンパイルエラーがない

---

### タスク 2: マイグレーションスクリプトを作成

**目的:** データベースに `branch_name` カラムを追加し、既存データを更新

**対象ファイル:** `src/core/database/migrations/00X_add_branch_name_to_specs.ts`（X は次の連番）

**作業内容:**

1. `up()` 関数で `branch_name` カラムを追加（デフォルト値 `'main'`）
2. 現在のブランチ名を取得し、既存レコードを更新
3. インデックス `idx_specs_branch_name` と `idx_specs_phase_branch` を作成
4. `down()` 関数でロールバック処理を実装

**受け入れ基準:**

- [ ] マイグレーションスクリプトが正しく動作する
- [ ] 既存の仕様書データに `branch_name` が設定される
- [ ] インデックスが作成される
- [ ] `npm run db:migrate` でマイグレーションが成功する

---

### タスク 3: ブランチキャッシュ機構を実装

**目的:** Git ブランチ名の取得コストを削減

**対象ファイル:** `src/core/git/branch-cache.ts`（新規作成）

**作業内容:**

1. `getCurrentBranch()` 関数を実装（キャッシュオプション付き）
2. `clearBranchCache()` 関数を実装
3. エクスポート設定

**受け入れ基準:**

- [ ] `getCurrentBranch()` が正しく動作する
- [ ] キャッシュが有効な場合、2 回目以降の呼び出しで `git rev-parse` を実行しない
- [ ] Git リポジトリ未初期化時にデフォルト値 `'main'` を返す

---

### タスク 4: 仕様書作成コマンドを変更

**目的:** 仕様書作成時に自動的にブランチを作成する。

**対象ファイル:** `src/commands/spec/create.ts`

**作業内容:**

1. ブランチ名生成ロジックを追加（`spec/<spec-id の先頭8文字>`）
2. Git リポジトリ存在確認を追加
3. ブランチ作成処理を追加（`git checkout -b`）
4. 保護ブランチチェックを追加
5. エラー時のロールバック処理を追加（ブランチ削除）
6. データベースレコードに `branch_name` を設定

**受け入れ基準:**

- [ ] 仕様書作成時にブランチが自動作成される
- [ ] ブランチ名が `spec/<spec-id の先頭8文字>` 形式である
- [ ] Git リポジトリ未初期化時は警告を表示し、処理を継続する
- [ ] 保護ブランチでは警告を表示し、ブランチ作成をスキップする
- [ ] エラー時にブランチが削除され、データベースがロールバックされる

---

### タスク 5: 仕様書一覧コマンドを変更

**目的:** 現在のブランチで参照可能な仕様書のみを表示する。

**対象ファイル:** `src/commands/spec/list.ts`

**作業内容:**

1. `getCurrentBranch()` を使用して現在のブランチ名を取得
2. クエリに `branch_name` フィルターを追加（現在のブランチ、main、develop）
3. ファイル存在確認を追加

**受け入れ基準:**

- [ ] 現在のブランチで作成された仕様書が表示される
- [ ] main ブランチで作成された仕様書が表示される
- [ ] develop ブランチで作成された仕様書が表示される
- [ ] 他のブランチで作成された仕様書は表示されない
- [ ] ファイルが存在しない仕様書は表示されない

---

### タスク 6: データベース整合性チェックスクリプトを拡張

**目的:** ブランチ整合性チェックを追加する。

**対象ファイル:** `.cc-craft-kit/scripts/repair-database.ts`

**作業内容:**

1. `branch_name` が NULL のレコードをチェック
2. `branch_name` に記載されたブランチが Git リポジトリに存在するかチェック（警告のみ）
3. ファイルが存在しないレコードの `branch_name` をチェック
4. 修復処理を追加

**受け入れ基準:**

- [ ] `branch_name` が NULL のレコードが検出される
- [ ] ブランチが存在しない場合、警告が表示される
- [ ] ファイルの存在しないレコードが検出される
- [ ] 修復処理が正しく動作する

---

### タスク 7: 単体テストを作成

**目的:** ブランチ作成、フィルタリング、エラーハンドリングのテストを作成する。

**対象ファイル:**

- `tests/commands/spec/create.test.ts`
- `tests/commands/spec/list.test.ts`
- `tests/core/git/branch-cache.test.ts`

**作業内容:**

1. ブランチ作成のテスト
   - 正常系: ブランチが正しく作成される
   - 異常系: Git リポジトリ未初期化、ブランチ名重複、保護ブランチ
2. フィルタリングのテスト
   - 現在のブランチで作成された仕様書のみ表示
   - main/develop ブランチの仕様書は全ブランチで表示
3. ブランチキャッシュのテスト
   - キャッシュが正しく動作する
   - `clearBranchCache()` でキャッシュがクリアされる

**受け入れ基準:**

- [ ] すべてのテストが通る
- [ ] カバレッジが 80% 以上

---

### タスク 8: E2E テストを作成

**目的:** ブランチ切り替えシナリオの統合テストを作成する。

**対象ファイル:** `tests/e2e/branch-switching.test.ts`

**作業内容:**

1. シナリオ 1: ブランチ A で仕様書作成 → ブランチ B に切り替え → 仕様書が表示されない
2. シナリオ 2: main ブランチで仕様書作成 → feature ブランチに切り替え → 仕様書が表示される
3. シナリオ 3: develop ブランチで仕様書作成 → feature ブランチに切り替え → 仕様書が表示される

**受け入れ基準:**

- [ ] すべてのシナリオが正しく動作する
- [ ] データベース整合性が保たれる

---

### タスク 9: ドキュメントを更新

**目的:** ブランチ管理の説明を追加する。

**対象ファイル:** `CLAUDE.md`

**作業内容:**

1. 「アーキテクチャ」セクションに「ブランチ管理」の説明を追加
2. 「トラブルシューティング」セクションに「ブランチ不整合エラー」を追加
3. 使用例を追加

**受け入れ基準:**

- [ ] ドキュメントが正しく更新されている
- [ ] textlint チェックに通る
