# implementation フェーズ完了時、未コミットのものがある

**仕様書 ID:** 842ac6b3-0ccc-46c2-9840-11bbfb89a58d
**フェーズ:** design
**作成日時:** 2025/11/23 20:47:51
**更新日時:** 2025/11/23 20:59:01

---

## 1. 背景と目的

### 背景

現在、cc-craft-kit では `implementation` フェーズから `completed` フェーズへ移行する際に、自動コミット機能が働いているものの、**仕様書ファイルのみがコミット対象**となっている。

**根本原因**:
- `src/core/workflow/git-integration.ts` の `getCommitTargets()` 関数が、仕様書ファイル (`.cc-craft-kit/specs/{spec-id}.md`) のみを返却している
- そのため、実装コード (`src/`, `tests/`) や設定ファイルなどは未コミット状態で残る

この問題は、以下の既存仕様書でも指摘されている:
- `.cc-craft-kit/specs/efef7d78-6e0b-4e6a-a5ec-0856e4012b76.md` (getCommitTargetsの返り値修正)

**影響範囲**:
- 開発者が意図せず未コミットファイルを残したまま、PR を作成してしまう
- Git ステータスが混乱し、どのファイルがコミットされたのか分かりにくくなる
- フェーズごとの変更履歴が追跡できなくなる

### 目的

implementation フェーズ完了時（`completed` フェーズ移行時）に、**全変更ファイルを自動コミット**する仕組みを実装し、未コミットファイルが残らないようにする。

**設計方針**:
1. **プロンプトファースト**: プロンプトで実現できることはプロンプトで実現する
2. **スキル/サブエージェント活用**: スキルやサブエージェントで実現できないかよく検討する
3. **スクリプト実装は最終手段**: 既存の TypeScript スクリプト修正が必要な場合のみ実施

**成功基準**:
- `implementation → completed` 時、実装コードを含む全変更ファイルがコミットされる
- 既存の E2E テスト (`tests/e2e/phase-transition-commit.test.ts`) がすべて通過する
- Git ステータスがクリーンな状態になる

---

## 2. 対象ユーザー

cc-craft-kit を使用する**開発者**（特に Claude Code を利用して仕様駆動開発を実践する開発者）

**具体的なユースケース**:
- 仕様書を作成し、implementation フェーズで実装コードを追加した後、completed フェーズに移行する際、全変更ファイルが自動コミットされることを期待する
- フェーズ遷移時に、手動で `git add .` や `git commit` を実行する必要がなくなる
- PR 作成前に、未コミットファイルが残っていないかチェックする手間を削減できる

---

## 3. 受け入れ基準

### 必須要件

- [ ] `implementation → completed` フェーズ移行時、**全変更ファイル**（仕様書ファイル + 実装コード + テスト + 設定ファイル）が自動コミットされる
- [ ] 既存の E2E テスト (`tests/e2e/phase-transition-commit.test.ts`) がすべて通過する
- [ ] コミット後、`git status` がクリーンな状態（未コミット変更なし）になる

### 機能要件

- [ ] `getCommitTargets(specId)` 関数が、仕様書ファイルのみではなく全変更ファイル (`['.']`) を返却する
- [ ] `.gitignore` で除外されたファイルは、自動的にコミット対象から除外される
- [ ] コミットメッセージは既存の規則に従う（`feat: {仕様書名} を実装完了`）
- [ ] フェーズ遷移時の自動コミットが失敗した場合、ステージングをロールバックし、フェーズ遷移は成功させる（既存の動作を維持）

### 非機能要件

- [ ] セキュリティ: `spawnSync` を使用したシェルインジェクション対策を維持する
- [ ] パフォーマンス: `git add .` によるコミット対象決定が、大規模リポジトリでも許容可能な速度で完了する
- [ ] 互換性: 既存のイベント駆動アーキテクチャ（`spec.phase_changed` イベント）を維持する
- [ ] テストカバレッジ: 修正箇所の単体テスト、E2E テストがすべて通過する

---

## 4. 制約条件

### 技術的制約

1. **既存インターフェース維持**
   - `handlePhaseChangeCommit()`, `handleSpecCreatedCommit()` のシグネチャ変更不可
   - 既存のイベント駆動アーキテクチャ（EventBus）を維持する

2. **セキュリティ対策維持**
   - `spawnSync` 使用によるシェルインジェクション対策
   - UUID バリデーション（`getCommitTargets()` の引数検証）
   - `.gitignore` 除外処理の継続

3. **エラーハンドリング**
   - Git リポジトリ未初期化時: 警告表示 + スキップ
   - コミット失敗時: ステージングロールバック (`git reset HEAD`)
   - フェーズ変更は成功させる（コミット失敗でもフェーズ遷移は完了）

### 設計制約

1. **プロンプトファースト原則**
   - プロンプトで実現できることはプロンプトで実現する
   - スクリプト実装は最終手段とする

2. **スキル/サブエージェント活用**
   - 既存のスキル（`git-operations`, `typescript-eslint` など）で実現できないか検討する
   - サブエージェント（`code-reviewer`, `refactoring-assistant`）の活用を優先する

3. **TypeScript スクリプト実装の条件**
   - データベース操作が必要
   - イベント発火・ハンドラー登録が必要
   - 複雑な Zod スキーマ検証が必要
   - 型安全性が重要（TypeScript の型推論が必要）

### 運用上の制約

1. **テストカバレッジ維持**
   - 既存テスト (`tests/e2e/phase-transition-commit.test.ts`) がすべて通過すること
   - 修正箇所の単体テストを追加すること

2. **コード品質維持**
   - ESLint ルール準拠
   - TypeScript strict mode
   - 命名規則: camelCase (変数・関数), PascalCase (クラス・型)

---

## 5. 依存関係

### 既存仕様書

- **efef7d78-6e0b-4e6a-a5ec-0856e4012b76**: `getCommitTargets()` の返り値修正
  - 本仕様書と同じ問題を解決する仕様書
  - 実装済みの場合、重複を避けるため、本仕様書は不要となる可能性がある

### 既存コンポーネント

1. **src/core/workflow/git-integration.ts**
   - `getCommitTargets(specId: string)`: コミット対象ファイル決定（修正対象）
   - `gitCommit(files: string[], message: string)`: Git コミット実行
   - `handlePhaseChangeCommit()`: フェーズ変更時の自動コミット
   - `handleSpecCreatedCommit()`: 仕様書作成時の自動コミット

2. **src/core/workflow/event-bus.ts**
   - `EventBus`: イベント駆動アーキテクチャの中核
   - `spec.phase_changed` イベントが発火され、`handlePhaseChangeCommit()` が呼び出される

3. **src/commands/spec/phase.ts**
   - `/cft:spec-phase` コマンドの実装
   - フェーズ変更時に `spec.phase_changed` イベントを発火

### テストケース

1. **tests/e2e/phase-transition-commit.test.ts**
   - フェーズ遷移時の自動コミット処理の E2E テスト
   - `implementation → completed` 時の期待値: `['.']` (全変更ファイル)

2. **tests/core/workflow/git-integration.test.ts**
   - `getCommitTargets()` 関数の単体テスト
   - 修正後の期待値: `['.']`

---

## 6. 参考情報

### 関連ファイル

- `src/core/workflow/git-integration.ts:165-174` - `getCommitTargets()` 関数（修正対象）
- `tests/core/workflow/git-integration.test.ts:318-387` - 単体テスト（期待値更新が必要）
- `tests/e2e/phase-transition-commit.test.ts:316-331` - E2E テスト（既に `['.']` を期待）

### 既存の実装パターン

**コミットメッセージ規約** (Conventional Commits):
- `feat:` - 新機能
- `fix:` - バグ修正
- `refactor:` - リファクタリング

**Git コマンド実行パターン**:
```typescript
import { spawnSync } from 'node:child_process';

const result = spawnSync('git', ['add', ...files], {
  encoding: 'utf-8',
  stdio: ['ignore', 'pipe', 'pipe'],
});

if (result.status !== 0) {
  throw new Error(`git command failed: ${result.stderr}`);
}
```

### 想定される実装アプローチ

**アプローチ 1: スクリプト修正（推奨）**
- `getCommitTargets()` の返り値を `['.']` に変更
- 既存テストの期待値を更新
- 影響範囲: 最小限

**アプローチ 2: プロンプトベース（検討中）**
- スラッシュコマンド `.cc-craft-kit/commands/spec/phase.md` でコミット処理をオーバーライド
- 課題: イベント駆動アーキテクチャとの整合性を保つ必要がある

**アプローチ 3: スキル活用（検討中）**
- `git-operations` スキルを拡張して、フェーズ遷移時のコミット処理をカスタマイズ
- 課題: 既存のイベントハンドラーとの競合を避ける必要がある

---

## 7. 設計詳細

### 7.1. アーキテクチャ設計

本仕様書では、**プロンプトファースト原則**に基づき、以下の優先順位でアプローチを検討する。

#### アプローチ評価マトリクス

| アプローチ | 実現可能性 | 保守性 | 影響範囲 | 推奨度 |
|---|---|---|---|---|
| **1. プロンプトベース** | ⚠️ 低 | ⭐⭐⭐ 高 | 🟢 最小 | ❌ 不採用 |
| **2. スキル活用** | ⚠️ 低 | ⭐⭐ 中 | 🟡 中 | ❌ 不採用 |
| **3. スクリプト修正** | ✅ 高 | ⭐⭐⭐ 高 | 🟢 最小 | ✅ **採用** |

#### アプローチ 1: プロンプトベース（不採用）

**実装方法**:
- `.cc-craft-kit/commands/spec/phase.md` を編集し、`npx tsx .cc-craft-kit/commands/spec/phase.ts` 実行前に以下を追加:
  ```bash
  # フェーズ移行前に未コミットファイルを確認
  if [ "$(git status --porcelain)" ]; then
    echo "⚠ 未コミットファイルが見つかりました。すべてコミットしますか？"
    # AskUserQuestion で確認
    # YES なら git add . && git commit -m "..."
  fi
  ```

**不採用理由**:
1. **イベント駆動アーキテクチャとの競合**
   - `spec.phase_changed` イベントが発火される前にコミットすると、イベントハンドラー（`handlePhaseChangeCommit`）が二重でコミットを試みる
   - イベント発火後にコミットすると、`handlePhaseChangeCommit` が先に実行され、仕様書ファイルのみがコミットされる

2. **プロンプトの複雑化**
   - Git 状態の確認、ユーザー確認、コミット実行をプロンプトで実装すると、可読性が低下する
   - デバッグが困難になる

3. **型安全性の欠如**
   - Bash スクリプトでは TypeScript の型チェックが効かない
   - エラーハンドリングが不十分になる可能性がある

**結論**: イベント駆動アーキテクチャとの整合性を保つため、プロンプトベースでの実装は不適切。

---

#### アプローチ 2: スキル活用（不採用）

**実装方法**:
- `git-operations` スキルを拡張し、フェーズ遷移時のコミット処理をカスタマイズ
- `.cc-craft-kit/commands/spec/phase.md` で `Skill(git-operations)` を呼び出し、`--commit-all` オプションを渡す

**不採用理由**:
1. **スキルの役割逸脱**
   - `git-operations` スキルは Git 操作の補助ツールであり、フェーズ遷移のビジネスロジックを持つべきではない
   - 仕様駆動開発のワークフローは、cc-craft-kit の中核機能であり、スキルに委譲すべきではない

2. **既存イベントハンドラーとの競合**
   - `handlePhaseChangeCommit` が既に登録されており、スキルから呼び出すと二重実行される
   - イベントハンドラーを無効化すると、他のフェーズ遷移（requirements → design など）に影響が出る

3. **保守性の低下**
   - スキルと TypeScript スクリプトの責務が不明確になる
   - 将来的なスキル削除時に影響が大きい

**結論**: スキルは補助的な役割に留め、中核ロジックはスクリプトで実装すべき。

---

#### アプローチ 3: スクリプト修正（✅ 採用）

**実装方法**:
- `src/core/workflow/git-integration.ts` の `getCommitTargets()` 関数を修正
- 返り値を `['.']` に変更し、全変更ファイルをコミット対象とする

**採用理由**:
1. **最小限の変更で実現可能**
   - 修正箇所: `git-integration.ts` の 1 関数のみ（10 行程度）
   - 既存のイベント駆動アーキテクチャをそのまま活用できる

2. **型安全性の維持**
   - TypeScript strict mode で型チェックが効く
   - Zod バリデーションやエラーハンドリングが既に実装されている

3. **テストカバレッジの維持**
   - E2E テスト (`tests/e2e/phase-transition-commit.test.ts`) は既に `['.']` を期待している
   - 単体テスト (`tests/core/workflow/git-integration.test.ts`) の期待値を更新するだけで完了

4. **既存の動作を維持**
   - `.gitignore` 除外処理が自動的に動作する
   - コミット失敗時のロールバック処理が既に実装されている

**結論**: スクリプト修正が最もシンプルかつ安全な実装方法。

---

### 7.2. データモデル

**変更なし**。本仕様書は Git 操作のみに関わるため、データベーススキーマの変更は不要。

---

### 7.3. API の仕様

#### 修正対象: `getCommitTargets(specId: string): string[]`

**ファイル**: `src/core/workflow/git-integration.ts:165-174`

**変更前**:
```typescript
export function getCommitTargets(specId: string): string[] {
  // specIdのバリデーション(UUID形式)
  const uuidPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
  if (!uuidPattern.test(specId)) {
    throw new Error(`Invalid spec ID format: ${specId}`);
  }

  // 仕様書ファイルのみをコミット対象とする
  return [`.cc-craft-kit/specs/${specId}.md`];
}
```

**変更後**:
```typescript
export function getCommitTargets(specId: string): string[] {
  // specIdのバリデーション(UUID形式)
  const uuidPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
  if (!uuidPattern.test(specId)) {
    throw new Error(`Invalid spec ID format: ${specId}`);
  }

  // 全変更ファイルをコミット対象とする
  return ['.'];
}
```

**変更箇所**:
- L173: `['.cc-craft-kit/specs/${specId}.md']` → `['.']`
- コメント更新: "仕様書ファイルのみ" → "全変更ファイル"

**影響を受ける関数**:
1. `handlePhaseChangeCommit()` (286行目)
   - 全フェーズ遷移時に呼び出される
   - 変更後: requirements → design, design → tasks なども全変更をコミット
2. `handleSpecCreatedCommit()` (369行目)
   - 仕様書作成時に呼び出される
   - 変更後: 仕様書作成時も全変更をコミット

**副作用の検証**:
- `.gitignore` 除外処理 (`getIgnoredFiles()`) が自動的に動作するため、除外ファイルは安全
- `git add .` は既存の実装 (`gitCommit()` 関数) でサポート済み

---

### 7.4. セキュリティ考慮事項

#### 既存のセキュリティ対策（維持）

1. **シェルインジェクション対策**
   - `spawnSync('git', ['add', '.'], { ... })` を使用
   - 引数を配列で渡すため、シェルインジェクションのリスクなし

2. **UUID バリデーション**
   - `getCommitTargets()` の引数 `specId` を UUID 形式で検証
   - 不正な ID が渡された場合、エラーをスローする

3. **.gitignore 除外処理**
   - `getIgnoredFiles()` で `.gitignore` 対象ファイルを自動除外
   - センシティブ情報（`.env`, `credentials.json` など）は自動的にコミット対象外となる

#### 新たなリスク評価

**リスク 1: 意図しないファイルのコミット**
- **影響**: 開発中の一時ファイル、デバッグコードが誤ってコミットされる可能性
- **対策**: `.gitignore` が適切に設定されていることを前提とする
- **軽減策**: フェーズ移行前に `git status` で確認することを推奨（プロンプトで案内）

**リスク 2: 大規模リポジトリでのパフォーマンス低下**
- **影響**: `git add .` が大量のファイルをスキャンし、コミットが遅延する
- **対策**: Git のインデックスキャッシュが有効であれば、影響は軽微
- **軽減策**: 必要に応じて、`git add` のタイムアウトを設定（現在は実装されていない）

**結論**: 既存のセキュリティ対策で十分。新たなリスクは限定的であり、`.gitignore` の適切な設定で回避可能。

---

### 7.5. テスト戦略

#### 単体テストの修正

**ファイル**: `tests/core/workflow/git-integration.test.ts:318-387`

**修正内容**:
- `getCommitTargets()` の期待値を `['.']` に更新

**変更前**:
```typescript
expect(result).toEqual([`.cc-craft-kit/specs/${specId}.md`]);
```

**変更後**:
```typescript
expect(result).toEqual(['.']);
```

**影響範囲**:
- テストケース数: 1 件（`getCommitTargets()` のテスト）
- 所要時間: 5 分以内

#### E2E テストの確認

**ファイル**: `tests/e2e/phase-transition-commit.test.ts:316-331`

**既存の期待値**:
```typescript
expectCommitTargetsToBe(['.']);
```

**確認内容**:
- 既に `['.']` を期待しているため、修正不要
- テストが通過することを確認

#### テスト実行計画

1. **単体テスト実行**:
   ```bash
   npm run test -- tests/core/workflow/git-integration.test.ts
   ```

2. **E2E テスト実行**:
   ```bash
   npm run test -- tests/e2e/phase-transition-commit.test.ts
   ```

3. **全テスト実行**:
   ```bash
   npm test
   ```

4. **型チェック**:
   ```bash
   npx tsc --noEmit
   ```

5. **ESLint チェック**:
   ```bash
   npm run lint
   ```

#### カバレッジ目標

- **単体テスト**: `getCommitTargets()` 関数のカバレッジ 100%
- **E2E テスト**: フェーズ遷移時の自動コミット処理のカバレッジ 100%
- **全体カバレッジ**: 既存の 80% 以上を維持

---

### 7.6. 実装の詳細手順

#### フェーズ 1: コード修正

1. **`src/core/workflow/git-integration.ts` を修正**
   - `getCommitTargets()` の返り値を `['.']` に変更
   - コメントを更新

2. **同期処理を実行**
   ```bash
   npm run sync:dogfood
   ```

#### フェーズ 2: テスト修正

1. **単体テストの期待値を更新**
   - `tests/core/workflow/git-integration.test.ts:318-387` を修正

2. **テスト実行**
   ```bash
   npm run test -- tests/core/workflow/git-integration.test.ts
   ```

#### フェーズ 3: E2E テスト確認

1. **E2E テスト実行**
   ```bash
   npm run test -- tests/e2e/phase-transition-commit.test.ts
   ```

2. **全テスト実行**
   ```bash
   npm test
   ```

#### フェーズ 4: 品質チェック

1. **型チェック**
   ```bash
   npx tsc --noEmit
   ```

2. **ESLint チェック**
   ```bash
   npm run lint
   ```

3. **code-reviewer サブエージェントで品質レビュー**
   ```bash
   /cft:code-review src/core/workflow/git-integration.ts
   ```

#### フェーズ 5: 動作確認

1. **テスト用仕様書を作成**
   ```bash
   /cft:spec-create "テスト: 全変更ファイルコミット確認"
   ```

2. **実装ファイルを追加**
   ```bash
   echo "console.log('test');" > test-file.ts
   ```

3. **completed フェーズに移行**
   ```bash
   /cft:spec-phase <test-spec-id> implementation
   /cft:spec-phase <test-spec-id> completed
   ```

4. **Git 状態を確認**
   ```bash
   git status
   ```
   - 期待値: `nothing to commit, working tree clean`

---

### 7.7. ロールバック計画

万が一、実装後に問題が発生した場合、以下の手順でロールバック可能。

#### ロールバック手順

1. **変更箇所を元に戻す**
   ```bash
   git checkout HEAD~1 -- src/core/workflow/git-integration.ts
   ```

2. **テストを元に戻す**
   ```bash
   git checkout HEAD~1 -- tests/core/workflow/git-integration.test.ts
   ```

3. **同期処理を実行**
   ```bash
   npm run sync:dogfood
   ```

4. **テスト実行**
   ```bash
   npm test
   ```

#### 影響範囲

- ロールバック後、仕様書ファイルのみがコミット対象に戻る
- 既存の動作に影響なし

---

### 7.8. プロンプトファースト原則の再確認

**最終判断**: スクリプト修正を採用

**理由**:
1. **プロンプトで実現できない**: イベント駆動アーキテクチャとの整合性を保つため、プロンプトでは実装困難
2. **スキルで実現できない**: スキルの役割を逸脱し、保守性が低下する
3. **スクリプトが最適**: 型安全性、テストカバレッジ、エラーハンドリングが既に実装されており、最小限の変更で実現可能

**CLAUDE.md の「スクリプトとプロンプトの使い分け指針」に従った判断**:
- ✅ データベース操作が必要（specs テーブル更新）
- ✅ イベント発火・ハンドラー登録が必要（`spec.phase_changed`）
- ✅ 型安全性が重要（TypeScript strict mode）

→ **スクリプト実装が必須条件を満たす**
