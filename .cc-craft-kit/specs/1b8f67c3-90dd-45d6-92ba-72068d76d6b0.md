# フェーズが completed になってもコミットされない

**仕様書 ID:** 1b8f67c3-90dd-45d6-92ba-72068d76d6b0
**フェーズ:** completed
**作成日時:** 2025/11/16 16:22:57
**更新日時:** 2025/11/17 02:07:22

---

## 1. 背景と目的

### 背景

フェーズが completed になっているが修正内容がコミットされていない。適切なタイミングで適切にコミットされるべき。

### 目的

フェーズ変更時、特に completed フェーズ移行時に、変更内容を自動的に Git コミットする機能を実装し、開発履歴を確実に記録する。

---

## 2. 対象ユーザー

Takumi を使用して仕様駆動開発を行う全ての開発者

---

## 3. 受け入れ基準

### 必須要件

- [ ] completed フェーズ移行時、変更内容が必ずコミットされる
- [ ] コミット漏れが発生しない（completed フェーズでのコミット漏れは言語道断）
- [ ] Git リポジトリが初期化されていない場合は警告のみでエラーにしない

### 機能要件

- [ ] 各フェーズ移行時に仕様書ファイル（.cc-craft-kit/specs/*.md）をコミット
- [ ] completed フェーズでは仕様書ファイルに加え、関連する実装ファイルもコミット
- [ ] コミットメッセージは仕様書名とフェーズ情報を含む
- [ ] イベントハンドラー（spec.phase_changed）経由で自動コミット
- [ ] コミット成功/失敗の通知を出力

### 非機能要件

- [ ] コミット失敗時も仕様書のフェーズ変更は成功させる（ロールバックしない）
- [ ] Git 操作は Node.js 標準の child_process で実装（外部ライブラリ非依存）
- [ ] 既存のイベント駆動アーキテクチャを維持

---

## 4. 制約条件

- Git リポジトリが初期化されていることを前提とする（未初期化の場合は警告のみ）
- ステージングエリアに未追跡ファイルがある場合は、仕様書ファイルのみを git add する
- コミット対象外のファイル（.env、node_modules など）は .gitignore で除外される前提

---

## 5. 依存関係

### 関連コンポーネント

- `.cc-craft-kit/core/workflow/event-bus.ts` - イベントバス
- `.cc-craft-kit/core/workflow/github-integration.ts` - GitHub 統合イベントハンドラー
- `.cc-craft-kit/commands/spec/phase.ts` - フェーズ変更コマンド

### 新規実装ファイル

- `.cc-craft-kit/core/workflow/git-integration.ts` - Git 自動コミットハンドラー（新規作成）

---

## 6. 参考情報

### コミットタイミング

1. **completed フェーズ移行時（必須）**
   - コミットメッセージ: `feat: <仕様書名> を実装完了`
   - 対象ファイル: 仕様書 + 実装ファイル全体

2. **その他のフェーズ移行時（推奨）**
   - `requirements` → `feat: <仕様書名> の要件定義を完了`
   - `design` → `feat: <仕様書名> の設計を完了`
   - `tasks` → `feat: <仕様書名> のタスク分解を完了`
   - `implementation` → `feat: <仕様書名> の実装を開始`
   - 対象ファイル: 仕様書ファイルのみ

### 実装方式

**A案（推奨）**: イベントハンドラーで自動コミット
- `spec.phase_changed` イベントハンドラーに Git コミット処理を追加
- メリット: 一元管理、拡張性が高い、他の方法でフェーズ変更しても漏れない

**B案**: コマンド実行時に直接コミット
- `phase.ts` の最後にコミット処理を追加
- デメリット: イベント経由のフェーズ変更時に漏れる可能性

→ **A案を採用**

---

## 7. 設計

### アーキテクチャ概要

```
┌─────────────────────────────────────┐
│  spec-phase コマンド実行             │
├─────────────────────────────────────┤
│  1. DB & Markdown 更新              │
│  2. spec.phase_changed イベント発火  │
└─────────────────────────────────────┘
                ↓
┌─────────────────────────────────────┐
│  EventBus (イベント配信)             │
├─────────────────────────────────────┤
│  - GitHub統合ハンドラー              │
│  - Git統合ハンドラー (新規)          │
└─────────────────────────────────────┘
                ↓
┌─────────────────────────────────────┐
│  GitIntegrationHandler              │
├─────────────────────────────────────┤
│  1. Git リポジトリ存在確認           │
│  2. 変更ファイル検出                 │
│  3. ステージング (git add)           │
│  4. コミット実行 (git commit)        │
│  5. 結果通知                         │
└─────────────────────────────────────┘
```

### コンポーネント設計

#### 1. Git統合ハンドラー (.cc-craft-kit/core/workflow/git-integration.ts)

**責務:**
- `spec.phase_changed` イベントを監視
- フェーズに応じた Git コミットを実行
- エラーハンドリングとログ出力

**主要関数:**

```typescript
/**
 * Git統合のイベントハンドラーを登録
 */
export function registerGitIntegrationHandlers(
  eventBus: EventBus,
  db: Kysely<Database>
): void

/**
 * フェーズ変更時の自動コミット処理
 */
async function handlePhaseChangeCommit(
  event: WorkflowEvent<{ oldPhase: string; newPhase: string }>
): Promise<void>

/**
 * Git リポジトリの存在確認
 */
function isGitRepository(): boolean

/**
 * Git コミット実行
 */
async function gitCommit(
  files: string[],
  message: string
): Promise<{ success: boolean; error?: string }>
```

#### 2. コミットメッセージ生成ロジック

```typescript
function generateCommitMessage(
  specName: string,
  phase: Phase
): string {
  const messages: Record<Phase, string> = {
    requirements: `feat: ${specName} の要件定義を完了`,
    design: `feat: ${specName} の設計を完了`,
    tasks: `feat: ${specName} のタスク分解を完了`,
    implementation: `feat: ${specName} の実装を開始`,
    completed: `feat: ${specName} を実装完了`,
  };
  return messages[phase];
}
```

#### 3. コミット対象ファイルの決定ロジック

```typescript
function getCommitTargets(phase: Phase, specId: string): string[] {
  const baseFiles = [`.cc-craft-kit/specs/${specId}.md`];

  if (phase === 'completed') {
    // completed フェーズでは全変更をコミット
    return ['.'];
  }

  // その他のフェーズでは仕様書のみ
  return baseFiles;
}
```

### データフロー

```
1. ユーザー: /cft:spec-phase <spec-id> completed
2. phase.ts: DB & Markdown 更新
3. phase.ts: eventBus.emit('spec.phase_changed', ...)
4. EventBus: 全ハンドラーに配信
   ├─ GitHubIntegrationHandler: Issue ラベル更新
   └─ GitIntegrationHandler: Git コミット実行
5. GitIntegrationHandler:
   ├─ Git リポジトリ確認
   ├─ git status で変更検出
   ├─ git add <files>
   ├─ git commit -m "<message>"
   └─ 結果を console.log で通知
```

### エラーハンドリング戦略

1. **Git リポジトリ未初期化**
   - エラーにせず警告のみ
   - フェーズ変更は成功

2. **git add 失敗**
   - エラーログ出力
   - コミットは中断
   - フェーズ変更は成功

3. **git commit 失敗**
   - エラーログ出力（詳細なエラーメッセージ）
   - フェーズ変更は成功

4. **イベントハンドラー内の例外**
   - EventBus が catch して他のハンドラーに影響させない
   - エラーログに記録

### セキュリティ考慮事項

- コミットメッセージにセンシティブ情報を含めない
- `.gitignore` の除外設定を尊重
- `child_process.execSync` は引数をエスケープ（シェルインジェクション対策）

### パフォーマンス考慮事項

- Git 操作は同期実行（execSync）で簡潔に
- 大量ファイルのコミット時もタイムアウトなし
- イベントハンドラーは非同期で並列実行（GitHub 統合と競合しない）

---

## 8. タスク分解

### タスク一覧

| # | タスク名 | 工数見積 | 依存関係 | 優先度 |
|---|---------|---------|---------|--------|
| 1 | Git統合ハンドラーの実装 | 2h | - | 高 |
| 2 | EventBusへのハンドラー登録 | 0.5h | 1 | 高 |
| 3 | コミットメッセージ生成ロジック実装 | 0.5h | 1 | 高 |
| 4 | コミット対象ファイル決定ロジック実装 | 0.5h | 1 | 高 |
| 5 | エラーハンドリング実装 | 1h | 1 | 高 |
| 6 | 単体テストの作成 | 2h | 1-5 | 中 |
| 7 | 統合テストの作成 | 1h | 1-5 | 中 |
| 8 | ドキュメント更新 | 0.5h | 1-5 | 低 |

**合計工数:** 約 8 時間

### タスク詳細

#### タスク1: Git統合ハンドラーの実装

**ファイル:** `.cc-craft-kit/core/workflow/git-integration.ts`

**実装内容:**
- `registerGitIntegrationHandlers()` 関数
- `handlePhaseChangeCommit()` 関数
- `isGitRepository()` 関数
- `gitCommit()` 関数

**受け入れ基準:**
- spec.phase_changed イベントを監視できる
- Git リポジトリの存在確認ができる
- git add と git commit を実行できる

#### タスク2: EventBusへのハンドラー登録

**ファイル:** `.cc-craft-kit/core/workflow/event-bus.ts`

**実装内容:**
- `registerHandlersAsync()` 内で `registerGitIntegrationHandlers()` を呼び出し

**受け入れ基準:**
- EventBus 初期化時に Git 統合ハンドラーが自動登録される
- GitHub 統合ハンドラーと共存できる

#### タスク3: コミットメッセージ生成ロジック実装

**ファイル:** `.cc-craft-kit/core/workflow/git-integration.ts`

**実装内容:**
- `generateCommitMessage()` 関数
- フェーズごとのメッセージテンプレート

**受け入れ基準:**
- 各フェーズに応じた適切なコミットメッセージが生成される
- 仕様書名が正しくメッセージに含まれる

#### タスク4: コミット対象ファイル決定ロジック実装

**ファイル:** `.cc-craft-kit/core/workflow/git-integration.ts`

**実装内容:**
- `getCommitTargets()` 関数
- completed フェーズでは全変更、それ以外は仕様書のみ

**受け入れ基準:**
- completed フェーズで全変更ファイルがコミット対象になる
- その他のフェーズで仕様書ファイルのみがコミット対象になる

#### タスク5: エラーハンドリング実装

**ファイル:** `.cc-craft-kit/core/workflow/git-integration.ts`

**実装内容:**
- Git リポジトリ未初期化時の警告
- git add/commit 失敗時のエラーログ
- イベントハンドラー内の例外キャッチ

**受け入れ基準:**
- Git 未初期化でもエラーにならない
- git コマンド失敗時でもフェーズ変更は成功する
- エラーメッセージが分かりやすい

#### タスク6: 単体テストの作成

**ファイル:** `tests/core/workflow/git-integration.test.ts`

**実装内容:**
- `registerGitIntegrationHandlers()` のテスト
- `generateCommitMessage()` のテスト
- `getCommitTargets()` のテスト
- `isGitRepository()` のテスト
- Git コマンドはモック化

**受け入れ基準:**
- 全関数のテストカバレッジ 80% 以上
- エッジケース（Git 未初期化、コミット失敗）を網羅

#### タスク7: 統合テストの作成

**ファイル:** `tests/integration/git-auto-commit.test.ts`

**実装内容:**
- フェーズ変更 → 自動コミットの E2E テスト
- completed フェーズでの全変更コミットテスト

**受け入れ基準:**
- 実際に Git リポジトリを作成してテスト
- フェーズ変更後にコミットが作成されることを確認

#### タスク8: ドキュメント更新

**ファイル:** `CLAUDE.md`, `docs/ARCHITECTURE.md`

**実装内容:**
- Git 自動コミット機能の説明追加
- イベントハンドラー一覧に追記

**受け入れ基準:**
- ドキュメントが最新の実装を反映している
