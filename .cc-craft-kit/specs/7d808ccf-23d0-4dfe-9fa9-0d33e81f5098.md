# /cft:spec-phase コマンドの見直し

**仕様書 ID:** 7d808ccf-23d0-4dfe-9fa9-0d33e81f5098
**フェーズ:** design
**作成日時:** 2025-11-25 12:00
**更新日時:** 2025/11/25 11:24:24

---

## 1. 背景と目的

### 背景

現在、多くの部分がスクリプトで実現されていて、なかなか仕様通りに動作していない。プロンプト指示だと簡単にできることができていない。たいていの処理は、プロンプト指示の方が上手くいく。カスタムスラッシュコマンド→スキル→サブエージェントの構成が上手く実現できていない。改めて、Claude Code のカスタムスラッシュコマンド、スキル、サブエージェントの各機能の仕様についてよく考えて、スクリプトを使わずに仕様を実現できるか再設計して欲しい。スクリプトは最終手段です。ただし、スキル内のスクリプトは OK です。

### 目的

/cft:spec-phase コマンドをプロンプトファースト原則に従って再設計し、スクリプト依存を最小化してカスタムスラッシュコマンド・スキル・サブエージェントの連携を適切に実現する。

---

## 2. 対象ユーザー

- cc-craft-kit を使用する開発者
- 仕様駆動開発（SDD）を実践するチーム

---

## 3. 受け入れ基準

### 必須要件

- [ ] /cft:spec-phase コマンドがプロンプトベースで動作すること
- [ ] スクリプト呼び出しは DB 操作など最小限に抑えること
- [ ] カスタムスラッシュコマンド→スキル→サブエージェントの連携が正しく機能すること

### 機能要件

- [ ] フェーズ遷移の検証がプロンプト内で実行できること
- [ ] Git 操作（ブランチ作成、コミット、PR 作成）がプロンプト指示で実行できること
- [ ] 仕様書のバリデーションがプロンプト内で実行できること
- [ ] completed フェーズ移行時の PR 作成が正しく動作すること

### 非機能要件

- [ ] 既存の仕様書との互換性を維持すること
- [ ] エラーメッセージが分かりやすいこと

---

## 4. 制約条件

- プロンプトファースト原則に従う（スクリプトは最終手段）
- スキル内のスクリプトは許容される
- 既存の DB スキーマは変更しない

---

## 5. 依存関係

- Claude Code のカスタムスラッシュコマンド機能
- Claude Code のスキル機能
- Claude Code のサブエージェント機能（Task ツール）
- pr-creator スキル
- git-operations スキル

---

## 6. 参考情報

- 現在の実装: src/slash-commands/spec-phase.md
- 現在のスクリプト: src/commands/spec/phase.ts
- CLAUDE.md のプロンプトファースト原則セクション

---

## 7. 設計詳細

### 7.1. 現状分析と問題点

#### 現在の実装構造

```
/cft:spec-phase コマンド
├── src/slash-commands/spec-phase.md  # カスタムスラッシュコマンド
│   └── npx tsx .cc-craft-kit/commands/spec/phase.ts を呼び出し
│       └── 以下の処理をすべてスクリプトで実行
│           ├── 引数検証 (Zod)
│           ├── DB クエリ (仕様書取得)
│           ├── GitHub Issue 自動リカバリー
│           ├── ブランチ切り替え
│           ├── フェーズ遷移バリデーション
│           ├── DB 更新
│           ├── Markdown ファイル更新
│           ├── イベント発火
│           └── ガイダンス表示
└── 後処理（プロンプト指示）
    ├── 各フェーズ固有の自動処理
    └── git status チェック
```

#### 問題点

| 問題 | 詳細 | 影響 |
|------|------|------|
| **スクリプト過依存** | ほぼすべての処理を TypeScript スクリプトで実行 | プロンプトの柔軟性を活かせていない |
| **二重定義** | プロンプトとスクリプトで同様の処理を定義 | 仕様の不整合が発生しやすい |
| **自動処理の信頼性** | プロンプト指示の後処理が実行されないことがある | ユーザー体験の低下 |
| **スキル未活用** | pr-creator スキルが存在するが連携が不明確 | 機能の重複 |
| **バリデーションの複雑さ** | TypeScript でプレースホルダー検出を実装 | プロンプトで十分な処理をスクリプト化 |

### 7.2. アーキテクチャ設計（プロンプトファースト版）

#### 新しい実装構造

```
/cft:spec-phase コマンド（再設計後）
├── src/slash-commands/spec-phase.md  # カスタムスラッシュコマンド
│   ├── Step 1: 引数解析・フェーズ名正規化（プロンプト）
│   ├── Step 2: 仕様書 ID 解決（最小スクリプト）
│   │   └── npx tsx .cc-craft-kit/commands/spec/resolve-id.ts
│   │       └── DB クエリのみ（ID → 完全な仕様書情報）
│   ├── Step 3: ブランチ切り替え（Bash）
│   │   └── git checkout <branch-name>
│   ├── Step 4: バリデーション（プロンプト + Read ツール）
│   │   └── 仕様書ファイルを読み込み、セクション・プレースホルダーを検証
│   ├── Step 5: DB 更新 + イベント発火（最小スクリプト）
│   │   └── npx tsx .cc-craft-kit/commands/spec/update-phase.ts
│   │       └── DB 更新 + イベント発火のみ
│   ├── Step 6: Markdown ファイル更新（Edit ツール）
│   │   └── フェーズ行・更新日時を直接編集
│   ├── Step 7: 自動コミット（Bash）
│   │   └── git add + git commit
│   ├── Step 8: フェーズ固有の後処理（分岐）
│   │   ├── tasks → TodoWrite でタスクリスト生成
│   │   ├── implementation → 品質チェック起動
│   │   └── completed → pr-creator スキル起動
│   └── Step 9: git status チェック（Bash）
```

#### 役割分担マトリクス

| 処理 | 現在の実装 | 新設計 | 理由 |
|------|------------|--------|------|
| 引数解析 | スクリプト (Zod) | プロンプト | 単純なマッピングはプロンプトで十分 |
| 仕様書 ID 解決 | スクリプト | **最小スクリプト** | DB クエリは Kysely 必須 |
| ブランチ切り替え | スクリプト (Git) | Bash | `git checkout` で十分 |
| バリデーション | スクリプト | プロンプト + Read | セクション確認はプロンプトで可能 |
| DB 更新 | スクリプト | **最小スクリプト** | Kysely トランザクション必須 |
| Markdown 更新 | スクリプト | Edit ツール | 単純な置換は Edit で十分 |
| イベント発火 | スクリプト | **最小スクリプト** | EventBus は TypeScript 必須 |
| 自動コミット | スクリプト | Bash | `git add/commit` で十分 |
| PR 作成 | 未実装/不安定 | pr-creator スキル | スキルで知識・手順を提供 |
| git status | プロンプト指示 | Bash | 確実に実行させるため明示的に |

### 7.3. スキル設計

#### spec-phase-validator スキル（新規）

フェーズ遷移前のバリデーションをスキルとして分離します。

```yaml
---
name: spec-phase-validator
description: 仕様書のフェーズ遷移前バリデーション。セクションの存在・プレースホルダー検出を実行します。
---
```

**機能:**

1. 必須セクションの存在確認
2. プレースホルダーパターンの検出
3. 不足セクションの自動補完ガイダンス

**実装方法:**

- Read ツールで仕様書ファイルを読み込み
- プロンプトロジックでセクション・パターンを検証
- 不足がある場合は AskUserQuestion または自動補完を提案

#### pr-creator スキル（既存・活用強化）

completed フェーズ移行時に自動的に呼び出されるよう連携を強化します。

**連携方法:**

```markdown
### completed フェーズに移行した場合

Skill ツールで `pr-creator` スキルを実行します。

**実行指示:**
- 仕様書 ID: $SPEC_ID
- 仕様書パス: .cc-craft-kit/specs/$SPEC_ID.md
- GitHub Issue 番号: (DB から取得)
```

### 7.4. 最小スクリプトの設計

スクリプトは以下の 2 つに分離・最小化します。

#### resolve-id.ts（新規）

```typescript
/**
 * 仕様書 ID 解決スクリプト
 *
 * 入力: 部分 ID (例: "7d808ccf")
 * 出力: JSON 形式の仕様書情報
 */
interface ResolveIdOutput {
  success: boolean;
  spec?: {
    id: string;
    name: string;
    phase: string;
    branch_name: string;
    spec_path: string;
    github_issue_number?: number;
  };
  error?: string;
}
```

**処理内容:**
- DB から仕様書を検索（部分一致）
- 結果を JSON 形式で標準出力に出力

#### update-phase.ts（既存を簡略化）

```typescript
/**
 * フェーズ更新スクリプト
 *
 * 入力: spec-id, new-phase
 * 出力: JSON 形式の結果
 */
interface UpdatePhaseOutput {
  success: boolean;
  oldPhase?: string;
  newPhase?: string;
  error?: string;
}
```

**処理内容:**
- DB の phase カラムを更新
- spec.phase_changed イベントを発火
- 結果を JSON 形式で標準出力に出力

**削除する処理:**
- 引数バリデーション（プロンプトで実行）
- ブランチ切り替え（Bash で実行）
- Markdown ファイル更新（Edit ツールで実行）
- ガイダンス表示（プロンプトで実行）

### 7.5. カスタムスラッシュコマンドの設計

#### spec-phase.md（再設計後）

```markdown
---
description: "仕様書のフェーズを更新します"
argument-hint: "<spec-id> <phase>"
---

# 仕様書フェーズ更新

## 引数

- `$1`: 仕様書 ID（部分一致可）
- `$2`: 新しいフェーズ

## フェーズ名マッピング

| 入力 | 正規化後 |
|------|----------|
| req, reqs | requirements |
| des | design |
| task | tasks |
| impl, imp | implementation |
| test | testing |
| comp, done | completed |

---

## 自動実行フロー

重要: 以下の処理を**自動的に実行**してください。

### Step 1: フェーズ名の正規化

`$2` を上記マッピングテーブルに従って正規化します。

### Step 2: 仕様書 ID の解決

Bash ツールで以下を実行:

\`\`\`bash
npx tsx .cc-craft-kit/commands/spec/resolve-id.ts "$1"
\`\`\`

出力を解析し、以下を記録:
- SPEC_ID: 完全な仕様書 ID
- SPEC_NAME: 仕様書名
- CURRENT_PHASE: 現在のフェーズ
- BRANCH_NAME: 関連ブランチ名
- SPEC_PATH: 仕様書ファイルパス

### Step 3: ブランチ切り替え

BRANCH_NAME が設定されている場合、Bash ツールで実行:

\`\`\`bash
git checkout "$BRANCH_NAME"
\`\`\`

### Step 4: バリデーション

Read ツールで仕様書ファイルを読み込み、以下を検証:

**requirements → design の場合:**
- ## 1. 背景と目的 が存在し、内容がある
- ## 2. 対象ユーザー が存在し、内容がある
- ## 3. 受け入れ基準 が存在し、内容がある
- プレースホルダー（"記述してください"等）がないこと

**design → tasks の場合:**
- ## 7. 設計詳細 が存在し、内容がある
- ### 7.x. アーキテクチャ設計 が存在すること
- ### 7.x. テスト戦略 が存在すること

バリデーションエラー時:
- エラーメッセージを表示
- 自動補完を提案（Task: Explore + Edit）
- 処理を中断

### Step 5: DB 更新 + イベント発火

Bash ツールで以下を実行:

\`\`\`bash
npx tsx .cc-craft-kit/commands/spec/update-phase.ts "$SPEC_ID" "$NEW_PHASE"
\`\`\`

### Step 6: Markdown ファイル更新

Edit ツールで仕様書ファイルを更新:

- `**フェーズ:** <current>` → `**フェーズ:** <new>`
- `**更新日時:** <old>` → `**更新日時:** <now>`

### Step 7: 自動コミット

Bash ツールで実行:

\`\`\`bash
git add "$SPEC_PATH" && \
git commit -m "feat: $SPEC_NAME の$(フェーズ名の日本語)を完了"
\`\`\`

### Step 8: フェーズ固有の後処理

#### tasks フェーズの場合

1. 仕様書の「3. 受け入れ基準」を解析
2. TodoWrite でタスクリストを生成
3. Edit で「## 8. 実装タスクリスト」セクションを追加

#### implementation フェーズの場合

1. Skill ツールで `typescript-eslint` を実行
2. 型エラー・ESLint 警告があれば表示

#### completed フェーズの場合

1. Skill ツールで `pr-creator` を実行
2. PR 作成結果を表示

### Step 9: git status チェック

Bash ツールで実行:

\`\`\`bash
git status --porcelain
\`\`\`

出力に応じてメッセージを表示。

---

## 成功メッセージ

\`\`\`
✓ フェーズを更新しました

仕様書: $SPEC_NAME
フェーズ: $CURRENT_PHASE → $NEW_PHASE

次のステップ:
- ...
\`\`\`
```

### 7.6. テスト戦略

#### 単体テスト

| 対象 | テスト内容 | モック |
|------|------------|--------|
| resolve-id.ts | 部分 ID → 完全情報の解決 | DB (in-memory) |
| update-phase.ts | フェーズ更新 + イベント発火 | DB (in-memory), EventBus |

#### 統合テスト

| シナリオ | 検証内容 |
|----------|----------|
| 正常フロー | requirements → design → tasks → impl → completed |
| バリデーションエラー | 不足セクションがある場合の中断 |
| completed フェーズ | PR 作成が正しく動作 |

#### E2E テスト

| シナリオ | 検証内容 |
|----------|----------|
| 実際のコマンド実行 | `/cft:spec-phase <id> <phase>` の動作確認 |
| スキル連携 | pr-creator スキルの自動実行 |

### 7.7. 移行計画

#### Phase 1: 最小スクリプトの作成

1. resolve-id.ts を新規作成
2. update-phase.ts を簡略化（既存の phase.ts をリファクタリング）
3. 単体テストを追加

#### Phase 2: カスタムスラッシュコマンドの更新

1. spec-phase.md を再設計後の内容に更新
2. プロンプト内でのバリデーションロジックを実装
3. スキル連携（pr-creator）を追加

#### Phase 3: 旧実装の削除

1. 不要になったスクリプトコードを削除
2. テストを更新
3. ドキュメントを更新

### 7.8. セキュリティ考慮事項

| 項目 | 対策 |
|------|------|
| SQL インジェクション | Kysely のパラメータ化クエリを継続使用 |
| コマンドインジェクション | Bash 引数はダブルクォートで囲む |
| 認証情報漏洩 | GITHUB_TOKEN は環境変数で管理 |

---

## 8. 実装タスクリスト

### 準備タスク

- [ ] resolve-id.ts スクリプトを新規作成
- [ ] update-phase.ts スクリプトを簡略化

### 本体タスク

- [ ] spec-phase.md をプロンプトファースト版に更新
- [ ] バリデーションロジックをプロンプト内で実装
- [ ] pr-creator スキルとの連携を実装
- [ ] 各フェーズ固有の後処理を実装

### テストタスク

- [ ] resolve-id.ts の単体テストを作成
- [ ] update-phase.ts の単体テストを更新
- [ ] 統合テストを追加

### クリーンアップタスク

- [ ] 旧 phase.ts の不要コードを削除
- [ ] ドキュメントを更新
