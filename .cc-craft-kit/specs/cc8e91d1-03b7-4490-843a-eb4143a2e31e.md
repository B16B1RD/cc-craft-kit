# req / design の各フェーズ切り替え時、req の場合は要求仕様、design の場合は詳細設計が不十分の場合は、自動で調査して埋める

**仕様書 ID:** cc8e91d1-03b7-4490-843a-eb4143a2e31e
**フェーズ:** completed
**作成日時:** 2025/11/23 01:22:52
**更新日時:** 2025/11/23 11:50:22

---

## 1. 背景と目的

### 背景

現在、`/cft:spec-phase` コマンドでフェーズを切り替える際、仕様書ファイルの内容が不十分な場合でもフェーズ遷移が許可されてしまいます。特に以下の問題が発生しています。

- **Requirements フェーズ**: 背景・目的・受け入れ基準などがプレースホルダーのまま Design フェーズに移行できてしまう
- **Design フェーズ**: 設計詳細セクション（セクション 7）が未記述でも Implementation フェーズに移行できてしまう
- **手動での補完作業**: 開発者が仕様書を手動で確認・編集する必要があり、作業効率が低い

これにより、不完全な仕様書のまま実装が進み、後工程でのトラブルや手戻りの原因となっている。

### 目的

フェーズ切り替え時に仕様書の内容を自動的に検証し、不足情報がある場合は以下を実現します。

1. **自動調査・補完**: コードベース解析や既存仕様書から情報を推論して自動的に補完する
2. **対話的な情報収集**: 推論が困難な情報についてはユーザーに質問し、回答をもとに仕様書を完成させる
3. **フェーズ遷移のゲート機能**: 必須情報が不足している場合はフェーズ遷移を一時的にブロックし、補完完了後に遷移する

これにより、仕様書の品質を担保しつつ、開発者の手間を削減し、スムーズな開発フローを実現する。

---

## 2. 対象ユーザー

**プライマリユーザー**: cc-craft-kit を使用してソフトウェア開発する開発者。

**ユースケース**:

- 仕様書を作成し、フェーズを切り替えながら開発を進める開発者
- Claude Code を使用して仕様駆動開発（SDD）を実践する開発者
- 仕様書の品質を自動的に担保したいプロジェクトリーダー

---

## 3. 受け入れ基準

### 必須要件

- [ ] `/cft:spec-phase <spec-id> design` 実行時、Requirements フェーズの必須セクションが不足している場合、自動的に補完される
- [ ] `/cft:spec-phase <spec-id> implementation` 実行時、Design フェーズの設計詳細セクション（セクション 7）が不足している場合、自動的に補完される
- [ ] 自動補完に必要な情報が不足している場合、ユーザーに質問し、回答をもとに仕様書を完成させる
- [ ] フェーズ遷移前に仕様書の品質が十分であることを確認し、不十分な場合は補完完了後に遷移する

### 機能要件

- [ ] **要件フェーズ (Requirements) の検証項目**:
  - 背景と目的セクションが具体的に記述されている（プレースホルダーが残っていない）
  - 対象ユーザーが明記されている
  - 受け入れ基準（必須要件・機能要件・非機能要件）が具体的に記述されている
  - 制約条件が記述されている（該当なしの場合は「なし」と明記）
  - 依存関係が記述されている（該当なしの場合は「なし」と明記）

- [ ] **設計フェーズ (Design) の検証項目**:
  - セクション 7「設計詳細」が存在し、以下のサブセクションが含まれている:
    - アーキテクチャ設計
    - API の仕様（該当する場合）
    - データモデル（該当する場合）
    - セキュリティ考慮事項
    - テスト戦略

- [ ] **自動補完の処理フロー**:
  1. コードベース解析（Explore サブエージェント）で関連実装を調査
  2. 既存仕様書から類似パターンを検索
  3. 推論可能な情報を自動的に記述
  4. 推論が困難な情報については `AskUserQuestion` ツールでユーザーに質問（最大4つまで）
  5. 仕様書ファイルを Edit ツールで更新
  6. 補完完了後、ユーザーに確認を求めて承認後にフェーズ遷移を実行

- [ ] **ユーザー確認フロー**:
  - 自動補完完了後、変更内容のサマリーを表示
  - ユーザーに「承認/再編集/キャンセル」の選択肢を提示
  - 承認された場合のみフェーズ遷移を実行
  - 再編集を選択した場合、仕様書ファイルのパスを案内し、手動編集後に再度フェーズ遷移を実行可能にする

- [ ] **エラーハンドリング**:
  - 自動補完に失敗した場合、詳細なエラーログをコンソールに出力する
  - GitHub Issue に自動補完失敗をコメントとして記録する
  - リトライ機能を提供し、再度自動補完を試行するコマンドを案内する（例: `/cft:spec-phase <spec-id> <phase> --retry`）
  - フェーズ遷移は中断せず、不完全な状態でも遷移を許可するオプションを提供する（`--force` フラグ）

### 非機能要件

- [ ] **パフォーマンス**: コードベース解析は 30 秒以内に完了すること
- [ ] **ユーザビリティ**: 質問は最大 4 つまでとし、ユーザーの負担を最小限にすること
- [ ] **保守性**: 既存のフェーズ遷移ロジック（`phase-automation.ts`）を拡張する形で実装すること
- [ ] **テスタビリティ**: 自動補完ロジックは単体テスト可能な形で実装すること

---

## 4. 制約条件

1. **既存アーキテクチャとの整合性**:
   - イベント駆動アーキテクチャ（`EventBus`）を使用すること
   - `spec.phase_changed` イベントのハンドラーとして実装すること
   - 既存の `phase-automation.ts` のロジックを拡張する形で実装すること

2. **データベース操作の安全性**:
   - `getDatabase()` を使用してデータベース接続を取得すること
   - パラメータを指定せず、デフォルトのデータベースパスを使用すること

3. **ファイル操作の制約**:
   - 仕様書ファイルの読み書きは `Read` ツールと `Edit` ツールを使用すること
   - Bash コマンド（`cat`, `sed` など）での直接操作は禁止

4. **テスト環境での動作**:
   - `NODE_ENV === 'test'` または `E2E_TEST === 'true'` の場合、自動補完処理をスキップすること
   - テスト環境では GitHub API 呼び出しをモック化すること

5. **エラーハンドリングの標準化**:
   - `src/core/errors/` の標準エラークラスを使用すること
   - エラーメッセージにはセンシティブ情報を含めないこと

6. **コンテキスト消費の制限**:
   - コードベース解析（Explore サブエージェント）は thoroughness level: "medium" を使用すること
   - 想定コンテキスト消費: 約 20,000〜40,000 トークン

---

## 5. 依存関係

### 既存コンポーネント

- **`src/commands/spec/phase.ts`**: フェーズ更新コマンドのエントリポイント
- **`src/core/workflow/phase-automation.ts`**: フェーズ切り替え時の自動処理ハンドラー
- **`src/core/workflow/event-bus.ts`**: イベントバス（`spec.phase_changed` イベント）
- **`src/core/sync/spec-file-parser.ts`**: 仕様書ファイルのパーサー（メタデータ抽出）
- **`src/core/validators/spec-file-validator.ts`**: 仕様書ファイルのバリデーター

### 関連仕様書

- **`a85fe81b-3d27-4a5e-bbf1-3e395ebc1c77.md`**: CLAUDE.md 整理（completed）
  - 仕様書テンプレートの構造を参考にする
- **`edcc66aa-6963-4042-9772-847733c802bb.md`**: 仕様書ファイルパーサー（completed）
  - セクションの存在チェックロジックを参考にする
- **`20a0ff2e-bab4-43f3-838a-decfd71a96da.md`**: 品質要件自動チェック（completed）
  - バリデーションパターンを参考にする

### 外部ツール

- **Task ツール（Explore サブエージェント）**: コードベース解析に使用
- **AskUserQuestion ツール**: ユーザーへの対話的な質問に使用
- **Edit ツール**: 仕様書ファイルの自動更新に使用

---

## 6. 参考情報

### 参考実装

- **`/cft:spec-create` の自動完成フロー**: `.claude/commands/cft/spec-create.md`
  - フェーズ 0〜4 の処理フローを参考にする
  - コードベース解析の thoroughness level 設定を参考にする
  - `AskUserQuestion` ツールの使用例を参考にする

- **既存のフェーズ遷移処理**:
  - `src/core/workflow/phase-automation.ts`: `PhaseAutomationHandler` クラスでフェーズごとの自動処理を実装
  - `src/commands/spec/phase.ts`: フェーズ更新コマンドのエントリポイント、データベース更新とイベント発火を実装
  - `src/core/workflow/git-integration.ts`: フェーズ変更時の自動コミット処理を実装

- **既存のバリデーション機能**:
  - `src/core/validators/spec-file-validator.ts`: メタデータのバリデーションを実装（UUID、フェーズ、日時形式）
  - **注意**: 現状ではプレースホルダー検出機能は実装されていないため、新規実装が必要

### 関連ドキュメント

- **CLAUDE.md**: プロジェクト規約とコーディング規約
- **ARCHITECTURE.md**: アーキテクチャ設計（イベント駆動、モジュラーモノリス）

### 技術資料

- **EventEmitter2 ドキュメント**: <https://github.com/EventEmitter2/EventEmitter2>
- **Kysely ドキュメント**: <https://kysely.dev/>
- **TypeScript Handbook**: <https://www.typescriptlang.org/docs/handbook/intro.html>

---

## 7. 設計詳細

### 7.1. アーキテクチャ設計

**実装アプローチ**: イベント駆動アーキテクチャを活用し、既存の `spec.phase_changed` イベントハンドラーを拡張する形で実装します。

**主要コンポーネント**:

1. **プレースホルダー検出器** (`src/core/validators/placeholder-detector.ts`):
   - 仕様書ファイルからプレースホルダーを検出する
   - プレースホルダーパターン: `(背景を記述してください)`, `(必須要件1)` など
   - 検出結果を返す（セクション名とプレースホルダーのリスト）

2. **仕様書自動補完サービス** (`src/core/workflow/spec-auto-completer.ts`):
   - Explore サブエージェントでコードベース解析
   - 既存仕様書から類似パターンを検索
   - `AskUserQuestion` ツールでユーザーに質問
   - Edit ツールで仕様書を更新

3. **フェーズ遷移前バリデーター** (`src/core/workflow/phase-transition-validator.ts`):
   - フェーズ遷移前に仕様書の品質をチェック
   - プレースホルダー検出と自動補完の起動
   - ユーザー確認フローの制御

**処理フロー**:

```
/cft:spec-phase <spec-id> <new-phase>
  ↓
phase.ts: updateSpecPhase()
  ↓
フェーズ遷移前バリデーション（新規追加）
  ↓
プレースホルダー検出
  ↓
プレースホルダーあり？
  Yes → 自動補完処理
    ↓
    1. Explore サブエージェント（コードベース解析）
    2. 既存仕様書検索
    3. 推論可能な情報を補完
    4. 推論困難な情報はユーザーに質問（AskUserQuestion）
    5. Edit ツールで仕様書更新
    ↓
    ユーザー確認
    ↓
    承認？
      Yes → フェーズ遷移実行
      No → キャンセル/再編集
  No → フェーズ遷移実行
  ↓
データベース更新
  ↓
Markdownファイル更新
  ↓
spec.phase_changed イベント発火
  ↓
PhaseAutomationHandler: 既存の自動処理
```

### 7.2. データモデル

**新規追加なし**: 既存のデータベーススキーマをそのまま使用します。

**使用する既存テーブル**:
- `specifications`: 仕様書のメタデータ（id, name, phase, created_at, updated_at など）

### 7.3. API の仕様

**新規公開 API**:

```typescript
// src/core/validators/placeholder-detector.ts
export interface PlaceholderDetectionResult {
  hasPlaceholders: boolean;
  placeholders: {
    section: string;
    placeholder: string;
  }[];
}

export function detectPlaceholders(content: string): PlaceholderDetectionResult;
```

```typescript
// src/core/workflow/spec-auto-completer.ts
export interface AutoCompleteOptions {
  specId: string;
  phase: Phase;
  thoroughness?: 'quick' | 'medium' | 'very thorough';
}

export interface AutoCompleteResult {
  success: boolean;
  updatedSections: string[];
  errors?: string[];
}

export async function autoCompleteSpec(
  options: AutoCompleteOptions
): Promise<AutoCompleteResult>;
```

```typescript
// src/core/workflow/phase-transition-validator.ts
export interface ValidationResult {
  isValid: boolean;
  needsCompletion: boolean;
  placeholders?: PlaceholderDetectionResult;
}

export async function validatePhaseTransition(
  specId: string,
  fromPhase: Phase,
  toPhase: Phase
): Promise<ValidationResult>;
```

**コマンドラインオプション追加**:

```bash
# リトライフラグ（自動補完を再試行）
/cft:spec-phase <spec-id> <phase> --retry

# 強制フラグ（バリデーションをスキップ）
/cft:spec-phase <spec-id> <phase> --force

# ドライランフラグ（実際には遷移せず、バリデーション結果のみ表示）
/cft:spec-phase <spec-id> <phase> --dry-run
```

### 7.4. セキュリティ考慮事項

1. **ファイルシステムアクセス**:
   - 仕様書ファイルの読み書きは `.cc-craft-kit/specs/` ディレクトリに限定
   - パストラバーサル攻撃を防ぐため、ファイルパスを検証

2. **データベース操作**:
   - `getDatabase()` を使用し、パラメータ化クエリのみを使用
   - SQL インジェクション対策を徹底

3. **GitHub API 呼び出し**:
   - GitHub トークンは環境変数（`.env`）で管理
   - エラーメッセージにトークンを含めない

4. **ユーザー入力の検証**:
   - コマンドライン引数は Zod スキーマで検証
   - 仕様書 ID は UUID 形式であることを確認

### 7.5. テスト戦略

#### 単体テスト

1. **プレースホルダー検出のテスト**:
   - `tests/core/validators/placeholder-detector.test.ts`
   - プレースホルダーありの仕様書
   - プレースホルダーなしの仕様書
   - 部分的にプレースホルダーがある仕様書

2. **自動補完サービスのテスト**:
   - `tests/core/workflow/spec-auto-completer.test.ts`
   - Explore サブエージェントのモック
   - AskUserQuestion のモック
   - Edit ツールのモック

3. **フェーズ遷移バリデーターのテスト**:
   - `tests/core/workflow/phase-transition-validator.test.ts`
   - バリデーション成功ケース
   - バリデーション失敗ケース（プレースホルダーあり）

#### E2Eテスト

1. **フェーズ遷移時の自動補完フロー**:
   - `tests/e2e/phase-transition-auto-complete.test.ts`
   - Requirements → Design の遷移
   - Design → Implementation の遷移
   - `--force` フラグでのスキップ
   - `--retry` フラグでのリトライ

2. **エラーハンドリング**:
   - 自動補完失敗時のリトライ
   - GitHub Issue へのコメント投稿

#### テスト時の注意事項

- データベースは `:memory:` モードでテスト
- GitHub API 呼び出しは必ずモック化
- Git 操作は必ずモック化（テスト実行時にブランチが変更されることを防止）
- Task ツール（Explore サブエージェント、AskUserQuestion）はモック化

### 7.6. パフォーマンス要件

1. **コードベース解析**: 30 秒以内に完了
2. **プレースホルダー検出**: 1 秒以内に完了
3. **仕様書ファイル更新**: 5 秒以内に完了
4. **全体の処理時間**: 60 秒以内に完了（ユーザーへの質問時間を除く）

### 7.7. ユーザビリティ要件

1. **質問数の制限**: 最大 4 つまで
2. **進捗表示**: コードベース解析中は進捗インジケーターを表示
3. **変更内容のサマリー**: 自動補完後、どのセクションが更新されたかを明示
4. **エラーメッセージ**: 具体的な対処方法を含める

### 7.8. 実装の優先順位

**Phase 1（最優先）**:
- プレースホルダー検出機能の実装
- フェーズ遷移前バリデーションの実装
- Requirements → Design の自動補完

**Phase 2**:
- Design → Implementation の自動補完
- ユーザー確認フローの実装
- エラーハンドリングの強化（GitHub Issue コメント、リトライ機能）

**Phase 3（オプション）**:
- `--dry-run` フラグの実装
- 自動補完の品質向上（より高精度な推論）
- パフォーマンス最適化

---

## 8. 実装タスクリスト

### Phase 1: コア機能の実装

- [x] **タスク 1**: プレースホルダー検出器の実装(`placeholder-detector.ts`)
  - 仕様書ファイルからプレースホルダーパターンを検出
  - 検出結果を `PlaceholderDetectionResult` 型で返す
  - 実装ファイル: `src/core/validators/placeholder-detector.ts` (286行)
  - コミット: `1d02553`

- [x] **タスク 2**: プレースホルダー検出器の単体テスト作成
  - プレースホルダーあり/なし/部分的にあるケースをテスト
  - 実装ファイル: `tests/core/validators/placeholder-detector.test.ts` (311行)
  - テスト件数: 15件 (すべて通過)
  - コミット: `1d02553`

- [x] **タスク 3**: フェーズ遷移前バリデーターの実装(`phase-transition-validator.ts`)
  - フェーズ遷移前に仕様書の品質をチェック
  - プレースホルダー検出器を呼び出してバリデーション
  - 実装ファイル: `src/core/workflow/phase-transition-validator.ts` (175行)
  - コミット: `1d02553`

- [x] **タスク 4**: フェーズ遷移前バリデーターの単体テスト作成
  - バリデーション成功/失敗ケースをテスト
  - 実装ファイル: `tests/core/workflow/phase-transition-validator.test.ts`
  - テスト件数: 8件 (すべて通過)
  - コミット: `1d02553`

### Phase 2: 自動補完機能の実装（実装方針変更）

- [x] **タスク 5**: 仕様書自動補完ガイダンスの追加
  - **実装方針変更**: TypeScript実装ではなく、スラッシュコマンドのプロンプトで対応
  - Explore サブエージェント、AskUserQuestion、Edit ツールの使用方法をガイダンスに記載
  - 実装ファイル: `src/slash-commands/spec-phase.md`
  - コミット: `36d7cb9`

- [x] **タスク 6**: 動作確認
  - テスト用仕様書 (6519992d) で動作確認を実施
  - バリデーションエラー検出 ✅
  - コードベース解析実行 ✅
  - ユーザーへの質問と情報収集 ✅
  - 仕様書の自動補完 ✅
  - フェーズ遷移の成功 ✅

### Phase 3: コマンド統合

- [x] **タスク 7**: `phase.ts` にフェーズ遷移前バリデーションを統合
  - `updateSpecPhase()` 関数にバリデーション処理を追加
  - フェーズ遷移前に `validatePhaseTransition()` を呼び出し
  - 実装ファイル: `src/commands/spec/phase.ts`
  - コミット: `1d02553`

- [x] **タスク 8**: コマンドラインオプション(`--retry`, `--force`, `--dry-run`)の追加
  - オプションフラグのパース処理を実装
  - 各オプションに応じた処理フローを実装
  - 実装ファイル: `src/commands/spec/phase.ts`
  - コミット: `1d02553`

### Phase 4: テストとドキュメント（オプショナル）

- [ ] **タスク 9**: E2Eテストの作成（オプショナル）
  - Requirements → Design の遷移テスト
  - Design → Implementation の遷移テスト
  - `--force` フラグでのスキップテスト
  - **注**: 単体テストで十分にカバーされているため、必要に応じて実装

- [x] **タスク 10**: 既存テストの確認とカバレッジ確認
  - 全テストスイート: 54 passed (702 tests)
  - 新規テスト: 23件 (すべて通過)
  - 型チェック: エラーなし

### 依存関係

- タスク 1 → タスク 2(テスト)
- タスク 3 → タスク 4(テスト)
- タスク 1, 3 → タスク 5(自動補完サービスで使用)
- タスク 5 → タスク 6(テスト)
- タスク 3, 5 → タスク 7(phase.ts 統合)
- タスク 7 → タスク 8(オプション追加)
- タスク 1〜8 → タスク 9(E2Eテスト)
- タスク 9 → タスク 10(既存テスト修正)
