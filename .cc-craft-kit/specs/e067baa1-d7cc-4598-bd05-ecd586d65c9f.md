# /cft:spec-phase xxx design としてもフェーズが切り替わるだけで設計作業を自動で進めてくれない

**仕様書 ID:** e067baa1-d7cc-4598-bd05-ecd586d65c9f
**フェーズ:** completed
**作成日時:** 2025/11/19 10:54:04
**更新日時:** 2025/11/19 11:12:09

---

## 1. 背景と目的

### 背景

本来どのフェーズ切り替えにおいても自動でそのフェーズでやるべきことを自動で処理する仕様としているがそれが実現できていない。また、その処理において自動で処理できないときはユーザーに不足している情報を問い合わせるようにしたい。

### 目的

1. **手動作業の削減**: フェーズ切り替え後の手動作業を自動化し、開発者の負担を軽減する
2. **品質向上**: 各フェーズで必要な作業を自動実行し、作業漏れを防ぐ
3. **標準化**: 全仕様書で一貫したワークフローを実現する

---

## 2. 対象ユーザー

- cc-craft-kit を使用する開発者
- 仕様駆動開発（SDD）を実践するチーム
- Claude Code を使用してプロジェクト管理を行うユーザー

---

## 3. 受け入れ基準

### 必須要件

- [ ] 各フェーズ切り替え時に、そのフェーズで必要な作業を自動で実行すること
- [ ] 自動処理できない場合は、AskUserQuestion ツールで不足情報を問い合わせること
- [ ] ユーザーの明示的な確認なしに自動処理を開始すること（CLAUDE.md の指示通り）
- [ ] 各フェーズの自動処理完了後、次のステップを明確に案内すること

### 機能要件（フェーズ別）

#### requirements フェーズ
- [ ] 仕様書テンプレートを自動展開すること
- [ ] GitHub Issue を自動作成すること（GitHub 統合が有効な場合）
- [ ] 仕様書ファイルを Read ツールで読み込み、不足セクションを検出すること
- [ ] 不足情報がある場合は、AskUserQuestion で問い合わせること

#### design フェーズ
- [ ] 要件定義を Read ツールで読み込み、設計が必要な箇所を特定すること
- [ ] アーキテクチャ設計セクションを自動生成すること
- [ ] API 設計セクションを自動生成すること
- [ ] データモデル設計セクションを自動生成すること
- [ ] 不足情報がある場合は、AskUserQuestion で問い合わせること

**問い合わせ対象:**
- [ ] アーキテクチャパターンが明示されていない場合:「モノリス or マイクロサービス?」
- [ ] データベース種別が不明な場合:「使用するデータベースは? (SQLite/PostgreSQL/MySQL)」
- [ ] API 形式が不明な場合:「API 形式は? (REST/GraphQL/gRPC)」
- [ ] 認証方式が不明な場合:「認証方式は? (JWT/Session/OAuth2)」

#### tasks フェーズ
- [ ] 受け入れ基準（3. 受け入れ基準）を解析すること
- [ ] TodoWrite ツールで実装タスクリストを作成すること
- [ ] 仕様書ファイルに「## 8. 実装タスクリスト」セクションを追加すること
- [ ] `/cft:spec-update` で GitHub Issue に更新を通知すること

#### implementation フェーズ
- [ ] Skill ツールで `typescript-eslint` スキルを実行し、既存コードをチェックすること
- [ ] 「## 8. 実装タスクリスト」を TodoWrite ツールで表示すること
- [ ] 最初の未完了タスクを in_progress に設定すること
- [ ] 実装対象ファイルを Read ツールで読み込み、現在の実装状況を確認すること
- [ ] ユーザーに実装の準備が整ったことを通知すること
- [ ] 各タスク完了後、test-generator サブエージェントでテスト生成すること
- [ ] 各タスク完了後、code-reviewer サブエージェントでコードレビューすること
- [ ] TodoWrite で completed に設定し、次のタスクへ自動移行すること

**問い合わせ対象:**
- [ ] 実装対象ファイルが特定できない場合:「実装対象ファイルのパスを指定してください」
- [ ] テストフレームワークが不明な場合:「使用するテストフレームワークは? (Jest/Vitest/Mocha)」

#### completed フェーズ
- [ ] code-reviewer サブエージェントで最終レビューを実行すること
- [ ] git-operations スキルで変更差分を確認すること
- [ ] Git 自動コミットを実行すること（イベント駆動で実装済み）
- [ ] GitHub Issue のステータスを Done に更新すること

### 非機能要件

- [ ] 自動処理の各ステップを `info` レベルでログに記録すること
- [ ] ログフォーマット: `[PhaseAutomation] <phase>: <message>`
- [ ] エラー発生時は `error` レベルでログ記録し、適切なエラーメッセージを表示すること
- [ ] ユーザーへの通知メッセージは標準出力に表示すること
- [ ] 既存の EventBus アーキテクチャを活用すること
- [ ] スラッシュコマンドの実装を変更せず、自動処理ロジックを追加すること

### テストシナリオ

#### シナリオ1: 完全自動フロー

1. `/cft:spec-create "test-spec"` で仕様書作成
2. 要件定義を手動で記述
3. `/cft:spec-phase <spec-id> design` 実行
4. 設計セクションが自動生成されることを確認
5. `/cft:spec-phase <spec-id> tasks` 実行
6. 実装タスクリストが自動生成されることを確認
7. `/cft:spec-phase <spec-id> implementation` 実行
8. TypeScript/ESLint チェックが自動実行されることを確認
9. `/cft:spec-phase <spec-id> completed` 実行
10. コードレビュー・Git コミットが自動実行されることを確認

#### シナリオ2: 不足情報の問い合わせフロー

1. 要件定義にデータベース種別が未記載の仕様書を作成
2. `/cft:spec-phase <spec-id> design` 実行
3. AskUserQuestion でデータベース種別を問い合わせることを確認
4. 回答後、設計が正常に生成されることを確認

---

## 4. 技術仕様

### アーキテクチャ

- EventBus のイベントハンドラーチェーン方式を採用
- 各フェーズごとに専用のハンドラー関数を実装
- `spec.phase_changed` イベントをトリガーとして自動処理を起動

### 実装対象ファイル

- `src/core/workflow/phase-automation.ts` - フェーズ自動処理ロジック（新規作成）
- `src/core/workflow/event-bus.ts` - イベントハンドラー登録（既存ファイルに追加）
- `src/slash-commands/spec-phase.md` - スラッシュコマンド定義（参照のみ）

### データフロー

1. `/cft:spec-phase <spec-id> <phase>` 実行
2. `spec.phase_changed` イベント発火
3. `PhaseAutomationHandler` が新フェーズを検出
4. フェーズ別処理関数を実行
5. 完了通知またはエラー通知

### エラーハンドリング

- AskUserQuestion 失敗時: デフォルト値で続行し、警告ログ出力
- サブエージェント実行失敗時: エラーログ出力し、ユーザーに手動実行を案内
- スキル実行失敗時: 警告ログ出力し、次の処理へ継続

---

## 5. 制約条件

- 既存のスラッシュコマンド定義（`src/slash-commands/spec-phase.md`）は変更しない
- EventBus のイベント駆動アーキテクチャを維持する
- `getEventBusAsync()` を使用してハンドラー登録を待機する
- AskUserQuestion ツールは Claude Code の標準ツールを使用する
- サブエージェント（code-reviewer, test-generator）は Task ツールで実行する
- スキル（typescript-eslint, git-operations）は Skill ツールで実行する

---

## 6. 依存関係

- `src/core/workflow/event-bus.ts` - イベント駆動アーキテクチャ
- `src/core/workflow/git-integration.ts` - Git 自動コミット機能
- `src/integrations/github/sync.ts` - GitHub 同期機能
- `.claude/agents/code-reviewer.md` - コードレビューサブエージェント
- `.claude/agents/test-generator.md` - テスト生成サブエージェント
- `.claude/skills/typescript-eslint/SKILL.md` - TypeScript/ESLint スキル
- `.claude/skills/git-operations/SKILL.md` - Git 操作スキル

---

## 7. 設計

### 7.1 アーキテクチャ設計

#### クラス構造

```typescript
// src/core/workflow/phase-automation.ts
@injectable()
export class PhaseAutomationHandler {
  constructor(
    private db: Kysely<Database>,
    private specRepository: SpecRepository,
    private githubSync: GitHubSyncService
  ) {}

  async handlePhaseChange(event: PhaseChangedEvent): Promise<void> {
    const { specId, newPhase, oldPhase } = event.data;

    switch (newPhase) {
      case 'requirements':
        await this.handleRequirementsPhase(specId);
        break;
      case 'design':
        await this.handleDesignPhase(specId);
        break;
      case 'tasks':
        await this.handleTasksPhase(specId);
        break;
      case 'implementation':
        await this.handleImplementationPhase(specId);
        break;
      case 'completed':
        await this.handleCompletedPhase(specId);
        break;
    }
  }

  private async handleDesignPhase(specId: string): Promise<void> {
    // 要件定義を読み込む
    // 設計セクションを自動生成
    // 不足情報を問い合わせ
  }

  // 他のフェーズハンドラー...
}
```

#### イベントハンドラー登録

```typescript
// src/core/workflow/event-bus.ts に追加
export async function getEventBusAsync(): Promise<EventBus> {
  // 既存のコード...

  // フェーズ自動処理ハンドラー登録
  const phaseAutomationHandler = container.resolve(PhaseAutomationHandler);
  eventBus.on('spec.phase_changed', (event) =>
    phaseAutomationHandler.handlePhaseChange(event)
  );

  return eventBus;
}
```

### 7.2 データモデル設計

既存のスキーマで対応可能（変更なし）。

### 7.3 API設計

内部 API のため、外部 API は不要。

### 7.4 UI/UX設計

CLI 出力メッセージの設計:

```typescript
// design フェーズ移行時の出力例
console.log(`✓ 要件定義を読み込みました`);
console.log(`✓ アーキテクチャ設計を生成しました`);
console.log(`✓ API設計を生成しました`);
console.log(`✓ データモデル設計を生成しました`);
console.log(`\n次のステップ: 設計内容を確認し、/cft:spec-phase ${specId} tasks でタスク分解へ進んでください`);
```

#### design フェーズ - 自動生成内容

**アーキテクチャ設計セクション:**
- システム構成図（Mermaid 図）
- レイヤー構造（プレゼンテーション層、ビジネスロジック層、データ層）
- 使用する設計パターン（DI、Repository、Factory 等）

**API設計セクション:**
- エンドポイント一覧（メソッド、パス、リクエスト/レスポンス）
- エラーレスポンス仕様
- 認証・認可方式

**データモデル設計セクション:**
- エンティティ図（ER 図）
- テーブル定義（カラム名、型、制約）
- インデックス設計

---

## 8. 参考情報

### 関連ドキュメント

- [CLAUDE.md - /cft:spec-phase の動作](./CLAUDE.md#cftspec-phase-の動作)
- [ARCHITECTURE.md - イベント駆動アーキテクチャ](./docs/ARCHITECTURE.md#イベント駆動アーキテクチャ)

### 参考実装

- `src/core/workflow/git-integration.ts` - Git 自動コミットの実装例
- `src/core/workflow/event-bus.ts` - イベントハンドラー登録パターン

### Claude Code ツールリファレンス

- [AskUserQuestion ツール](https://docs.anthropic.com/claude/docs/tools#askuserquestion)
- [Task ツール（サブエージェント実行）](https://docs.anthropic.com/claude/docs/tools#task)
- [Skill ツール](https://docs.anthropic.com/claude/docs/tools#skill)

---

## 9. 実装タスクリスト

### タスク概要

以下のタスクを順番に実装していきます。各タスクは依存関係に基づいて順序付けられています。

### 実装タスク

#### 1. PhaseAutomationHandler クラスの実装
- **ファイル**: `src/core/workflow/phase-automation.ts`（新規作成）
- **内容**:
  - `@injectable()` デコレータを使用した DI 対応クラス
  - `handlePhaseChange` メソッドで `spec.phase_changed` イベントを処理
  - フェーズごとの分岐処理（requirements, design, tasks, implementation, completed）
- **依存関係**: なし
- **優先度**: 高

#### 2. handleRequirementsPhase メソッドの実装
- **ファイル**: `src/core/workflow/phase-automation.ts`
- **内容**:
  - 仕様書ファイルを Read ツールで読み込む（実際には fs.readFile を使用）
  - 不足セクションを検出
  - AskUserQuestion で不足情報を問い合わせる（Claude Code の処理として実装）
  - GitHub Issue 自動作成（既存の GitHubSyncService を活用）
- **依存関係**: タスク 1
- **優先度**: 中

#### 3. handleDesignPhase メソッドの実装
- **ファイル**: `src/core/workflow/phase-automation.ts`
- **内容**:
  - 要件定義セクションを解析
  - 設計セクション（7. 設計）を自動生成
  - 不足情報がある場合は AskUserQuestion で問い合わせ
  - 仕様書ファイルに設計内容を追記
- **依存関係**: タスク 1
- **優先度**: 高

#### 4. handleTasksPhase メソッドの実装
- **ファイル**: `src/core/workflow/phase-automation.ts`
- **内容**:
  - 受け入れ基準（3. 受け入れ基準）を解析
  - TodoWrite で実装タスクリストを生成（Claude Code の処理として実装）
  - 仕様書ファイルに「## 9. 実装タスクリスト」セクションを追加
  - `/cft:spec-update` で GitHub Issue に更新を通知
- **依存関係**: タスク 1
- **優先度**: 高

#### 5. handleImplementationPhase メソッドの実装
- **ファイル**: `src/core/workflow/phase-automation.ts`
- **内容**:
  - typescript-eslint スキルを実行（Claude Code の処理として実装）
  - 「## 9. 実装タスクリスト」を読み込み、TodoWrite で表示
  - 最初の未完了タスクを in_progress に設定
  - 実装対象ファイルを確認し、準備完了を通知
- **依存関係**: タスク 1、タスク 4
- **優先度**: 高

#### 6. handleCompletedPhase メソッドの実装
- **ファイル**: `src/core/workflow/phase-automation.ts`
- **内容**:
  - code-reviewer サブエージェントで最終レビュー（Claude Code の処理として実装）
  - git-operations スキルで変更差分を確認（Claude Code の処理として実装）
  - GitHub Issue のステータスを Done に更新（既存の GitHubSyncService を活用）
- **依存関係**: タスク 1
- **優先度**: 中

#### 7. event-bus.ts にイベントハンドラー登録を追加
- **ファイル**: `src/core/workflow/event-bus.ts`
- **内容**:
  - `getEventBusAsync` 関数に PhaseAutomationHandler の登録を追加
  - `spec.phase_changed` イベントに対するリスナー登録
  - DI コンテナから PhaseAutomationHandler を解決
- **依存関係**: タスク 1
- **優先度**: 高

#### 8. ログ出力機能の実装
- **ファイル**: `src/core/workflow/phase-automation.ts`
- **内容**:
  - `info` レベルでのログ記録
  - ログフォーマット: `[PhaseAutomation] <phase>: <message>`
  - エラー時の `error` レベルログ
  - ユーザー通知メッセージの標準出力
- **依存関係**: タスク 1
- **優先度**: 中

#### 9. E2E テストシナリオの実装
- **ファイル**: `tests/integrations/phase-automation.test.ts`（新規作成）
- **内容**:
  - シナリオ 1: 完全自動フロー
  - シナリオ 2: 不足情報の問い合わせフロー
  - データベースモック、GitHub API モックの設定
  - 各フェーズの自動処理が正しく動作することを検証
- **依存関係**: タスク 1-6
- **優先度**: 中

#### 10. ドキュメント更新
- **ファイル**: `CLAUDE.md`, `ARCHITECTURE.md`
- **内容**:
  - CLAUDE.md に PhaseAutomationHandler の動作説明を追加
  - ARCHITECTURE.md にフェーズ自動処理アーキテクチャを追加
  - スラッシュコマンドの自動処理に関する説明を更新
- **依存関係**: タスク 1-6
- **優先度**: 低

### 実装優先順位

1. **Phase 1（基盤）**: タスク 1 → タスク 7 → タスク 8
2. **Phase 2（コア機能）**: タスク 3 → タスク 4 → タスク 5
3. **Phase 3（追加機能）**: タスク 2 → タスク 6
4. **Phase 4（品質保証）**: タスク 9 → タスク 10

### 注意事項

- **Claude Code ツールの扱い**: AskUserQuestion, TodoWrite, Skill, Task ツールは Claude Code 側で処理されるため、実装側では「Claude が実行すべき処理」として CLAUDE.md に記載する形式になります。
- **イベント駆動の維持**: すべての自動処理は `spec.phase_changed` イベントをトリガーとして実行され、既存のイベント駆動アーキテクチャを維持します。
- **同期実行**: `npm run sync:dogfood` で `.cc-craft-kit/` に同期後、スラッシュコマンドで動作確認を行います。
