---
id: "5e034974-ac4a-46bb-9fac-747245a28031"
name: "データベース不整合がまだ発生する"
phase: "completed"
branch_name: "main"
github_issue_number: null
pr_url: null
created_at: "2025-11-20T11:08:42Z"
updated_at: "2025-11-20T11:43:27Z"
---

# データベース不整合がまだ発生する


## 1. 背景と目的

### 背景

相変わらず Claude Code 再起動後、/cft:status するとデータベース不整合が発生する。また、リペアすると 1 件の孤立レコード (test-spec-error-level) が現れる。この仕様書は存在しないため毎回削除する羽目になる。根本原因を探り二度と発生しないような対策が必要。

### 目的

データベース不整合（特に `test-spec-error-level` という孤立レコード）が繰り返し発生する根本原因を特定し、二度と発生しないような恒久的な対策を実装する。
---

## 2. 対象ユーザー

- cc-craft-kit の開発者
- cc-craft-kit のユーザー（データベース不整合によるエラーに遭遇したすべてのユーザー）
---

## 3. 受け入れ基準

### 必須要件

- [ ] `test-spec-error-level` レコードの発生源を特定
- [ ] 修復スクリプトが孤立レコード（ファイルなし DB レコード）を自動削除する
- [ ] データベース不整合が二度と発生しない仕組みを実装

### 機能要件

- [ ] 修復スクリプト (`repair-database.ts`) が孤立レコードを自動削除
- [ ] 仕様書作成時のロールバック処理が正常に動作（ファイル削除 + DB 削除）
- [ ] 仕様書削除時にファイルと DB レコードの両方を削除
- [ ] データベース接続終了時に WAL チェックポイントを実行し、データ損失を防ぐ
- [ ] 整合性チェック時に孤立レコードを検出し、警告を表示

### 非機能要件

- [ ] データベース整合性チェックが高速に動作（100ms 以内）
- [ ] 修復処理が冪等性を持つ（何度実行しても同じ結果）
- [ ] エラーログに十分な診断情報を記録（レコード ID、ファイルパス、エラー理由）
---

## 4. 制約条件

- 既存の仕様書ファイル（63 件）を破壊しないこと
- データベーススキーマ変更は最小限にとどめること
- 既存のコマンド（`/cft:spec-create`, `/cft:spec-phase` など）の動作を壊さないこと
---

## 5. 依存関係

- `src/core/database/connection.ts` - データベース接続管理
- `src/core/validators/database-integrity-checker.ts` - 整合性チェッカー
- `.cc-craft-kit/scripts/repair-database.ts` - 修復スクリプト
- `src/commands/spec/create.ts` - 仕様書作成コマンド
---

## 6. 参考情報

### 調査結果

#### 問題1: 修復スクリプトが孤立レコードを削除しない

**現状の動作:**

修復スクリプト (`repair-database.ts`) は以下の処理を実施します。

1. ファイルシステム内の仕様書ファイルを読み込む
2. データベースに存在しないファイルを追加 (ADD)
3. データベースに存在するファイルを更新 (UPDATE)
4. **孤立レコード（ファイルなし DB レコード）は削除しない**

**根本原因:**

修復スクリプトは「ファイルを正」として扱い、データベースを同期する設計。孤立レコードの削除処理が実装されていない。

**対策:**

修復スクリプトに以下の処理を追加します。

```typescript
// ステップ4: 孤立レコードの削除
for (const { id, name } of integrityResult.details.missingFiles) {
  await db.deleteFrom('specs').where('id', '=', id).execute();
  console.log(`✓  [DELETE] Orphaned record: ${name} (${id.substring(0, 8)}...)`);
  deletedCount++;
}
```

#### 問題2: `test-spec-error-level` の発生源

**調査結果:**

- Git 履歴に該当ファイルなし
- データベースログに該当レコード作成ログなし
- 仕様書ファイルが削除されたが、DB レコードが残っている

**推測される原因:**

1. **テストコードでの仕様書作成**: テストケースで `test-spec-error-level` を作成したが、クリーンアップが不完全
2. **仕様書削除コマンドの欠如**: `/cft:spec-delete` コマンドが存在せず、ファイルを手動削除したが DB レコードが残った
3. **異常終了**: 仕様書作成中に Claude Code が異常終了し、ロールバック処理が実行されなかった

**対策:**

1. 修復スクリプトで孤立レコードを自動削除
2. `/cft:spec-delete` コマンドを実装（ファイル + DB レコードの両方を削除）
3. 仕様書作成のロールバック処理を強化

#### 問題3: データベース接続終了時のデータ損失

**現状の動作:**

`connection.ts` の `closeDatabase()` は WAL チェックポイントを実行するが、すべてのコマンドが `closeDatabase()` を呼び出すわけではない。

**対策:**

- すべてのコマンド実行後に `closeDatabase()` を確実に呼び出す
- プロセス終了時のシグナルハンドラーで `closeDatabase()` を実行
---

## 7. 設計

### 7.1. アーキテクチャ

#### 修復スクリプトの改善

**現状:**

```text
repair-database.ts
├── Step 1: 整合性チェック (checkDatabaseIntegrity)
├── Step 2: 不正メタデータ修正 (fixSpecFileMetadata)
├── Step 3: データベース修復
│   ├── ファイル → DB 同期 (ADD/UPDATE)
│   └── 孤立レコード削除 (未実装) ❌
└── Step 4: 最終整合性チェック
```

**改善後:**

```text
repair-database.ts
├── Step 1: 整合性チェック (checkDatabaseIntegrity)
├── Step 2: 不正メタデータ修正 (fixSpecFileMetadata)
├── Step 3: データベース修復
│   ├── ファイル → DB 同期 (ADD/UPDATE)
│   └── 孤立レコード削除 (NEW) ✅
│       └── details.missingFiles の各レコードを DELETE
└── Step 4: 最終整合性チェック
```

#### 仕様書削除コマンドの設計

**新規コマンド:** `/cft:spec-delete <spec-id>`

**処理フロー:**

```text
spec-delete.ts
├── 1. 仕様書 ID の検証
├── 2. 削除対象の表示
│   ├── 仕様書名
│   ├── フェーズ
│   └── 関連 GitHub Issue
├── 3. 確認プロンプト (y/N)
├── 4. トランザクション開始
│   ├── 4-1. DB レコード削除
│   ├── 4-2. 仕様書ファイル削除
│   ├── 4-3. GitHub Issue クローズ (オプション)
│   └── 4-4. spec.deleted イベント発火
└── 5. エラー時のロールバック
```

#### データベース接続管理の改善

**現状の問題:**

- コマンド終了時に `closeDatabase()` が呼ばれない
- 異常終了時に WAL チェックポイントが実行されない

**改善策:**

```typescript
// すべてのコマンドに以下を追加
try {
  // コマンド処理
} finally {
  await closeDatabase(); // 必ず実行
}

// プロセスレベルのシグナルハンドラー追加
process.on('SIGINT', async () => {
  await closeDatabase();
  process.exit(0);
});

process.on('SIGTERM', async () => {
  await closeDatabase();
  process.exit(0);
});
```

### 7.2. データモデル

既存のデータモデルは変更なし。`specs` テーブルの構造は維持します。

```typescript
interface Spec {
  id: string; // UUID
  name: string;
  description: string | null;
  phase: 'requirements' | 'design' | 'tasks' | 'implementation' | 'testing' | 'completed';
  created_at: string; // ISO 8601
  updated_at: string; // ISO 8601
}
```

### 7.3. API 設計

#### 修復スクリプト API

**関数シグネチャ:**

```typescript
async function deleteOrphanedRecords(
  db: Kysely<Database>,
  orphanedRecords: Array<{ id: string; name: string }>
): Promise<number>;
```

**処理内容:**

1. 各孤立レコードを `DELETE FROM specs WHERE id = ?` で削除
2. 削除件数をカウント
3. 削除されたレコードをログ出力

#### 仕様書削除コマンド API

**関数シグネチャ:**

```typescript
async function deleteSpec(
  specId: string,
  options: {
    skipConfirmation?: boolean;
    closeGitHubIssue?: boolean;
  }
): Promise<void>;
```

**処理内容:**

1. 仕様書 ID を完全一致で検索
2. 削除対象の情報を表示
3. 確認プロンプト（`skipConfirmation: true` の場合はスキップ）
4. トランザクション内で DB レコード + ファイルを削除
5. GitHub Issue をクローズ（オプション）

### 7.4. エラーハンドリング

#### 修復スクリプト

- 孤立レコード削除時のエラーは警告として記録し、処理を継続
- 最終整合性チェックで残存エラーを検出

#### 仕様書削除コマンド

- DB 削除失敗 → ロールバック（ファイル削除もスキップ）
- ファイル削除失敗 → DB ロールバック
- GitHub API エラー → 警告のみ（ローカル削除は成功）

### 7.5. パフォーマンス

- 整合性チェック: O(n) where n = 仕様書ファイル数
- 孤立レコード削除: O(m) where m = 孤立レコード数
- 目標: 100 件の仕様書で 100ms 以内

### 7.6. セキュリティ

- 仕様書削除は不可逆操作のため、確認プロンプトを必須とする
- 削除前にバックアップ推奨メッセージを表示
---

## 8. 実装方針

### Phase 1: 修復スクリプトの改善（即座に対応）

1. 孤立レコードの自動削除機能を追加
2. 削除されたレコードのログ出力
3. 冪等性の保証（何度実行しても同じ結果）

### Phase 2: 仕様書削除コマンドの実装

1. `/cft:spec-delete <spec-id>` コマンドを追加
2. ファイル + DB レコード + GitHub Issue を一括削除
3. 削除前の確認プロンプト

### Phase 3: データベース接続管理の改善

1. すべてのコマンドに `closeDatabase()` 呼び出しを追加
2. プロセス終了時のシグナルハンドラー実装
3. エラー時の確実なロールバック処理
---

## 9. 実装タスクリスト

### Phase 1: 修復スクリプトの改善（優先度: 最高）

- [ ] **Task 1.1**: 修復スクリプトに孤立レコード削除機能を追加
  - ファイル: `.cc-craft-kit/scripts/repair-database.ts`
  - 処理: `details.missingFiles` の各レコードを `DELETE FROM specs WHERE id = ?` で削除
  - 削除件数をカウントし、ログ出力
  - 依存: なし

- [ ] **Task 1.2**: 修復スクリプトの単体テストを作成
  - ファイル: `tests/scripts/repair-database.test.ts`
  - テストケース:
    - 孤立レコードが正常に削除されること
    - 削除後の整合性チェックが成功すること
    - 冪等性（何度実行しても同じ結果）
  - 依存: Task 1.1

### Phase 2: 仕様書削除コマンドの実装（優先度: 高）

- [ ] **Task 2.1**: `/cft:spec-delete` コマンドを実装
  - ファイル: `src/commands/spec/delete.ts`
  - 処理:
    - 仕様書 ID の検証
    - 削除対象の表示（仕様書名、フェーズ、関連 GitHub Issue）
    - 確認プロンプト (y/N)
    - トランザクション内で DB レコード + ファイルを削除
    - `spec.deleted` イベント発火
  - 依存: なし

- [ ] **Task 2.2**: `/cft:spec-delete` のスラッシュコマンド定義を作成
  - ファイル: `src/slash-commands/spec-delete.md`
  - 内容: コマンドの使用方法、引数、オプションを記述
  - 依存: Task 2.1

- [ ] **Task 2.3**: 仕様書削除コマンドの単体テストを作成
  - ファイル: `tests/commands/spec/delete.test.ts`
  - テストケース:
    - DB レコードとファイルが両方削除されること
    - GitHub Issue がクローズされること（オプション）
    - エラー時のロールバック処理が動作すること
  - 依存: Task 2.1

### Phase 3: データベース接続管理の改善（優先度: 中）

- [ ] **Task 3.1**: すべてのコマンドに `closeDatabase()` 呼び出しを追加
  - ファイル: `src/commands/**/*.ts`（すべてのコマンド）
  - 処理: `try-finally` ブロックで `closeDatabase()` を確実に実行
  - 依存: なし

- [ ] **Task 3.2**: プロセス終了時のシグナルハンドラーを実装
  - ファイル: `src/core/database/connection.ts`
  - 処理:
    - `process.on('SIGINT')` で `closeDatabase()` を実行
    - `process.on('SIGTERM')` で `closeDatabase()` を実行
  - 依存: なし

### Phase 4: テストと検証（優先度: 高）

- [ ] **Task 4.1**: E2E テストでデータベース不整合が発生しないことを確認
  - ファイル: `tests/e2e/database-integrity.test.ts`
  - テストケース:
    - 100 回連続で仕様書を作成・削除
    - 整合性チェックでエラー 0 件を確認
    - 孤立レコードが発生しないことを確認
  - 依存: Task 1.1, Task 2.1, Task 3.1, Task 3.2

### Phase 5: ドキュメント更新（優先度: 低）

- [ ] **Task 5.1**: ドキュメントを更新
  - ファイル: `CLAUDE.md`
  - 更新内容:
    - トラブルシューティングセクションに `/cft:spec-delete` コマンドを追加
    - データベース不整合の解決手順を更新
  - 依存: Task 1.1, Task 2.1
---

## 10. タスク依存関係グラフ

```text
Task 1.1 → Task 1.2
         ↘
          Task 4.1 → Task 5.1
         ↗       ↗
Task 2.1 → Task 2.2, Task 2.3
         ↗
Task 3.1, Task 3.2
```
