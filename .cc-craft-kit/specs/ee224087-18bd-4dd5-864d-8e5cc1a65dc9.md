# データベース処理の見直し

**仕様書 ID:** ee224087-18bd-4dd5-864d-8e5cc1a65dc9
**フェーズ:** completed
**作成日時:** 2025/11/19 16:26:25
**更新日時:** 2025/11/19 17:43:44

---

## 1. 背景と目的

### 背景

データベースの状態が信用できない状態にある。Claude Code を再起動して /cft:status で確認すると、以下の問題が発生している:

1. **データベースの状態が不正** - 作成したはずの仕様書が無かったり、フェーズが間違っていたりする
2. **自動リカバリー処理が遅い** - `/cft:status` 実行時に Issue 未作成の仕様書を自動作成する処理が走り、すごく待たされる（182-240 行目）
3. **GitHub Issue の重複作成** - 既に completed でクローズ済みの仕様書に対して、新しい Issue が作成される
4. **データベース破損の原因不明** - 再起動後にデータベースが古い状態に戻る原因が不明

**具体的な問題の流れ:**

```
1. Claude Code 再起動
   ↓
2. /cft:status 実行
   ↓
3. データベースから specs を取得（この時点で古い状態）
   ↓
4. github_issue_id が NULL の仕様書を検出（182-186行目）
   ↓
5. ensureGitHubIssue() で自動リカバリー実行（196-240行目）
   ↓
6. 大量の Issue が作成され、すごく待たされる
   ↓
7. しかし、データベースのフェーズ情報は古いまま（例: implementation のまま）
```

**根本原因の仮説:**

- データベースファイル（`.cc-craft-kit/cc-craft-kit.db`）が何らかの理由で古い状態に戻っている
- WAL ファイル（`.cc-craft-kit/cc-craft-kit.db-wal`）のチェックポイント処理が失敗している
- 複数の Claude Code インスタンスで同時実行した際に、データベース破損が発生している
- 仕様書ファイル（`.cc-craft-kit/specs/*.md`）とデータベースの整合性が取れていない

### 目的

データベースとファイルシステムの整合性を保証し、以下を実現する:

1. **データベース状態の信頼性向上** - Claude Code 再起動後もデータベースが正しい状態を維持
2. **自動修復機能の強化** - データベース破損を検出し、自動的に修復
3. **ログ記録の改善** - データベース操作のすべてのログを記録し、問題の早期発見を可能に
4. **GitHub Issue 重複作成の防止** - 既に存在する Issue を誤って再作成しないよう、厳格なチェックを実施

---

## 2. 対象ユーザー

- cc-craft-kit を使用してプロジェクト管理を行う開発者
- 複数の Claude Code インスタンスを同時に起動するユーザー
- データベース破損に悩むユーザー

---

## 3. 受け入れ基準

### 必須要件

- [ ] Claude Code 再起動後、データベース内の仕様書が正しく読み込まれる
- [ ] 仕様書のフェーズがファイルとデータベースで一致している
- [ ] 既存の GitHub Issue が誤って再作成されない
- [ ] データベース破損時に自動修復が実行される
- [ ] データベース操作のすべてのログが記録される

### 機能要件

- [ ] 起動時にデータベースとファイルシステムの整合性チェックを実施
- [ ] 整合性エラー検出時に自動修復を実行
- [ ] GitHub Issue の存在確認を厳格化（410/404 エラー時のみ再作成）
- [ ] データベース操作のトランザクション化（ACID 保証）
- [ ] WAL モードでのチェックポイント最適化
- [ ] データベース破損時のバックアップからの自動復旧

### 非機能要件

- [ ] データベース操作のパフォーマンス劣化がない（整合性チェックは非同期実行）
- [ ] データベースファイルサイズの肥大化防止（定期的な VACUUM 実行）
- [ ] 複数の Claude Code インスタンスでの同時実行をサポート
- [ ] データベース破損時のエラーメッセージが明確で、復旧手順を案内

---

## 4. 制約条件

### 技術的制約

- SQLite データベースを使用（変更不可）
- WAL モードを使用（既存設定）
- Kysely ORM を使用（既存設定）
- better-sqlite3 ドライバを使用（既存設定）

### 既存実装の制約

- `getDatabase()` 関数は厳格なシングルトンパターンを実装している
- GitHub Issue 自動リカバリー機能が既に実装されている
- データベース修復スクリプト (`repair-database.ts`) が既に存在する

### データ整合性の制約

- 仕様書ファイルが Single Source of Truth（信頼できる唯一の情報源）
- データベースはファイルシステムのキャッシュとして機能する
- GitHub Issue はデータベースと同期される（双方向同期）

---

## 5. 依存関係

### 既存モジュール

- `src/core/database/connection.ts` - データベース接続管理
- `src/integrations/github/ensure-issue.ts` - GitHub Issue 自動リカバリー
- `src/scripts/repair-database.ts` - データベース修復スクリプト
- `src/core/errors/error-handler.ts` - エラーハンドリング
- `src/commands/status.ts` - プロジェクト状況表示

### 関連する仕様書

- 仕様書とデータベース間の同期がとれていない (edcc66aa) - completed
- データベース破損を防ぐための包括的な対策を実装 (eaa365b) - completed
- 複数 Claude Code インスタンスでの同時実行をサポート (a95c818) - completed

---

## 6. 参考情報

### 現在の問題箇所

1. **仕様書ファイルのメタデータ形式の不統一**
   - 一部の仕様書ファイルが正しくないメタデータ形式を使用している
   - 例: `ae5bffaf-843f-41f1-b486-973db2e45928.md` と `bfcb8e9e-4e35-43b6-bd57-2ead519ec3fa.md`
   - 修復スクリプト (`repair-database.ts`) がこれらのファイルをパースできず、SKIP される
   - 結果: ファイルシステムには 54 件、データベースには 52 件の仕様書が存在（2 件の差分）

2. **データベース修復スクリプトの自動実行がない**
   - 修復スクリプトが存在するが、Claude Code 起動時に自動実行されない
   - ユーザーが手動で実行する必要がある

3. **GitHub Issue 自動リカバリーの副作用**
   - `/cft:status` 実行時に `github_issue_id` が NULL の仕様書を検出すると、自動的に Issue を作成する（182-240 行目）
   - しかし、データベースのフェーズ情報が古い場合、completed の仕様書に対して新しい Issue が作成される
   - 例: GitHub Issue #160 が削除され、新しい Issue #203 が作成されたが、フェーズは `implementation` のまま

4. **WAL チェックポイントのタイミング問題**
   - WAL モードを使用しているが、チェックポイントが適切に実行されていない可能性
   - Claude Code 異常終了時に WAL ファイルがコミットされず、データが失われる可能性

### SQLite のベストプラクティス

- WAL モード: 複数プロセスからの同時アクセスをサポート
- `busy_timeout`: ロック待機時間を設定（現在は 5 秒）
- `wal_autocheckpoint`: WAL ファイルが肥大化しないよう自動チェックポイント実行
- `PRAGMA integrity_check`: データベース破損をチェック
- `VACUUM`: データベースファイルサイズを最適化

### GitHub API のエラーハンドリング

- 410 Gone: リソースが削除されている（Issue が削除された）
- 404 Not Found: リソースが見つからない（Issue が存在しない、またはアクセス権限がない）
- 403 Forbidden: レート制限またはアクセス権限不足

---

## 7. 設計

### 7.1 アーキテクチャ設計

#### データベース整合性保証の全体フロー

```
Claude Code 起動
    ↓
getDatabase() 呼び出し
    ↓
初回接続時に自動整合性チェック実行
    ├─ データベース integrity_check
    ├─ ファイルシステムとの整合性チェック
    └─ 不整合検出時に自動修復
    ↓
通常のデータベース操作
    ↓
定期的な WAL チェックポイント
    ↓
Claude Code 終了時に明示的チェックポイント
```

#### コンポーネント構成

1. **DatabaseIntegrityChecker** (新規作成: `src/core/database/integrity-checker.ts`)
   - データベースファイルの破損チェック (`PRAGMA integrity_check`)
   - ファイルシステムとデータベースの整合性チェック
   - 不整合検出時の自動修復ロジック

2. **SpecFileValidator** (新規作成: `src/core/validators/spec-file-validator.ts`)
   - 仕様書ファイルのメタデータバリデーション
   - 必須フィールドの存在確認
   - 日時形式の検証

3. **DatabaseConnectionManager** (修正: `src/core/database/connection.ts`)
   - `getDatabase()` に整合性チェックを統合
   - 初回接続時に自動チェック実行
   - 終了時のチェックポイント処理追加

4. **RepairService** (修正: `src/scripts/repair-database.ts`)
   - メタデータ不正ファイルの自動修正
   - スキップされたファイルのログ記録
   - 修復結果のサマリー表示

5. **StatusCommand** (修正: `src/commands/status.ts`)
   - GitHub Issue 自動リカバリーの最適化
   - フェーズ情報の検証強化
   - リカバリー前に整合性チェック実行

### 7.2 データベース整合性チェック設計

#### チェック項目

1. **データベースファイルの破損チェック**
   ```sql
   PRAGMA integrity_check;
   ```
   - 正常: `ok` が返る
   - 異常: エラーメッセージが返る → バックアップから復旧

2. **ファイルシステムとの整合性チェック**
   - `.cc-craft-kit/specs/*.md` のファイル数とデータベースの `specs` テーブルのレコード数を比較
   - 差分がある場合 → 自動修復実行

3. **メタデータ形式の検証**
   - 各仕様書ファイルのメタデータをパース
   - 必須フィールド（仕様書 ID、フェーズ、作成日時、更新日時）の存在確認
   - 日時形式の検証（`YYYY/MM/DD HH:MM:SS` 形式）

#### 自動修復ロジック

```typescript
async function checkAndRepair(): Promise<void> {
  // 1. データベース破損チェック
  const integrityResult = await db.raw('PRAGMA integrity_check').execute();
  if (integrityResult !== 'ok') {
    console.error('Database corruption detected. Restoring from backup...');
    await restoreFromBackup();
    return;
  }

  // 2. ファイルシステムとの整合性チェック
  const specsDir = join(process.cwd(), '.cc-craft-kit', 'specs');
  const files = await readdir(specsDir);
  const specFiles = files.filter((f) => f.endsWith('.md'));

  const dbSpecs = await db.selectFrom('specs').selectAll().execute();

  if (specFiles.length !== dbSpecs.length) {
    console.log(`Inconsistency detected: ${specFiles.length} files vs ${dbSpecs.length} records`);
    await repairDatabase();
  }

  // 3. メタデータ形式の検証
  for (const file of specFiles) {
    const content = await readFile(join(specsDir, file), 'utf-8');
    const metadata = parseSpecFile(content);

    if (!metadata) {
      console.warn(`Invalid metadata in ${file}. Attempting to fix...`);
      await fixSpecFileMetadata(join(specsDir, file));
    }
  }
}
```

### 7.3 メタデータバリデーション設計

#### 正しいメタデータ形式

```markdown
**仕様書 ID:** xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
**フェーズ:** requirements|design|tasks|implementation|testing|completed
**作成日時:** YYYY/MM/DD HH:MM:SS
**更新日時:** YYYY/MM/DD HH:MM:SS
```

#### バリデーションルール

1. **フィールド名**: `**仕様書 ID:**`（スペース+コロン）
2. **UUID 形式**: `xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx`
3. **フェーズ**: 有効な値のみ許可
4. **日時形式**: `YYYY/MM/DD HH:MM:SS`（時刻情報必須）

#### 自動修正機能

不正なメタデータを検出した場合、以下の修正を自動的に実行:

```typescript
function fixSpecFileMetadata(filePath: string): void {
  const content = readFileSync(filePath, 'utf-8');
  let fixed = content;

  // 1. フィールド名の修正
  fixed = fixed.replace(/\*\*仕様書ID:\*\*/g, '**仕様書 ID:**');
  fixed = fixed.replace(/\*\*フェーズ:\*\*/g, '**フェーズ:**');

  // 2. 日時形式の修正（時刻情報がない場合は 00:00:00 を追加）
  fixed = fixed.replace(
    /\*\*作成日:\*\* (\d{4}\/\d{2}\/\d{2})$/gm,
    '**作成日時:** $1 00:00:00'
  );
  fixed = fixed.replace(
    /\*\*更新日:\*\* (\d{4}\/\d{2}\/\d{2})$/gm,
    '**更新日時:** $1 00:00:00'
  );

  writeFileSync(filePath, fixed, 'utf-8');
  console.log(`✓ Fixed metadata in ${filePath}`);
}
```

### 7.4 WAL チェックポイント最適化

#### 現在の設定

```typescript
sqlite.pragma('wal_autocheckpoint = 1000'); // 1000ページごとにチェックポイント
```

#### 最適化方針

1. **明示的チェックポイント実行**
   - Claude Code 終了時に明示的に WAL チェックポイントを実行
   - `PRAGMA wal_checkpoint(PASSIVE)` を使用

2. **チェックポイント失敗時のリトライ**
   - チェックポイント失敗時は最大 3 回リトライ
   - リトライ間隔: 100ms

3. **WAL ファイルサイズの監視**
   - WAL ファイルが 10MB を超えた場合、強制チェックポイント実行
   - `PRAGMA wal_checkpoint(TRUNCATE)` でファイルサイズをリセット

#### 実装例

```typescript
async function checkpointWAL(): Promise<void> {
  const db = getDatabase();

  for (let i = 0; i < 3; i++) {
    try {
      await db.raw('PRAGMA wal_checkpoint(PASSIVE)').execute();
      console.log('✓ WAL checkpoint completed');
      return;
    } catch (error) {
      console.warn(`WAL checkpoint failed (attempt ${i + 1}/3):`, error);
      await new Promise((resolve) => setTimeout(resolve, 100));
    }
  }

  console.error('Failed to checkpoint WAL after 3 attempts');
}

// Claude Code 終了時に実行
process.on('beforeExit', async () => {
  await checkpointWAL();
  await closeDatabase();
});
```

### 7.5 GitHub Issue 自動リカバリーの改善

#### 現在の問題

- `/cft:status` 実行時に `github_issue_id` が NULL の仕様書を検出すると、即座に Issue を作成
- データベースのフェーズ情報が古い場合、completed の仕様書に新しい Issue が作成される

#### 改善方針

1. **整合性チェック後にリカバリー実行**
   ```typescript
   // status.ts
   // 自動リカバリー実行前に整合性チェック
   await checkAndRepair();

   // その後、リカバリー実行
   const specsWithoutIssue = await db
     .selectFrom('specs')
     .where('github_issue_id', 'is', null)
     .execute();
   ```

2. **フェーズ情報の検証強化**
   - リカバリー前に仕様書ファイルからフェーズ情報を読み取る
   - データベースのフェーズと一致しない場合は、ファイルのフェーズを優先

3. **completed 仕様書のスキップ**
   - フェーズが `completed` の仕様書は Issue リカバリーをスキップ
   - 既にクローズされた Issue の再作成を防止

#### 実装例

```typescript
// ensureGitHubIssue の改善
export async function ensureGitHubIssue(
  db: Kysely<Database>,
  specId: string
): Promise<EnsureGitHubIssueResult> {
  // 1. 仕様書ファイルからフェーズ情報を取得
  const specFile = join(process.cwd(), '.cc-craft-kit', 'specs', `${specId}.md`);
  const content = readFileSync(specFile, 'utf-8');
  const metadata = parseSpecFile(content);

  // 2. completed フェーズの場合はスキップ
  if (metadata?.phase === 'completed') {
    console.log(`Skipping Issue recovery for completed spec: ${specId}`);
    return { issueNumber: null, wasCreated: false };
  }

  // 3. データベースのフェーズと一致しない場合は更新
  const dbSpec = await db
    .selectFrom('specs')
    .where('id', '=', specId)
    .selectAll()
    .executeTakeFirst();

  if (dbSpec && dbSpec.phase !== metadata?.phase) {
    console.log(`Phase mismatch detected. Updating DB: ${dbSpec.phase} → ${metadata?.phase}`);
    await db
      .updateTable('specs')
      .set({ phase: metadata?.phase })
      .where('id', '=', specId)
      .execute();
  }

  // 4. 通常のリカバリー処理
  // ...
}
```

### 7.6 実装対象ファイル

#### 新規作成ファイル

1. **`src/core/database/integrity-checker.ts`**
   - データベース整合性チェック機能
   - 自動修復ロジック

2. **`src/core/validators/spec-file-validator.ts`**
   - 仕様書ファイルのメタデータバリデーション
   - メタデータ自動修正機能

#### 修正ファイル

1. **`src/core/database/connection.ts`**
   - `getDatabase()` に整合性チェックを統合
   - 終了時のチェックポイント処理追加

2. **`src/scripts/repair-database.ts`**
   - メタデータバリデーション機能の統合
   - 自動修正機能の追加

3. **`src/commands/status.ts`**
   - GitHub Issue 自動リカバリー前に整合性チェック実行
   - フェーズ情報の検証強化

4. **`src/integrations/github/ensure-issue.ts`**
   - フェーズ情報の検証強化
   - completed 仕様書のスキップロジック追加

### 7.7 パフォーマンス設計

#### 整合性チェックのタイミング

- **初回接続時のみ実行**: `getDatabase()` の初回呼び出し時のみチェック
- **非同期実行**: 整合性チェックは非同期で実行し、データベース操作をブロックしない
- **キャッシュ**: チェック結果をメモリにキャッシュし、同一セッション内で再実行しない

#### WAL チェックポイントの最適化

- **自動チェックポイント**: 1000 ページごとに自動実行（既存設定）
- **明示的チェックポイント**: Claude Code 終了時に実行
- **PASSIVE モード**: 読み取り操作をブロックしない

### 7.8 エラーハンドリング設計

#### データベース破損時の復旧フロー

```
データベース破損検出
    ↓
最新のバックアップファイルを検索
    ↓
バックアップから復旧
    ↓
整合性チェック実行
    ↓
成功 → 通常運用再開
失敗 → エラーメッセージ表示し、手動復旧を案内
```

#### エラーメッセージの改善

```typescript
if (integrityResult !== 'ok') {
  console.error(`
❌ Database corruption detected!

Details:
  ${integrityResult}

Recovery steps:
  1. Automatic backup restoration in progress...
  2. If automatic recovery fails, restore manually:
     - Latest backup: ${latestBackupPath}
     - Run: cp ${latestBackupPath} .cc-craft-kit/cc-craft-kit.db
  3. If no backup available, rebuild database:
     - Run: npx tsx .cc-craft-kit/scripts/repair-database.ts
  `);
}
```

---

## 8. 実装タスクリスト

### タスク1: SpecFileValidator の作成

**目的**: 仕様書ファイルのメタデータバリデーション機能を実装

**実装内容**:
- `src/core/validators/spec-file-validator.ts` を新規作成
- メタデータパーサー機能の実装
- バリデーションルールの実装（フィールド名、UUID 形式、フェーズ、日時形式）
- 自動修正機能の実装（フィールド名の修正、日時形式の補完）

**受け入れ基準**:
- メタデータが正しい形式かどうかを検証できる
- 不正な形式を検出し、自動的に修正できる
- 修正内容をログに記録する

**工数見積**: 3 時間

**依存関係**: なし

---

### タスク2: DatabaseIntegrityChecker の作成

**目的**: データベース整合性チェック機能を実装

**実装内容**:
- `src/core/database/integrity-checker.ts` を新規作成
- データベース破損チェック機能（`PRAGMA integrity_check`）
- ファイルシステムとの整合性チェック機能
- 自動修復ロジックの実装

**受け入れ基準**:
- データベース破損を検出できる
- ファイル数とレコード数の差分を検出できる
- 検出した不整合を自動的に修復できる
- 修復不可能な場合はエラーメッセージを表示する

**工数見積**: 4 時間

**依存関係**: タスク 1（SpecFileValidator）

---

### タスク3: repair-database.ts の改善

**目的**: データベース修復スクリプトにバリデーション機能を統合

**実装内容**:
- `src/scripts/repair-database.ts` を修正
- SpecFileValidator を使用してメタデータを検証
- 不正なメタデータを自動修正
- スキップされたファイルのログ記録を改善
- 修復結果のサマリー表示を改善

**受け入れ基準**:
- メタデータ不正ファイルを自動修正できる
- スキップされたファイルが 0 件になる
- 修復結果のサマリーが詳細に表示される

**工数見積**: 2 時間

**依存関係**: タスク 1（SpecFileValidator）

---

### タスク4: connection.ts に整合性チェックを統合

**目的**: データベース接続時に自動整合性チェックを実行

**実装内容**:
- `src/core/database/connection.ts` を修正
- `getDatabase()` に DatabaseIntegrityChecker を統合
- 初回接続時のみチェック実行（キャッシュ機能）
- 終了時の明示的 WAL チェックポイント処理を追加
- `process.on('beforeExit')` でクリーンアップ処理

**受け入れ基準**:
- Claude Code 起動時に自動整合性チェックが実行される
- チェック結果がキャッシュされ、同一セッション内で再実行されない
- 終了時に WAL チェックポイントが実行される

**工数見積**: 3 時間

**依存関係**: タスク 2（DatabaseIntegrityChecker）

---

### タスク5: ensureGitHubIssue の改善

**目的**: GitHub Issue 自動リカバリー時のフェーズ検証を強化

**実装内容**:
- `src/integrations/github/ensure-issue.ts` を修正
- 仕様書ファイルからフェーズ情報を取得
- completed フェーズの仕様書はリカバリーをスキップ
- データベースとファイルのフェーズ不一致時にデータベースを更新
- フェーズ情報の検証ログを記録

**受け入れ基準**:
- completed フェーズの仕様書に対して Issue が作成されない
- フェーズ不一致時に正しいフェーズに更新される
- リカバリーログが詳細に記録される

**工数見積**: 3 時間

**依存関係**: タスク 1（SpecFileValidator）

---

### タスク6: status.ts の改善

**目的**: `/cft:status` 実行時に整合性チェック後にリカバリーを実行

**実装内容**:
- `src/commands/status.ts` を修正
- GitHub Issue 自動リカバリー前に整合性チェックを実行
- フェーズ情報の検証を強化
- リカバリー処理のログを改善

**受け入れ基準**:
- リカバリー前に整合性チェックが実行される
- completed フェーズの仕様書がリカバリー対象から除外される
- リカバリー処理の進捗が表示される

**工数見積**: 2 時間

**依存関係**: タスク 2（DatabaseIntegrityChecker）、タスク 5（ensureGitHubIssue の改善）

---

### タスク7: 不正メタデータファイルの修正

**目的**: 既存の 2 件の不正メタデータファイルを修正

**実装内容**:
- `ae5bffaf-843f-41f1-b486-973db2e45928.md` のメタデータを修正
- `bfcb8e9e-4e35-43b6-bd57-2ead519ec3fa.md` のメタデータを修正
- 修復スクリプトを実行して整合性を確認

**受け入れ基準**:
- 2 件のファイルのメタデータが正しい形式に修正される
- 修復スクリプト実行時にスキップされるファイルが 0 件になる
- データベースのレコード数がファイル数と一致する

**工数見積**: 1 時間

**依存関係**: タスク 3（repair-database.ts の改善）

---

### タスク8: WAL チェックポイント最適化

**目的**: WAL チェックポイント処理を最適化し、データ損失を防止

**実装内容**:
- `src/core/database/connection.ts` に `checkpointWAL()` 関数を追加
- チェックポイント失敗時のリトライロジック（最大 3 回）
- WAL ファイルサイズの監視機能
- 10MB を超えた場合の強制チェックポイント

**受け入れ基準**:
- チェックポイント失敗時に最大 3 回リトライする
- WAL ファイルサイズが 10MB を超えた場合に強制チェックポイントが実行される
- チェックポイント処理のログが記録される

**工数見積**: 2 時間

**依存関係**: タスク 4（connection.ts に整合性チェックを統合）

---

### タスク9: エラーメッセージの改善

**目的**: データベース破損時のエラーメッセージを改善し、復旧手順を案内

**実装内容**:
- `src/core/database/integrity-checker.ts` にエラーメッセージ表示機能を追加
- バックアップファイルのパスを表示
- 手動復旧手順を案内
- 修復スクリプトの実行コマンドを表示

**受け入れ基準**:
- データベース破損検出時に詳細なエラーメッセージが表示される
- 復旧手順が明確に案内される
- 修復スクリプトのコマンドがコピペで実行できる

**工数見積**: 1 時間

**依存関係**: タスク 2（DatabaseIntegrityChecker の作成）

---

### タスク10: 統合テストの作成

**目的**: 整合性チェック機能の統合テストを作成

**実装内容**:
- `tests/integrations/database-integrity.test.ts` を新規作成
- データベース破損検出テスト
- ファイル整合性チェックテスト
- 自動修復機能テスト
- WAL チェックポイントテスト

**受け入れ基準**:
- すべてのテストがパスする
- カバレッジが 80%以上
- エッジケース（破損データベース、メタデータ不正など）がテストされる

**工数見積**: 4 時間

**依存関係**: タスク 1-9 のすべて

---

### タスクの依存関係

```
タスク1（SpecFileValidator 作成）
    ↓
タスク2（DatabaseIntegrityChecker 作成）
    ↓
タスク3（repair-database.ts 改善）
    ↓
タスク4（connection.ts 整合性チェック統合）
    ↓
タスク5（ensureGitHubIssue 改善）
    ↓
タスク6（status.ts 改善）
    ↓
タスク7（不正メタデータファイル修正）
    ↓
タスク8（WAL チェックポイント最適化）
    ↓
タスク9（エラーメッセージ改善）
    ↓
タスク10（統合テスト作成）
```

### 総工数見積

**合計**: 25 時間（約 3-4 日間）
