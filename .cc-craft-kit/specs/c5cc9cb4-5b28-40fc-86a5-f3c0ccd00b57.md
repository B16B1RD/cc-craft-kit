# /cft:pr-cleanup が正しく動作していない

**仕様書 ID:** c5cc9cb4-5b28-40fc-86a5-f3c0ccd00b57
**フェーズ:** completed
**作成日時:** 2025/11/24 09:20:32
**更新日時:** 2025/11/24 10:32:33

---

## 1. 背景と目的

### 背景

以下の3つの問題を修正する必要があります:

1. **PR存在判定の誤り**: PR作成済みなのに「PRが作成されていません」と判定される
   - github_syncテーブルのJOIN条件が正しくない可能性
   - PR作成時のデータベース記録が不完全な可能性

2. **branch_nameカラム更新値の誤り**: PRのマージ先ブランチ名を設定すべきなのに、空文字列を設定している
   - PRがdevelopブランチにマージされた場合、branch_nameは'develop'にすべき
   - 現在は空文字列''を設定している

3. **SQLクエリの誤り**: github_syncテーブルに存在しないg.spec_idカラムを参照
   - 正しくはentity_idカラムを使用すべき

参考ログ: PR #330はdevelopブランチにマージ済み（2025-11-24T00:11:59Z）、feature/spec-a6e1c24a-add-design-implementation-rules ブランチから作成

### 目的

`/cft:pr-cleanup` コマンドが PR マージ後の後処理を正しく実行できるようにする。具体的には:

1. PR の存在判定を正確に行う
2. データベースの `branch_name` カラムをマージ先ブランチ名（develop または main）に更新する
3. SQL クエリで正しいカラム名を使用する

---

## 2. 対象ユーザー

- cc-craft-kit を使用する開発者
- 仕様駆動開発（SDD）で PR マージ後の後処理を実行するユーザー

---

## 3. 受け入れ基準

### 必須要件

- [ ] PR が作成済みの場合、正しく検出できること
- [ ] PR マージ後、`specs.branch_name` カラムがマージ先ブランチ名（`develop` または `main`）に更新されること
- [ ] SQL クエリで存在しないカラム（`g.spec_id`）を参照しないこと（`entity_id` を使用すること）

### 機能要件

- [ ] `getSpecWithGitHubInfo()` が `github_sync` テーブルと正しく JOIN できること
- [ ] `updateSpecBranchToBaseBranch()` が PR のベースブランチ名（`pr.base.ref`）を受け取り、`specs.branch_name` に設定できること
- [ ] PR が作成されていない場合、適切なエラーメッセージを表示すること
- [ ] PR がマージされていない場合、適切なエラーメッセージを表示すること

### 非機能要件

- [ ] データベース更新がトランザクション内で実行されること
- [ ] エラーメッセージがユーザーにとって理解しやすいこと
- [ ] GitHub API のレート制限を考慮した実装であること

---

## 4. 制約条件

- Kysely の型安全性を維持すること
- `specs.branch_name` カラムは NOT NULL 制約があるため、空文字列ではなく有効なブランチ名（`develop` または `main`）を設定すること
- `github_sync` テーブルの `entity_id` カラムと `specs.id` カラムを JOIN すること（`spec_id` カラムは存在しない）

---

## 5. 依存関係

### 関連ファイル

- `src/integrations/github/pr-cleanup.ts:104-271` - `cleanupMergedPullRequest()` 関数
- `src/core/database/helpers.ts:36-82` - `getSpecWithGitHubInfo()` 関数
- `src/core/database/helpers.ts:177-183` - `updateSpecBranchToBaseBranch()` 関数
- `src/core/database/helpers.ts:192-203` - `updatePrMergedStatus()` 関数

### データベーススキーマ

- `specs` テーブル: `branch_name` カラム（NOT NULL 制約）
- `github_sync` テーブル: `entity_id`, `entity_type`, `pr_number`, `pr_url`, `pr_merged_at` カラム

---

## 6. 参考情報

### 問題の詳細分析

#### 問題1: PR存在判定の誤り

**現象**: PR #330が作成済みなのに「PRが作成されていません」と判定される

**原因**: `github_sync` テーブルに PR 情報が記録されていない可能性。`getSpecWithGitHubInfo()` は正しく動作しているが、PR 作成時にデータベースへの記録が失敗している可能性がある。

**修正方針**: PR 作成時の処理（`/cft:spec-phase <spec-id> completed`）を確認し、`github_sync` テーブルへの記録が確実に行われるようにする。

#### 問題2: `branch_name` カラム更新値の誤り

**現象**: PRがdevelopブランチにマージされたのに、`branch_name`を空文字列に更新

**原因**: ログを見ると、Claudeが手動で `UPDATE specs SET branch_name = ''` を実行している。しかし、`updateSpecBranchToBaseBranch()` 関数は正しく `pr.base.ref`（マージ先ブランチ名）を受け取っているため、関数自体は正しく動作している。

**修正方針**: `cleanupMergedPullRequest()` 関数内で `updateSpecBranchToBaseBranch()` が正しく呼び出されていることを確認する（`src/integrations/github/pr-cleanup.ts:233`）。実装は正しいため、問題はログに記録されている手動SQLクエリの実行にある。

**注意**: ログでは、Claude が `sqlite3` コマンドで `UPDATE specs SET branch_name = ''` を実行しているが、これは**誤った手動操作**である。`cleanupMergedPullRequest()` 関数は `updateSpecBranchToBaseBranch(trx, spec.id, baseBranch)` を呼び出しており、`baseBranch` には `pr.base.ref`（develop）が渡されているはずである。

#### 問題3: SQLクエリの誤り

**現象**: 最初のJOINクエリで `g.spec_id` カラムを参照してエラー

**原因**: ログを見ると、Claudeが手動で以下のSQLクエリを実行している:

```sql
SELECT s.id, s.name, s.phase, s.branch_name, g.pr_number, g.pr_url, g.pr_merged_at
FROM specs s
LEFT JOIN github_sync g ON g.spec_id = s.id
```

しかし、`github_sync` テーブルには `spec_id` カラムが存在せず、`entity_id` カラムを使用すべきである。

**修正方針**: `getSpecWithGitHubInfo()` 関数は正しく `entity_id` を使用している（`src/core/database/helpers.ts:44`）。問題はログに記録されている手動SQLクエリの実行にある。

### 根本原因

ログを詳細に確認したところ、以下の根本原因が判明:

1. **PR存在判定の誤り**: `cleanupMergedPullRequest()` 関数は `getSpecWithGitHubInfo()` を呼び出し、`spec.pr_number` が存在しない場合にエラーを返している（`src/integrations/github/pr-cleanup.ts:150-156`）。しかし、ログでは PR #330 が作成済みなのに、`github_sync` テーブルに記録されていないため、`spec.pr_number` が `null` になっている。

2. **手動SQLクエリの誤り**: ログでは、Claudeが手動で `sqlite3` コマンドを実行し、誤ったSQLクエリ（`g.spec_id`）を使用している。これは、`getSpecWithGitHubInfo()` 関数を使用せず、手動でSQLクエリを実行したことが原因である。

3. **branch_name カラム更新値の誤り**: `cleanupMergedPullRequest()` 関数は `updateSpecBranchToBaseBranch(trx, spec.id, baseBranch)` を呼び出しており、`baseBranch` には `pr.base.ref` が渡されている（`src/integrations/github/pr-cleanup.ts:233`）。しかし、最初の PR 存在判定でエラーが発生し、関数が早期リターンしたため、データベース更新処理が実行されていない。その後、Claudeが手動で `UPDATE specs SET branch_name = ''` を実行したことが誤りの原因である。

### 修正が必要な箇所

1. **PR作成時のデータベース記録処理**: `/cft:spec-phase <spec-id> completed` 実行時に、`github_sync` テーブルへの記録が確実に行われるようにする。

2. **PR存在判定のフォールバック処理**: `github_sync` テーブルに PR 情報が記録されていない場合、GitHub API で直接 PR を検索する処理を追加する（ブランチ名から PR を検索）。

3. **エラーメッセージの改善**: PR が作成されていない場合と、データベース記録が不完全な場合を区別し、適切なエラーメッセージを表示する。

---

## 7. 設計詳細

### 7.1. アーキテクチャ設計

#### コンポーネント構成

```
/cft:pr-cleanup コマンド実行
  ↓
pr-cleanup.ts: cleanupMergedPullRequest()
  ↓
├─ helpers.ts: getSpecWithGitHubInfo()  // 仕様書 + GitHub 情報取得
│   └─ github_sync テーブルと JOIN
│
├─ GitHub API: pulls.get()  // PR 状態確認
│
├─ Git操作: deleteLocalBranch(), deleteRemoteBranch()
│
└─ helpers.ts: updateSpecBranchToBaseBranch()  // データベース更新
    └─ specs.branch_name ← pr.base.ref
```

#### データフロー

1. **仕様書情報の取得** (`getSpecWithGitHubInfo`)
   - `specs` テーブルと `github_sync` テーブルを `LEFT JOIN`
   - JOIN 条件: `github_sync.entity_id = specs.id AND github_sync.entity_type = 'spec'`
   - 取得データ: `pr_number`, `pr_url`, `pr_merged_at`

2. **PR 情報の取得** (GitHub API)
   - `pr_number` が存在しない場合: エラー（または GitHub API でブランチ名から PR を検索）
   - `pr_number` が存在する場合: GitHub API で PR 詳細を取得
   - 取得データ: `pr.merged`, `pr.base.ref`, `pr.merged_at`

3. **ブランチ削除** (Git操作)
   - ローカルブランチ: `git branch -D <branch>`
   - リモートブランチ: `git push origin --delete <branch>`

4. **データベース更新** (`updateSpecBranchToBaseBranch`)
   - `specs.branch_name` ← `pr.base.ref` (develop または main)
   - `github_sync.pr_merged_at` ← `pr.merged_at`

#### 問題箇所の特定

1. **PR存在判定の誤り**
   - 原因: `github_sync` テーブルに PR 情報が記録されていない
   - 影響: `getSpecWithGitHubInfo()` が `pr_number: null` を返す
   - 対策: フォールバック処理で GitHub API からブランチ名で PR を検索

2. **branch_name カラム更新値の誤り**
   - 原因: PR存在判定で早期リターンし、データベース更新処理が実行されていない
   - 影響: 仕様書のブランチ名が作業ブランチのまま残る
   - 対策: PR存在判定を修正し、データベース更新処理が確実に実行されるようにする

3. **SQLクエリの誤り**
   - 原因: `getSpecWithGitHubInfo()` は正しく `entity_id` を使用しているが、手動SQLクエリで `spec_id` を参照
   - 影響: データベースエラー（カラムが存在しない）
   - 対策: 手動SQLクエリを使用せず、`getSpecWithGitHubInfo()` を使用

### 7.2. データモデル

#### github_sync テーブル

PR 情報を記録するためのテーブル。PR 作成時に `pr_number`, `pr_url` を記録する。

```typescript
interface GitHubSync {
  id: number;  // PRIMARY KEY
  entity_id: string;  // 仕様書ID（specs.id）
  entity_type: string;  // 'spec' 固定
  github_number: number;  // GitHub Issue番号
  github_node_id: string;
  sync_status: string;
  pr_number: number | null;  // Pull Request番号（PR作成時に記録）
  pr_url: string | null;  // Pull Request URL
  pr_merged_at: string | null;  // PRマージ日時
  created_at: string;
  updated_at: string;
}
```

#### specs テーブル

仕様書情報を管理するテーブル。PR マージ後、`branch_name` をマージ先ブランチ名に更新する。

```typescript
interface Spec {
  id: string;  // PRIMARY KEY（UUID）
  name: string;
  description: string;
  phase: SpecPhase;
  branch_name: string;  // NOT NULL 制約（PRマージ後、develop または main に更新）
  created_at: string;
  updated_at: string;
}
```

#### JOIN クエリの正誤

**誤り** (手動SQLクエリ):
```sql
LEFT JOIN github_sync g ON g.spec_id = s.id  -- ❌ spec_id カラムは存在しない
```

**正しい** (`getSpecWithGitHubInfo()`):
```sql
LEFT JOIN github_sync ON github_sync.entity_id = specs.id
  AND github_sync.entity_type = 'spec'  -- ✅ entity_id と entity_type を使用
```

### 7.3. API の仕様

#### cleanupMergedPullRequest()

PR マージ後の後処理を実行する関数。

**シグネチャ**:
```typescript
export async function cleanupMergedPullRequest(
  db: Kysely<Database>,
  specId: string
): Promise<CleanupResult>
```

**処理フロー**:

1. GitHub クライアント取得（未初期化の場合は環境変数から初期化）
2. 仕様書 + GitHub 情報取得 (`getSpecWithGitHubInfo`)
3. **PR存在判定**（修正箇所）
   - `pr_number` が存在しない場合: エラーまたはフォールバック処理
   - フォールバック: GitHub API でブランチ名から PR を検索
4. GitHub API で PR 状態確認 (`pulls.get`)
5. PR マージ確認（`pr.merged === true`）
6. ブランチ削除（ローカル + リモート）
7. **データベース更新**（修正箇所）
   - `specs.branch_name` ← `pr.base.ref`（develop または main）
   - `github_sync.pr_merged_at` ← `pr.merged_at`
8. イベント発火 (`spec.pr_merged`)

**修正前のエラーフロー**:

```
PR #330 が作成済み
  ↓
github_sync テーブルに PR 情報が未記録
  ↓
getSpecWithGitHubInfo() が pr_number: null を返す
  ↓
PR存在判定で早期リターン（エラー: "PR が作成されていません"）
  ↓
データベース更新処理が実行されない
  ↓
specs.branch_name が作業ブランチのまま残る
```

**修正後のフロー（フォールバック処理追加）**:

```
PR #330 が作成済み
  ↓
github_sync テーブルに PR 情報が未記録
  ↓
getSpecWithGitHubInfo() が pr_number: null を返す
  ↓
フォールバック: GitHub API でブランチ名から PR を検索
  ↓
PR が見つかった場合: PR 情報を取得し、処理を継続
  ↓
データベース更新処理が実行される
  ↓
specs.branch_name が develop または main に更新される
```

#### updateSpecBranchToBaseBranch()

仕様書のブランチ名をマージ先ブランチ名に更新する関数。

**シグネチャ**:
```typescript
export async function updateSpecBranchToBaseBranch(
  db: Kysely<Database>,
  specId: string,
  baseBranch: string  // ← pr.base.ref（develop または main）
): Promise<void>
```

**処理内容**:
```typescript
await db
  .updateTable('specs')
  .set({ branch_name: baseBranch })  // ← develop または main
  .where('id', '=', specId)
  .execute();
```

**修正前の誤った呼び出し**（手動SQLクエリ）:
```sql
UPDATE specs SET branch_name = '' WHERE id = 'c5cc9cb4-...';  -- ❌ 空文字列を設定
```

**正しい呼び出し** (`cleanupMergedPullRequest`):
```typescript
const baseBranch = pr.base.ref;  // ← 'develop' または 'main'
await updateSpecBranchToBaseBranch(trx, spec.id, baseBranch);
```

### 7.4. セキュリティ考慮事項

#### GitHub トークンの管理

- 環境変数 `GITHUB_TOKEN` でトークンを管理
- トークン未設定の場合は適切なエラーメッセージを表示
- トークンをログに出力しない

#### SQL インジェクション対策

- Kysely のパラメータ化クエリを使用
- 手動SQLクエリを使用しない

#### ブランチ削除の安全性

- 保護ブランチ（`main`, `develop`, `master`）は削除しない
- ブランチ名のバリデーション（`isProtectedBranch()`）

### 7.5. テスト戦略

#### 単体テスト

1. **`getSpecWithGitHubInfo()` のテスト**
   - [ ] `github_sync` テーブルに PR 情報が記録されている場合、正しく取得できること
   - [ ] `github_sync` テーブルに PR 情報が記録されていない場合、`pr_number: null` を返すこと
   - [ ] JOIN 条件が正しいこと（`entity_id` と `entity_type` を使用）

2. **`cleanupMergedPullRequest()` のテスト**
   - [ ] PR が作成済みの場合、正しく処理が完了すること
   - [ ] PR が未作成の場合、適切なエラーメッセージを返すこと
   - [ ] PR が未マージの場合、適切なエラーメッセージを返すこと
   - [ ] フォールバック処理で GitHub API からブランチ名で PR を検索できること

3. **`updateSpecBranchToBaseBranch()` のテスト**
   - [ ] `specs.branch_name` が `pr.base.ref` に更新されること
   - [ ] 空文字列ではなく、`develop` または `main` が設定されること

#### 統合テスト

1. **PR マージ後の後処理フロー**
   - [ ] PR 作成 → マージ → `/cft:pr-cleanup` 実行 → ブランチ削除 + データベース更新
   - [ ] `github_sync` テーブルに PR 情報が記録されていない場合のフォールバック処理

#### E2Eテスト

1. **完全なワークフロー**
   - [ ] `/cft:spec-phase <spec-id> completed` → PR 作成 → マージ → `/cft:pr-cleanup` → ブランチ削除
   - [ ] データベース整合性の確認（`specs.branch_name` が `develop` または `main` に更新）

---

## 8. 実装タスクリスト

### タスク 1: PR 情報が github_sync テーブルに記録されていない場合の GitHub API フォールバック処理を実装する

**優先度**: 高
**依存関係**: なし

**実装内容**:

- `cleanupMergedPullRequest()` 関数内で、`pr_number` が存在しない場合のフォールバック処理を追加
- GitHub API (`pulls.list`) でブランチ名から PR を検索
- PR が見つかった場合、`pr_number` を取得して処理を継続
- PR が見つからない場合、適切なエラーメッセージを表示

**対象ファイル**:

- `src/integrations/github/pr-cleanup.ts:150-156`

### タスク 2: cleanupMergedPullRequest() 関数の PR 存在判定エラーハンドリングを改善する

**優先度**: 高
**依存関係**: タスク 1

**実装内容**:

- PR が作成されていない場合と、データベース記録が不完全な場合を区別
- エラーメッセージをユーザーにとって理解しやすく改善
- フォールバック処理で PR が見つかった場合、警告メッセージを表示（データベース記録が不完全であることを通知）

**対象ファイル**:

- `src/integrations/github/pr-cleanup.ts:150-156`

### タスク 3: updateSpecBranchToBaseBranch() が pr.base.ref を正しく受け取ることを確認する

**優先度**: 中
**依存関係**: タスク 1, 2

**実装内容**:

- `cleanupMergedPullRequest()` 関数内で `updateSpecBranchToBaseBranch(trx, spec.id, baseBranch)` が正しく呼び出されていることを確認
- `baseBranch` に `pr.base.ref`（develop または main）が渡されていることを確認
- 空文字列が渡されていないことを検証

**対象ファイル**:

- `src/integrations/github/pr-cleanup.ts:233`

### タスク 4: getSpecWithGitHubInfo() の JOIN 条件が正しいことを確認する

**優先度**: 低
**依存関係**: なし

**実装内容**:

- `getSpecWithGitHubInfo()` 関数が `entity_id` と `entity_type` を使用していることを確認
- `spec_id` カラムを参照していないことを確認
- JOIN クエリの正しさを単体テストで検証

**対象ファイル**:

- `src/core/database/helpers.ts:44`

### タスク 5: 単体テストを作成・更新する

**優先度**: 高
**依存関係**: タスク 1, 2, 3, 4

**実装内容**:

- `getSpecWithGitHubInfo()` のテスト
  - `github_sync` テーブルに PR 情報が記録されている場合
  - `github_sync` テーブルに PR 情報が記録されていない場合
  - JOIN 条件が正しいこと
- `cleanupMergedPullRequest()` のテスト
  - PR が作成済みの場合
  - PR が未作成の場合
  - PR が未マージの場合
  - フォールバック処理で GitHub API からブランチ名で PR を検索できること
- `updateSpecBranchToBaseBranch()` のテスト
  - `specs.branch_name` が `pr.base.ref` に更新されること
  - 空文字列ではなく、`develop` または `main` が設定されること

**対象ファイル**:

- `tests/integrations/github/pr-cleanup.test.ts` (新規作成または更新)
- `tests/core/database/helpers.test.ts` (新規作成または更新)

### タスク 6: 型チェック・リント実行で品質確認を行う

**優先度**: 高
**依存関係**: タスク 1, 2, 3, 4, 5

**実装内容**:

- `npx tsc --noEmit` で型エラーがないことを確認
- `npm run lint` で ESLint 警告がないことを確認
- `npm run lint:fix` で自動修正可能なエラーを修正

### タスク 7: 統合テストで PR マージ後の後処理フローを検証する

**優先度**: 中
**依存関係**: タスク 1, 2, 3, 4, 5, 6

**実装内容**:

- PR 作成 → マージ → `/cft:pr-cleanup` 実行 → ブランチ削除 + データベース更新
- `github_sync` テーブルに PR 情報が記録されていない場合のフォールバック処理
- データベース整合性の確認（`specs.branch_name` が `develop` または `main` に更新）

**対象ファイル**:

- `tests/integrations/github/pr-cleanup-integration.test.ts` (新規作成)

---
