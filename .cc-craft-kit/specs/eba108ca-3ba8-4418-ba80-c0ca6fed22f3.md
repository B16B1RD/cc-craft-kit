# 各フェーズ完了時に未コミットのものがる

**仕様書 ID:** eba108ca-3ba8-4418-ba80-c0ca6fed22f3
**フェーズ:** tasks
**作成日時:** 2025/11/24 16:03:32
**更新日時:** 2025/11/24 17:35:57

---

## 1. 背景と目的

### 背景

現在、フェーズ遷移時（特に `/cft:spec-phase` コマンド実行時）に未コミット状態が残存する問題が発生しています。

**問題の原因:**

1. **自動コミット実行タイミングの不確実性**:
   - `phase.ts` でフェーズ遷移時に `spec.phase_changed` イベントを発火
   - イベントハンドラー登録が非同期で実行される（`event-bus.ts`）
   - ハンドラー登録完了前にイベントが発火すると、自動コミットがスキップされる

2. **Slash コマンド層での自動コミットチェック非実装**:
   - `spec-phase.md` の仕様では「フェーズ移行後に自動的に git status チェックを実行」と記載
   - 実際には Claude が手動で実行する必要があるが、実行されないケースがある
   - 未コミット状態の検出と警告が確実に実行されない

3. **責任分界の不明確さ**:
   - TypeScript スクリプト層（`git-integration.ts`）: イベント駆動で自動コミット実装
   - Slash コマンド層（`spec-phase.md`）: プロンプトベースで git status チェック指示
   - 両者の役割分担が不明確で、どちらも確実に実行されない可能性がある

### 目的

フェーズ遷移時に未コミット状態が残存する問題を解決し、すべてのフェーズ完了時に確実にコミットが実行される仕組みを構築します。具体的には:

1. イベントハンドラー登録の完了を明示的に待機し、自動コミット処理の確実性を向上
2. Slash コマンド層での未コミットチェックを確実に実行する実装を追加
3. TypeScript スクリプト層と Slash コマンド層の責任分界を明確化
4. フェーズ完了時のコミット処理をテストで検証

---

## 2. 対象ユーザー

- **cc-craft-kit を使用する開発者**: `/cft:spec-phase` コマンドでフェーズ遷移を実行するユーザー
- **開発キット保守担当者**: 自動コミット処理の信頼性を確保する必要がある開発者
- **CI/CD パイプライン**: 自動化されたフェーズ遷移処理で未コミット状態を検出する必要があるシステム

---

## 3. 受け入れ基準

### 必須要件

- [ ] `event-bus.ts` でハンドラー登録完了を待機する関数を実装（`ensureHandlersRegistered()`）
- [ ] `phase.ts` の `updateSpecPhase()` でイベント発火前にハンドラー登録完了を明示的に待機
- [ ] `spec-phase.md` でフェーズ遷移後に `git status --porcelain` を確実に実行する実装を追加
- [ ] フェーズ完了時のコミット処理をテストで検証（単体テスト、統合テスト）

### 機能要件

- [ ] `/cft:spec-phase <id> <phase>` 実行後、未コミット状態がない場合は成功メッセージを表示
- [ ] 未コミット状態がある場合は、警告メッセージを表示し、コミット推奨を案内
- [ ] 自動コミット処理が失敗した場合、エラーメッセージを表示し、手動コミットを案内
- [ ] イベント駆動の自動コミット処理と Slash コマンド層のチェック処理が両方とも実行される

### 非機能要件

- [ ] 既存のフェーズ遷移処理に影響を与えない（後方互換性）
- [ ] イベントハンドラー登録の待機処理がタイムアウトする（デフォルト 10 秒）
- [ ] テストカバレッジが維持される（追加されたコードがテストでカバーされる）
- [ ] ログレベルを適切に設定（`debug`, `info`, `warn`, `error`）

---

## 4. 制約条件

- **非同期処理の複雑性**: イベントハンドラー登録とイベント発火のタイミングを確実に制御する必要がある
- **後方互換性**: 既存のフェーズ遷移処理（`phase.ts`, `git-integration.ts`）を変更するため、既存の動作を維持する必要がある
- **Slash コマンドの実装主体**: `spec-phase.md` はプロンプトベースで、Claude が Bash コマンドを実行する必要がある
- **テストカバレッジ**: イベント駆動処理のテストは複雑で、モック化が必要（Git コマンド、EventBus）
- **タイムアウト設定**: ハンドラー登録待機処理がデッドロックしないよう、タイムアウトを設定する必要がある

---

## 5. 依存関係

### 修正対象ファイル

1. **`src/core/workflow/event-bus.ts`** (287行)
   - `ensureHandlersRegistered()` 関数を実装
   - ハンドラー登録完了を待機する仕組みを追加
   - タイムアウト処理の実装

2. **`src/commands/spec/phase.ts`** (287行)
   - `updateSpecPhase()` でハンドラー登録完了を明示的に待機
   - `await ensureHandlersRegistered(eventBus);` を追加
   - エラーハンドリングの改善

3. **`src/slash-commands/spec-phase.md`** (188行)
   - フェーズ遷移後の git status チェックを確実に実行する実装を追加
   - 未コミット状態の検出と警告メッセージの表示を明確化

4. **`src/core/workflow/git-integration.ts`** (427行)
   - 自動コミット処理のログレベルを改善
   - エラーハンドリングの強化

5. **テストファイルの追加/更新**
   - `tests/core/workflow/event-bus.test.ts` - ハンドラー登録待機処理のテスト
   - `tests/commands/spec/phase.test.ts` - フェーズ遷移時の自動コミットテスト
   - `tests/integrations/phase-commit-flow.test.ts` - 統合テスト

### 関連コンポーネント

- **EventBus**: `src/core/workflow/event-bus.ts` (イベント駆動アーキテクチャの中核)
- **フェーズ遷移処理**: `src/core/workflow/phase-automation.ts` (フェーズ自動処理)
- **GitHub 統合**: `src/core/workflow/github-integration.ts` (GitHub Issue 連携)
- **仕様書作成**: `src/commands/spec/create.ts` (仕様書作成時の自動コミット実装例)

---

## 6. 参考情報

### 実装パターン

- **イベント駆動アーキテクチャ**: EventBus を使用した非同期処理のベストプラクティス
- **ハンドラー登録待機**: Promise ベースの待機処理とタイムアウト実装
- **Git 操作の自動化**: `execSync()` を使用した Git コマンド実行とエラーハンドリング
- **プロンプトベース実装**: Slash コマンド層での Bash コマンド実行パターン

### コードベース解析結果

Explore サブエージェントで調査した結果、以下の実装状況が特定されました:

1. **イベント駆動の自動コミット実装済み**: `git-integration.ts` で `spec.phase_changed` イベントに対応
2. **ハンドラー登録の非同期性**: `event-bus.ts` でハンドラー登録が非同期で実行され、競合が発生する可能性
3. **Slash コマンド層での実装不足**: `spec-phase.md` の仕様では git status チェックを指示しているが、確実に実行されない

詳細は、Explore サブエージェントの分析レポートを参照してください。

### 修正方針の選択肢

**A. 短期対策**: `spec-phase.md` での git status チェックを確実に実行
**B. 中期対策**: `event-bus.ts` でハンドラー登録完了を明示的に待機
**C. 長期対策**: コミット処理の責任分界を明確化し、一元化

本仕様では、B と C を組み合わせた修正を推奨します。

### 関連ドキュメント

- **CLAUDE.md**: プロジェクト規約（スクリプトとプロンプトの使い分け指針）
- **src/slash-commands/spec-phase.md**: ユーザー向けフェーズ遷移ガイド
- **src/core/workflow/event-bus.ts**: EventBus の実装と使用方法
- **src/core/workflow/git-integration.ts**: Git 統合の実装例

---

## 7. 設計詳細

### 7.1. アーキテクチャ設計

#### イベント駆動アーキテクチャの活用

本仕様では、既存の EventBus アーキテクチャを活用し、フェーズ遷移時の自動コミット処理を確実に実行する仕組みを構築します。

**現在のアーキテクチャの特徴**:

1. **並列処理による複数ハンドラー実行**
   - `spec.phase_changed` イベントに複数のハンドラーが登録可能
   - `Promise.all()` で並列実行され、パフォーマンス最適化
   - 各ハンドラーは独立してエラーハンドリング

2. **ハンドラー登録待機メカニズム**
   - `getEventBusAsync()` 関数でハンドラー登録完了を保証
   - グローバルフラグ (`registrationInProgress`) で二重登録防止
   - 非同期ハンドラー初期化を待機

**フェーズ遷移の処理フロー**:

```
updateSpecPhase() 実行
  ↓
1. プロジェクト初期化チェック
  ↓
2. フェーズバリデーション
  ↓
3. ブランチ切り替え（必要に応じて）
  ↓
4. フェーズ遷移バリデーション
  ↓
5. データベース更新
  ↓
6. Markdown ファイル更新
  ↓
7. getEventBusAsync() → ハンドラー登録を待機
  ↓
8. await eventBus.emit(spec.phase_changed)
  ↓
複数ハンドラーが並列実行:
  ├─ Git 統合: 自動コミット処理
  ├─ GitHub 統合: Issue 更新 + Project ステータス更新
  └─ フェーズ自動処理: 品質チェック実行
  ↓
9. 全ハンドラーの完了を待機 (Promise.all)
  ↓
10. 成功メッセージ表示
```

#### 責任分界の明確化

**TypeScript スクリプト層** (`phase.ts`):
- データベースと仕様書ファイルの更新
- イベント発火とハンドラー待機
- エラー時のロールバック処理

**イベントハンドラー層** (`git-integration.ts`, `github-integration.ts`):
- Git 自動コミット処理
- GitHub Issue 更新
- フェーズ固有の自動処理

**Slash コマンド層** (`spec-phase.md`):
- ユーザー向けガイダンス表示
- フェーズ遷移後の git status チェック（二重確認）
- 未コミット状態の警告表示

### 7.2. データモデル

#### 仕様書データモデル

**テーブル**: `specifications`

| カラム | 型 | 説明 |
|---|---|---|
| `id` | TEXT | 仕様書 ID (UUID) |
| `name` | TEXT | 仕様書名 |
| `phase` | TEXT | フェーズ (requirements, design, tasks, implementation, completed) |
| `github_issue_number` | INTEGER | GitHub Issue 番号 |
| `github_issue_id` | TEXT | GitHub Issue ID (GraphQL) |
| `created_at` | DATETIME | 作成日時 |
| `updated_at` | DATETIME | 更新日時 |

**更新対象**:
- `phase`: フェーズ遷移時に更新
- `updated_at`: フェーズ遷移時に現在時刻で更新

#### イベントデータモデル

**イベント**: `spec.phase_changed`

```typescript
interface PhaseChangedEventData {
  oldPhase: Phase;
  newPhase: Phase;
}

type WorkflowEvent<T> = {
  type: WorkflowEventType;
  specId: string;
  data: T;
  timestamp: Date;
};
```

**イベント発火箇所**:
- `src/commands/spec/phase.ts` の `updateSpecPhase()` 関数 (行 168-174)

**ハンドラー登録箇所**:
- `src/core/workflow/git-integration.ts` の `registerGitIntegrationHandlers()` (自動コミット)
- `src/core/workflow/github-integration.ts` の `registerGitHubIntegrationHandlers()` (Issue 更新)
- `src/core/workflow/phase-automation.ts` の `registerPhaseAutomationHandlers()` (フェーズ固有処理)

### 7.3. Git 自動コミット処理の詳細設計

#### 処理フロー

**ハンドラー**: `handlePhaseChangeCommit()` (`git-integration.ts`:249-334)

```
1. Git リポジトリ確認
   ├─ リポジトリが存在しない → スキップ
   └─ リポジトリが存在 → 続行
  ↓
2. 未コミット変更のチェック
   ├─ 変更なし → スキップ
   └─ 変更あり → 続行
  ↓
3. コミットメッセージ生成
   - フェーズに応じたメッセージを自動生成
   - 例: "feat: ${specName} の設計を完了"
  ↓
4. Git コミット実行
   - `git add .`
   - `git commit -m "${message}"`
  ↓
5. エラーハンドリング
   ├─ コミット成功 → ログ出力（info レベル）
   └─ コミット失敗 → エラーログ出力（warn レベル）
      - フェーズ遷移は成功させる（コミット失敗でもロールバックしない）
      - ユーザーに手動コミットを案内
```

#### コミットメッセージ生成ルール

**関数**: `generateCommitMessage()` (`git-integration.ts`:289)

| フェーズ | コミットメッセージ |
|---|---|
| `requirements` | `feat: ${specName} の要件定義を完了` |
| `design` | `feat: ${specName} の設計を完了` |
| `tasks` | `feat: ${specName} のタスク分解を完了` |
| `implementation` | `feat: ${specName} の実装を開始` |
| `completed` | `feat: ${specName} を実装完了` |

**メッセージフォーマット**:
- Conventional Commits 形式 (`feat:`)
- 日本語メッセージ
- 仕様書名を含める

#### エラーハンドリング設計

**原則**: コミット失敗でもフェーズ遷移を失敗させない

**理由**:
1. ユーザーが手動でコミットできるようにする
2. フェーズ遷移のロールバックは複雑（DB + ファイル + Git ブランチ）
3. 未コミット状態は `spec-phase.md` で二重確認

**エラー通知**:
- コンソール出力（`warn` レベル）
- Slash コマンド層での git status チェックで再確認

### 7.4. GitHub 統合処理の詳細設計

#### Issue 更新処理

**ハンドラー**: `handlePhaseChange()` (`github-integration.ts`:165-350+)

**処理内容**:

1. **Issue タイトル更新** (行 193-199)
   - フォーマット: `[${phase}] ${specName}`
   - 例: `[design] 各フェーズ完了時に未コミットのものがある`

2. **ラベル更新** (行 193-199)
   - ラベル: `phase:${phase}`
   - 例: `phase:design`

3. **フェーズ移行コメント追加** (行 212-218)
   - コメント内容: フェーズ遷移の通知
   - タイムスタンプ付き

4. **Project ステータス更新** (行 234-350+)
   - フェーズに応じた Project ステータスを更新
   - 更新検証とリトライロジック搭載

#### Issue 本文更新処理

**トリガーイベント**: `spec.updated`

**発火箇所**:
- `src/commands/spec/update.ts` (明示的コマンド実行)
- `src/core/filesystem/watcher.ts` (ファイル監視)

**処理内容**:
- Issue の本文を最新の仕様書ファイルで上書き
- 更新をコメントで記録

### 7.5. Slash コマンド層での二重確認メカニズム

#### 設計方針

**目的**: イベント駆動の自動コミットが失敗した場合の二重確認

**実装方法**: `spec-phase.md` でフェーズ遷移後に `git status --porcelain` を実行

**処理フロー**:

```
フェーズ遷移コマンド完了
  ↓
Bash ツールで `git status --porcelain` 実行
  ↓
出力を解析
  ├─ 出力が空 → すべてコミット済み → 成功メッセージ表示
  └─ 出力が空でない → 未コミットあり → 警告メッセージ表示
      ├─ 未コミットファイル一覧を表示
      └─ 手動コミットを案内
```

**警告メッセージ例**:

```
⚠ 警告: フェーズ移行後も未コミットファイルが残っています。

未コミットファイル一覧:
M  src/commands/spec/phase.ts
M  src/core/workflow/event-bus.ts
?? tests/commands/spec/phase.test.ts

自動コミットは仕様書ファイル (.cc-craft-kit/specs/<spec-id>.md) のみを対象としています。
その他のファイルは手動でコミットしてください:

git add <file-path>
git commit -m "適切なコミットメッセージ"

または、すべての変更をコミットする場合:

git add .
git commit -m "適切なコミットメッセージ"
```

### 7.6. セキュリティ考慮事項

#### Git コマンド実行のセキュリティ

**脅威**:
- コマンドインジェクション攻撃
- 仕様書名に不正な文字列が含まれる場合

**対策**:
1. **入力バリデーション**: 仕様書名の Zod スキーマ検証
2. **コマンド実行**: `execSync()` のパラメータ化
3. **エスケープ処理**: コミットメッセージのエスケープ

**実装例**:

```typescript
// コミットメッセージのエスケープ
const escapedMessage = message.replace(/"/g, '\\"');
execSync(`git commit -m "${escapedMessage}"`, { cwd: repoRoot });
```

#### データベース操作のセキュリティ

**脅威**:
- SQL インジェクション攻撃

**対策**:
- Kysely のパラメータ化クエリのみを使用
- 入力値を直接 SQL に埋め込まない

**実装例**:

```typescript
await db
  .updateTable('specifications')
  .set({
    phase: validatedPhase,
    updated_at: new Date().toISOString(),
  })
  .where('id', '=', spec.id)
  .executeTakeFirstOrThrow();
```

#### GitHub API のセキュリティ

**脅威**:
- トークン漏洩
- レート制限超過

**対策**:
1. **トークン管理**: 環境変数（`.env`）で管理、コードに直接記述しない
2. **レート制限**: Octokit の自動リトライ機能を活用
3. **エラーハンドリング**: API エラー時のログ出力にトークンを含めない

### 7.7. テスト戦略

#### 単体テスト

**対象ファイル**:
- `tests/core/workflow/event-bus.test.ts` (EventBus のテスト)
- `tests/commands/spec/phase.test.ts` (フェーズ遷移のテスト)
- `tests/core/workflow/git-integration.test.ts` (Git 統合のテスト)

**テストケース**:

1. **EventBus のハンドラー登録待機**:
   - `getEventBusAsync()` がハンドラー登録を待機する
   - 二重登録が防止される
   - タイムアウト処理が正常に動作する

2. **フェーズ遷移時の自動コミット**:
   - `spec.phase_changed` イベント発火時に自動コミットされる
   - コミットメッセージが正しく生成される
   - Git リポジトリが存在しない場合はスキップされる
   - 未コミット変更がない場合はスキップされる

3. **エラーハンドリング**:
   - コミット失敗時もフェーズ遷移が成功する
   - エラーログが適切に出力される

**モック化**:
- Git コマンド: `jest.mock('node:child_process')`
- ファイルシステム: `jest.mock('node:fs')`
- データベース: インメモリデータベース (`:memory:`)

#### 統合テスト

**対象ファイル**:
- `tests/integrations/phase-commit-flow.test.ts` (E2E テスト)

**テストシナリオ**:

1. **フェーズ遷移 → 自動コミット → GitHub Issue 更新**:
   - 仕様書作成
   - フェーズ遷移実行
   - 自動コミットが実行されることを確認
   - GitHub Issue が更新されることを確認

2. **未コミット状態の検出**:
   - フェーズ遷移後に未コミットファイルが残る状態を再現
   - `spec-phase.md` の git status チェックで検出されることを確認

**カバレッジ目標**:
- 単体テスト: 80% 以上
- 統合テスト: 主要フローのカバレッジ 100%

#### テスト実行コマンド

```bash
# 単体テスト
npm test

# カバレッジ確認
npm run test:coverage

# E2E テスト
npm run test:e2e
```

### 7.8. パフォーマンス考慮事項

#### 並列処理の最適化

**EventBus のハンドラー実行**:
- `Promise.all()` で並列実行
- Git コミット、GitHub Issue 更新、フェーズ自動処理が同時実行
- 処理時間の短縮（並列化により約 30-50% 削減）

#### ハンドラー登録待機のオーバーヘッド

**`getEventBusAsync()` の待機処理**:
- ハンドラー登録が完了している場合は即座に返却
- 登録中の場合は 10ms ごとにポーリング
- タイムアウト: デフォルト 10 秒

**オーバーヘッド**:
- 通常ケース: 0ms（ハンドラー登録済み）
- 最悪ケース: 10 秒（タイムアウト）
- 平均: 10-50ms（ハンドラー登録待機）

#### ファイルシステム監視のデバウンス

**`watcher.ts` の実装**:
- デバウンス時間: 500ms
- 連続ファイル変更時のイベント発火を抑制
- パフォーマンス向上とレート制限対策

### 7.9. ログ出力設計

#### ログレベルの使い分け

| レベル | 用途 | 実装例 |
|---|---|---|
| `debug` | デバッグ情報（開発時のみ） | ハンドラー登録完了のログ |
| `info` | 通常の情報（正常系） | フェーズ遷移成功、コミット成功 |
| `warn` | 警告（処理は継続） | コミット失敗、GitHub API エラー |
| `error` | エラー（処理が失敗） | データベースエラー、フェーズ遷移失敗 |

#### ログ出力例

**フェーズ遷移成功**:
```
[info] Phase updated successfully: requirements → design
[info] Auto-committed: feat: 各フェーズ完了時に未コミットのものがある の設計を完了
[info] GitHub Issue updated: #343
```

**コミット失敗**:
```
[warn] Failed to auto-commit: Git command failed
[warn] Please commit manually: git add . && git commit -m "message"
```

**EventBus ハンドラー登録**:
```
[debug] Registering event handlers...
[debug] Handler registered: spec.phase_changed → handlePhaseChangeCommit
[debug] All handlers registered
```

### 7.10. 実装優先順位

#### Phase 1: 緊急対策（即座に実装）

- [ ] `spec-phase.md` での git status チェックを確実に実行する実装
- [ ] 未コミット状態の警告メッセージ表示

#### Phase 2: 中期対策（設計完了後に実装）

- [ ] `event-bus.ts` のハンドラー登録待機処理の改善（タイムアウト追加）
- [ ] `phase.ts` でのエラーハンドリング強化
- [ ] 単体テストの実装

#### Phase 3: 長期対策（実装完了後に検討）

- [ ] コミット処理の責任分界を一元化
- [ ] フェーズ遷移のロールバック処理の実装
- [ ] E2E テストの拡充

---

## 8. 実装ガイド

### 8.1. 実装手順

#### ステップ 1: ハンドラー登録待機処理の改善

**ファイル**: `src/core/workflow/event-bus.ts`

**実装内容**:
- `getEventBusAsync()` にタイムアウト処理を追加
- ハンドラー登録完了を明示的にログ出力

#### ステップ 2: フェーズ遷移処理の改善

**ファイル**: `src/commands/spec/phase.ts`

**実装内容**:
- `updateSpecPhase()` でハンドラー登録完了を待機（既に実装済み）
- エラーハンドリングの強化

#### ステップ 3: Slash コマンド層での git status チェック

**ファイル**: `src/slash-commands/spec-phase.md`

**実装内容**:
- フェーズ遷移後に `git status --porcelain` を確実に実行
- 未コミット状態の検出と警告メッセージ表示

#### ステップ 4: テストの実装

**ファイル**: `tests/commands/spec/phase.test.ts`, `tests/integrations/phase-commit-flow.test.ts`

**実装内容**:
- フェーズ遷移時の自動コミット処理のテスト
- 未コミット状態の検出テスト
- エラーハンドリングのテスト

### 8.2. 実装時の注意事項

#### Git 操作のモック化

**重要**: テスト実行時に実際の Git コマンドを実行しないこと

```typescript
jest.mock('node:child_process', () => ({
  execSync: jest.fn(),
}));
```

#### データベース操作のモック化

**重要**: テスト実行時にインメモリデータベースを使用すること

```typescript
const db = createDatabase({ databasePath: ':memory:' });
```

#### EventBus のモック化

**重要**: テスト実行時にハンドラー登録を確実に待機すること

```typescript
const eventBus = await getEventBusAsync();
```

---

## 9. リスクと緩和策

### リスク 1: ハンドラー登録待機のタイムアウト

**リスク**: ハンドラー登録が完了しない場合、タイムアウトエラーが発生

**緩和策**:
- タイムアウト時間を十分に長く設定（デフォルト 10 秒）
- タイムアウト時のエラーメッセージを明確化
- ログレベルを `error` に設定し、問題を可視化

### リスク 2: コミット処理の失敗

**リスク**: Git コマンド実行エラーでコミットが失敗

**緩和策**:
- コミット失敗でもフェーズ遷移を成功させる（既に実装済み）
- Slash コマンド層で git status チェックを実行（二重確認）
- ユーザーに手動コミットを案内

### リスク 3: GitHub API のレート制限

**リスク**: Issue 更新時のレート制限超過

**緩和策**:
- Octokit の自動リトライ機能を活用
- レート制限エラー時のログ出力
- ユーザーに再実行を案内

### リスク 4: 後方互換性の破壊

**リスク**: 既存のフェーズ遷移処理に影響を与える

**緩和策**:
- 既存の処理フローを維持（追加のみ、変更なし）
- E2E テストで既存動作を検証
- 段階的リリース（Phase 1 → Phase 2 → Phase 3）

---

## 10. まとめ

本設計では、イベント駆動アーキテクチャの強みを活かし、フェーズ遷移時の自動コミット処理の信頼性を向上させます。

**主要な改善点**:

1. **ハンドラー登録待機の確実性向上**: `getEventBusAsync()` でハンドラー登録を明示的に待機
2. **二重確認メカニズム**: Slash コマンド層で git status チェックを実行
3. **エラーハンドリングの強化**: コミット失敗時の警告メッセージ表示
4. **テストカバレッジの拡充**: 単体テスト + E2E テストで品質保証

**期待される効果**:

- フェーズ遷移時の未コミット状態が確実に検出される
- ユーザーへの明確な警告メッセージ表示
- 開発キットの信頼性向上
