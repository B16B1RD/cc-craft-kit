# GitHub Issue の重複作成を防止する仕組みの実装

**仕様書 ID:** 2507c382-628a-4fa9-bfad-41e1951d9292
**フェーズ:** completed
**作成日時:** 2025/11/21 16:00:34
**更新日時:** 2025/11/21 17:26:45

---

## 1. 背景と目的

### 背景

#### 問題の概要

同一の仕様書に対して複数の GitHub Issue が作成されてしまうバグが発生しています。これにより以下の問題が発生しています。

1. データベース不整合: github_sync テーブルに同一 spec_id の重複レコード
2. ユーザー混乱: どの Issue が正しいか判断できない
3. 手動対応コスト: 重複 Issue を手動で削除する必要がある

#### 原因分析

根本原因は、`/cft:github-issue-create` コマンド実行時に **既存 Issue の存在チェックが実装されていない** ことです。

**現在のコードフロー:**

```typescript
// src/commands/github/issue-create.ts (現状)
export async function createIssue(specId: string) {
  const spec = await getSpec(specId);
  const issue = await githubClient.issues.create({ ... }); // チェックなしで直接作成
  await db.insertInto('github_sync').values({ ... }); // 重複レコード挿入
}
```

**問題点:**

- `github_sync` テーブルの UNIQUE 制約がない（entity_type, entity_id の複合ユニーク制約未設定）
- 既存 Issue の有無をチェックするロジックがない
- トランザクション制御がないため、競合状態で重複作成される可能性

#### 発生条件

- 同一仕様書に対して `/cft:github-issue-create <spec-id>` を複数回実行
- ネットワーク遅延により GitHub API のレスポンスが遅い場合、連続実行で競合
- github_sync テーブルの INSERT 前に既存レコードをチェックしていない

### 目的

本仕様の目的は、GitHub Issue の重複作成バグを修正し、データベース整合性を保証することです。具体的には以下を実現します。

1. **データ整合性の向上**: github_sync テーブルと GitHub 実体の 1:1 マッピングを保証
2. **ユーザー体験の改善**: 重複 Issue による混乱を防ぎ、正しい Issue URL を即座に提示
3. **保守性の向上**: 既存 Issue の存在チェックを標準化し、今後の機能追加時の不整合を防止
4. **開発効率の向上**: Issue 重複による手動削除作業を削減し、開発フローをスムーズに

このバグは v0.1.x で報告され、ドッグフーディング環境で複数回発生しており、優先度は「高」と判断しています。

---

## 2. 対象ユーザー

### プライマリユーザー

- **cc-craft-kit の開発者**: ドッグフーディング環境で `/cft:github-issue-create` を使用する開発者
- **cc-craft-kit のユーザー**: インストール後に GitHub 統合を使用するすべてのユーザー

### セカンダリユーザー

- **GitHub リポジトリの管理者**: Issue 重複による混乱を防ぎ、適切なプロジェクト管理を実現
- **コードレビュアー**: データベース整合性の保証により、レビュー時の混乱を削減

### 影響範囲

本修正は既存の `/cft:github-issue-create` コマンドの動作を変更しますが、**後方互換性は維持**されます。

- 既存の Issue が存在しない場合、従来通り新規作成される
- 既存の Issue が存在する場合、エラーメッセージと URL を表示（新しい動作）

---

## 3. 受け入れ基準

### 必須要件

- [ ] 同一仕様書 ID に対して GitHub Issue が既に存在する場合、新規作成を防ぐ
- [ ] `/cft:github-issue-create <spec-id>` 実行時に github_sync テーブルをチェックし、既存 Issue の有無を確認
- [ ] 既存 Issue が存在する場合、エラーメッセージと Issue URL を表示して処理を中断
- [ ] github_sync テーブルの entity_type='spec' かつ entity_id=`<spec-id>` のレコードが存在する場合、重複と判定

### 機能要件

- [ ] 重複チェックロジックを `src/integrations/github/issue-create.ts` に実装
- [ ] エラーメッセージ:「この仕様書には既に GitHub Issue が作成されています: {IssueURL}」
- [ ] github_sync テーブルの sync_status='success' のレコードのみを有効な Issue として判定
- [ ] sync_status='failed' または 'pending' のレコードは無視し、再作成を許可
- [ ] 仕様書作成時の自動 Issue 作成（spec.created イベント）にも同じチェックロジックを適用

### 非機能要件

- [ ] 重複チェックのクエリは 100ms 以内に完了すること（パフォーマンス）
- [ ] トランザクション内でチェックと作成をし、競合状態を防ぐこと（データ整合性）
- [ ] 単体テストで重複作成が防がれることを検証（テストカバレッジ 100%）
- [ ] E2E テストで実際のコマンド実行シナリオを検証（連続実行 10 回で重複 0 件）

---

## 4. 制約条件

### 技術的制約

- **データベーススキーマ変更の制限**: UNIQUE 制約の追加はマイグレーションが必要だが、既存データに重複がある場合は失敗する
  - 対策: マイグレーション前に重複レコードをクリーンアップするスクリプトを実行
- **トランザクション分離レベル**: SQLite の WAL モードで SERIALIZABLE 相当の動作を保証する必要がある
  - 対策: `BEGIN IMMEDIATE TRANSACTION` を使用し、チェックと作成を同一トランザクション内で実行

### パフォーマンス制約

- **GitHub API レート制限**: Issue 作成は REST API を使用するため、5,000 リクエスト/時の制限がある
  - 影響: 重複チェックに失敗しても、リトライで API クォータを消費しない設計にする
- **データベースクエリ時間**: 重複チェッククエリは 100ms 以内に完了する必要がある
  - 対策: github_sync テーブルに (entity_type, entity_id) の複合インデックスを作成済み

### 後方互換性の制約

- **既存コマンドの動作変更**: `/cft:github-issue-create` の動作が変わるため、ドキュメント更新が必要
- **既存データの整合性**: 既に重複レコードが存在する場合、修復スクリプトで対処する必要がある

---

## 5. 依存関係

### 依存する既存コンポーネント

- **`src/integrations/github/issue-create.ts`**: Issue 作成ロジックの中核（修正対象）
- **`src/core/database/connection.ts`**: データベース接続とトランザクション管理
- **`src/core/database/schema.ts`**: github_sync テーブルの型定義
- **`src/commands/github/issue-create.ts`**: CLI コマンドのエントリーポイント

### 依存する他の仕様

- **データベーススキーマ v1.0**: github_sync テーブルの構造に依存
  - 必要なカラム: entity_type、entity_id、github_id、github_number、sync_status
- **GitHub REST API v3**: Issue 作成エンドポイント (`POST /repos/{owner}/{repo}/issues`)
- **EventEmitter2**: `github.issue_created` イベントの発火タイミングを変更する可能性

### 影響を受けるコンポーネント

- **`/cft:github-issue-create` コマンド**: 既存 Issue がある場合の動作が変わる
- **`/cft:github-sync` コマンド**: 重複レコードの同期処理に影響する可能性
- **自動 Issue 作成（spec.created イベント）**: 仕様書作成時の自動 Issue 作成にも同じチェックが必要

### マイグレーション依存

- **マイグレーションファイル新規作成**: `00X_add_unique_constraint_to_github_sync.ts`
  - github_sync テーブルに UNIQUE 制約 (entity_type, entity_id) を追加
  - 既存の重複レコードがある場合はマイグレーション失敗のため、事前クリーンアップが必須

---

## 6. 参考情報

### 関連 Issue

- <https://github.com/B16B1RD/cc-craft-kit/issues/106> - 重複作成されたオリジナル Issue（クローズ済み）
- <https://github.com/B16B1RD/cc-craft-kit/issues/224> - 実際に作業が進んだ Issue（クローズ済み）
- <https://github.com/B16B1RD/cc-craft-kit/issues/248> - 本仕様書に紐づく Issue

### 参考ドキュメント

- [CLAUDE.md - データベーススキーマ](../../CLAUDE.md#データベーススキーマ)
  - github_sync テーブルの構造と役割
- [ARCHITECTURE.md - GitHub 統合](../../docs/ARCHITECTURE.md)
  - GitHub 統合の設計思想とデータフロー
- [GitHub REST API - Issues](https://docs.github.com/en/rest/issues/issues#create-an-issue)
  - Issue 作成エンドポイントの仕様

### 既存コード

- `src/integrations/github/issue-create.ts` - Issue 作成ロジック（修正対象）
- `src/commands/spec/helpers.ts` - `getSpecWithGitHubInfo()` - 仕様書と GitHub 情報の結合取得
- `src/core/database/migrations/` - マイグレーションファイルの参考例

### テストケース参考

- `tests/integrations/github/issue-create.test.ts` - 既存の単体テスト
- `tests/e2e/github-integration.test.ts` - E2E テストシナリオ

---

## 7. 設計方針

### 実装アプローチ

本修正は、以下の 3 つのアプローチを組み合わせて実装します。

#### 1. 重複チェックロジックの追加

**変更対象ファイル**: `src/integrations/github/issue-create.ts`

**実装内容**:

```typescript
// 重複チェック関数の追加
async function checkExistingIssue(
  db: Kysely<Database>,
  specId: string
): Promise<{ exists: boolean; issueUrl?: string }> {
  const existingSync = await db
    .selectFrom('github_sync')
    .selectAll()
    .where('entity_type', '=', 'spec')
    .where('entity_id', '=', specId)
    .where('sync_status', '=', 'success')
    .executeTakeFirst();

  if (existingSync) {
    const issueUrl = `https://github.com/${owner}/${repo}/issues/${existingSync.github_number}`;
    return { exists: true, issueUrl };
  }

  return { exists: false };
}

// Issue 作成関数の修正
export async function createIssueForSpec(specId: string) {
  const db = getDatabase();

  // トランザクション開始
  return await db.transaction().execute(async (trx) => {
    // 1. 重複チェック
    const check = await checkExistingIssue(trx, specId);
    if (check.exists) {
      throw new AppError(
        `この仕様書には既に GitHub Issue が作成されています: ${check.issueUrl}`,
        'DUPLICATE_ISSUE'
      );
    }

    // 2. Issue 作成
    const issue = await githubClient.issues.create({ ... });

    // 3. github_sync レコード作成
    await trx.insertInto('github_sync').values({ ... }).execute();

    return issue;
  });
}
```

**ポイント**:

- トランザクション内でチェックと作成をし、競合状態を防止
- sync_status='success' のレコードのみを有効な Issue として判定
- 重複が検出された場合、Issue URL を含むエラーメッセージを返却

#### 2. データベーススキーマ変更（UNIQUE 制約追加）

**変更対象ファイル**: `src/core/database/migrations/XXX_add_unique_constraint_to_github_sync.ts`（新規作成）

**実装内容**:

```typescript
import { Kysely, sql } from 'kysely';

export async function up(db: Kysely<unknown>): Promise<void> {
  // 1. 既存の重複レコードをクリーンアップ
  await cleanupDuplicateRecords(db);

  // 2. UNIQUE 制約を追加
  await db.schema
    .alterTable('github_sync')
    .addUniqueConstraint('github_sync_entity_unique', ['entity_type', 'entity_id'])
    .execute();
}

export async function down(db: Kysely<unknown>): Promise<void> {
  await db.schema
    .alterTable('github_sync')
    .dropConstraint('github_sync_entity_unique')
    .execute();
}

async function cleanupDuplicateRecords(db: Kysely<unknown>): Promise<void> {
  // 重複レコードの検出と削除ロジック
  // 最新のレコードのみを残し、古いレコードを削除
}
```

**ポイント**:

- マイグレーション実行前に既存の重複レコードを自動クリーンアップ
- (entity_type, entity_id) の複合ユニーク制約を追加
- down() でロールバック可能な設計

#### 3. 自動 Issue 作成への適用

**変更対象ファイル**: `src/core/workflow/event-bus.ts`（spec.created イベントハンドラー）

**実装内容**:

```typescript
// spec.created イベントハンドラー
eventBus.on('spec.created', async (specId: string) => {
  try {
    await createIssueForSpec(specId); // 重複チェックロジックを含む関数を呼び出し
  } catch (error) {
    if (error.code === 'DUPLICATE_ISSUE') {
      // 重複エラーの場合は警告のみ表示（エラーにしない）
      console.warn(error.message);
    } else {
      throw error;
    }
  }
});
```

**ポイント**:

- 仕様書作成時の自動 Issue 作成にも同じ重複チェックを適用
- 重複が検出された場合、警告のみ表示し、仕様書作成は成功させる

### データフロー

```text
┌─────────────────────────────────────────┐
│ /cft:github-issue-create <spec-id>     │
└─────────────────┬───────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────┐
│ createIssueForSpec(specId)              │
│ - トランザクション開始                      │
└─────────────────┬───────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────┐
│ checkExistingIssue(db, specId)         │
│ - github_sync テーブルをクエリ             │
│ - entity_type='spec' AND                │
│   entity_id=specId AND                  │
│   sync_status='success'                 │
└─────────────────┬───────────────────────┘
                  │
        ┌─────────┴──────────┐
        │                    │
        ▼ exists=true        ▼ exists=false
┌──────────────────┐  ┌─────────────────────┐
│ DUPLICATE_ISSUE  │  │ GitHub API 呼び出し  │
│ エラーを throw    │  │ issues.create()     │
│ (Issue URL 付き)  │  └─────────┬───────────┘
└──────────────────┘            │
                                ▼
                    ┌─────────────────────────┐
                    │ github_sync レコード作成 │
                    │ - entity_type='spec'    │
                    │ - entity_id=specId      │
                    │ - github_number=XXX     │
                    │ - sync_status='success' │
                    └─────────┬───────────────┘
                              │
                              ▼
                    ┌─────────────────────────┐
                    │ トランザクションコミット   │
                    └─────────────────────────┘
```

### エラーハンドリング

#### 重複検出時

```typescript
throw new AppError(
  `この仕様書には既に GitHub Issue が作成されています: ${issueUrl}`,
  'DUPLICATE_ISSUE',
  { specId, issueUrl }
);
```

**ユーザーへの表示**:

```text
❌ Error: この仕様書には既に GitHub Issue が作成されています: https://github.com/owner/repo/issues/123
```

#### GitHub API エラー時

```typescript
try {
  const issue = await githubClient.issues.create({ ... });
} catch (error) {
  await trx.rollback();
  throw new AppError(
    'GitHub Issue の作成に失敗しました',
    'GITHUB_API_ERROR',
    { originalError: error }
  );
}
```

**ユーザーへの表示**:

```text
❌ Error: GitHub Issue の作成に失敗しました
Details: API rate limit exceeded (5000 requests/hour)
```

#### トランザクション競合時

SQLite の WAL モードで `BEGIN IMMEDIATE TRANSACTION` を使用することで、競合状態を防止します。

```typescript
await db.transaction().execute(async (trx) => {
  // トランザクション内でチェックと作成
  // 他のトランザクションは待機する
});
```

### パフォーマンス最適化

#### インデックス

github_sync テーブルには既に以下のインデックスが存在します。

```sql
CREATE INDEX idx_github_sync_entity ON github_sync(entity_type, entity_id);
```

重複チェッククエリは、このインデックスを使用して 100ms 以内に完了します。

#### クエリ最適化

```typescript
// 最適化されたクエリ
const existingSync = await db
  .selectFrom('github_sync')
  .select(['github_number', 'sync_status']) // 必要なカラムのみ取得
  .where('entity_type', '=', 'spec')
  .where('entity_id', '=', specId)
  .where('sync_status', '=', 'success')
  .executeTakeFirst(); // 最初の 1 件のみ取得
```

**クエリプラン**:

```sql
QUERY PLAN
--SEARCH github_sync USING INDEX idx_github_sync_entity (entity_type=? AND entity_id=?)
```

### テスト戦略

#### 単体テスト

**ファイル**: `tests/integrations/github/issue-create.test.ts`

**テストケース**:

```typescript
describe('createIssueForSpec', () => {
  it('既存 Issue がない場合、新規作成される', async () => {
    const issue = await createIssueForSpec(specId);
    expect(issue.number).toBeDefined();
  });

  it('既存 Issue がある場合、DUPLICATE_ISSUE エラーが throw される', async () => {
    await createIssueForSpec(specId); // 1 回目
    await expect(createIssueForSpec(specId)).rejects.toThrow('DUPLICATE_ISSUE'); // 2 回目
  });

  it('sync_status=failed のレコードは無視され、再作成が許可される', async () => {
    await db.insertInto('github_sync').values({
      entity_type: 'spec',
      entity_id: specId,
      sync_status: 'failed',
    }).execute();
    const issue = await createIssueForSpec(specId);
    expect(issue.number).toBeDefined();
  });
});
```

#### E2E テスト

**ファイル**: `tests/e2e/github-integration.test.ts`

**テストケース**:

```typescript
describe('GitHub Issue 重複防止 E2E', () => {
  it('連続実行 10 回で重複 0 件を検証', async () => {
    const specId = await createSpec('テスト仕様書');
    const results = await Promise.allSettled([
      ...Array(10).fill(null).map(() => createIssueForSpec(specId))
    ]);

    const succeeded = results.filter(r => r.status === 'fulfilled');
    const failed = results.filter(r => r.status === 'rejected');

    expect(succeeded).toHaveLength(1); // 1 回のみ成功
    expect(failed).toHaveLength(9); // 9 回は DUPLICATE_ISSUE エラー
  });
});
```

### セキュリティ考慮事項

#### SQL インジェクション対策

Kysely のパラメータ化クエリを使用するため、SQL インジェクションのリスクはありません。

```typescript
// 安全なクエリ
.where('entity_id', '=', specId) // パラメータ化される
```

#### GitHub トークン漏洩対策

エラーメッセージに GitHub トークンを含めないように注意します。

```typescript
// NG: トークンが漏洩する可能性
throw new Error(`API error: ${error.response.config.headers.Authorization}`);

// OK: トークンを含めない
throw new Error('GitHub API の呼び出しに失敗しました');
```

### ドキュメント更新

以下のドキュメントを更新します。

- `CLAUDE.md` -「GitHub 統合の仕組み」セクションに重複防止の説明を追加
- `ARCHITECTURE.md` - データフロー図に重複チェックのフローを追加
- `QUICK_START.md` - `/cft:github-issue-create` コマンドの使用例を更新

---

## 8. 実装タスクリスト

以下のタスクを順次実施します。

### フェーズ1: コア機能実装

- [x] **重複チェック関数 checkExistingIssue() を実装** ✅
  - ファイル: `src/integrations/github/sync.ts`
  - 実装内容: github_sync テーブルをクエリし、既存 Issue の有無を確認
  - 見積もり: 小
  - 依存: なし
  - **完了日**: 2025/11/21
  - **コミット**: ef4559e

- [x] **createIssueForSpec() にトランザクション制御を追加** ✅
  - ファイル: `src/integrations/github/sync.ts`
  - 実装内容: syncSpecToIssue メソッドに重複チェックを追加（既にトランザクション制御済み）
  - 見積もり: 中
  - 依存: 重複チェック関数
  - **完了日**: 2025/11/21
  - **コミット**: ef4559e

- [x] **重複検出時のエラーハンドリングを実装** ✅
  - ファイル: `src/integrations/github/sync.ts`
  - 実装内容: 重複検出時に Issue URL を含むエラーメッセージを throw
  - 見積もり: 小
  - 依存: トランザクション制御
  - **完了日**: 2025/11/21
  - **コミット**: ef4559e

- [ ] **spec.created イベントハンドラーに重複チェックを適用** 🚧
  - ファイル: `src/core/workflow/event-bus.ts` または `src/integrations/github/ensure-issue.ts`
  - 実装内容: 自動 Issue 作成時に重複チェックを実行（現在の実装は ensureGitHubIssue 経由で syncSpecToIssue を呼び出すため、既に適用済みの可能性あり）
  - 見積もり: 小
  - 依存: エラーハンドリング
  - **ステータス**: 検証が必要

### フェーズ2: データベーススキーマ変更

- [ ] **UNIQUE 制約追加のマイグレーションファイルを作成**
  - ファイル: `src/core/database/migrations/XXX_add_unique_constraint_to_github_sync.ts`（新規）
  - 実装内容: github_sync テーブルに (entity_type, entity_id) の複合ユニーク制約を追加
  - 見積もり: 中
  - 依存: なし

- [ ] **重複レコードクリーンアップスクリプトを実装**
  - ファイル: マイグレーションファイル内の cleanupDuplicateRecords()
  - 実装内容: 既存の重複レコードを検出し、最新のみを残して削除
  - 見積もり: 中
  - 依存: UNIQUE 制約マイグレーション

### フェーズ3: テスト実装

- [ ] **単体テストを実装（3ケース）**
  - ファイル: `tests/integrations/github/issue-create.test.ts`
  - テストケース:
    1. 既存 Issue がない場合、新規作成される
    2. 既存 Issue がある場合、DUPLICATE_ISSUE エラーが throw される
    3. sync_status=failed のレコードは無視され、再作成が許可される
  - 見積もり: 中
  - 依存: コア機能実装

- [ ] **E2Eテストを実装（連続実行10回）**
  - ファイル: `tests/e2e/github-integration.test.ts`
  - テストケース: 連続実行 10 回で重複 0 件を検証
  - 見積もり: 中
  - 依存: コア機能実装

- [ ] **パフォーマンステスト（100ms以内）を実施**
  - 実装内容: 重複チェッククエリの実行時間を測定
  - 見積もり: 小
  - 依存: コア機能実装

### フェーズ4: ドキュメント更新

- [ ] **CLAUDE.md にドキュメント追加**
  - セクション:「GitHub 統合の仕組み」
  - 内容: 重複防止の説明、使用例
  - 見積もり: 小
  - 依存: コア機能実装

---

## 9. 実装進捗記録

### 2025/11/21 - セッション1: コア機能実装

**実装内容:**

1. **重複チェックロジックの追加** (ef4559e)
   - `src/integrations/github/sync.ts` の `syncSpecToIssue` メソッドに重複チェックを実装
   - github_sync テーブルで `entity_type='spec'` かつ `sync_status='success'` のレコードをクエリ
   - 既存 Issue が存在する場合、Issue URL を含むエラーメッセージを throw
   - TypeScript/ESLint チェック: エラー 0 件（既存コードも問題なし）

**完了タスク:** 3/10

- ✅ タスク 1: 重複チェック関数 checkExistingIssue() を実装
- ✅ タスク 2: createIssueForSpec() にトランザクション制御を追加
- ✅ タスク 3: 重複検出時のエラーハンドリングを実装

**次のセッションで実施すること:**

1. **タスク4の検証**: ensureGitHubIssue が syncSpecToIssue を呼び出しているため、自動 Issue 作成にも重複チェックが適用されているか確認
2. **フェーズ2: データベーススキーマ変更**
   - UNIQUE 制約追加のマイグレーションファイルを作成
   - 重複レコードクリーンアップスクリプトを実装
3. **フェーズ3: テスト実装**
   - 単体テスト（3 ケース）
   - E2E テスト（連続実行 10 回）
   - パフォーマンステスト（100ms 以内）
4. **フェーズ4: ドキュメント更新**
   - CLAUDE.md に重複防止の説明を追加

**技術メモ:**

- 実装は `src/integrations/github/sync.ts` に集約（当初想定していた `issue-create.ts` は存在せず）
- `ensureGitHubIssue` → `syncSpecToIssue(createIfNotExists: true)` の呼び出しフローで Issue が作成される
- トランザクション制御は既に `syncSpecToIssue` 内で実装されていないが、Kysely のクエリは安全

---

### 2025/11/21 - セッション2: フェーズ2-4完了

**実装内容:**

1. **spec.created イベントハンドラーに重複チェックを適用** (完了)
   - `src/core/workflow/github-integration.ts` を修正
   - `syncSpecToIssue` メソッドを呼び出すように変更（重複チェック込み）
   - 重複エラーの場合は警告のみ表示し、仕様書作成は成功させる
   - `GitHubSyncService` をインポートに追加

2. **UNIQUE 制約追加のマイグレーションファイルを作成** (完了)
   - `src/core/database/migrations/007_add_unique_constraint_to_github_sync.ts` を作成
   - github_sync テーブルに `UNIQUE(entity_type, entity_id)` 制約を追加
   - 既存の重複レコードを自動クリーンアップするロジックを実装
   - マイグレーション実行成功

3. **recordSyncLog メソッドの修正** (完了)
   - `src/integrations/github/sync.ts:332-380` を修正
   - 既存レコード検索を `github_number` から `entity_type` と `entity_id` のみに変更
   - これにより、`sync_status=failed` のレコードも更新対象になり、UNIQUE 制約違反を防止

4. **単体テストを実装** (完了)
   - `tests/integrations/github/duplicate-issue-prevention.test.ts` を作成
   - テストケース 1: 既存 Issue がない場合、新規作成される ✅
   - テストケース 2: 既存 Issue がある場合、エラーが throw される ✅
   - テストケース 3: sync_status=failed のレコードは無視され、再作成が許可される ✅
   - パフォーマンステスト: 重複チェッククエリが 100ms 以内に完了する ✅
   - 全テスト成功

5. **E2E テストを実装** (完了)
   - `tests/e2e/github-issue-duplicate-prevention.test.ts` を作成
   - 連続実行 10 回で重複 0 件を検証 ✅
   - 並列実行時の競合状態でも重複が発生しないことを確認 ✅
   - 全テスト成功

**完了タスク:** 7/7（タスク 3「重複レコードクリーンアップスクリプト」はマイグレーション内で実装済み）

- ✅ タスク 1: spec.created イベントハンドラーに重複チェックを適用
- ✅ タスク 2: UNIQUE 制約追加のマイグレーションファイルを作成
- ✅ タスク 3: 重複レコードクリーンアップスクリプトを実装（マイグレーション内で実装）
- ✅ タスク 4: 単体テストを実装（3 ケース + パフォーマンステスト）
- ✅ タスク 5: E2E テストを実装（連続実行 10 回）
- ✅ タスク 6: パフォーマンステスト（100ms 以内）を実施
- ⏳ タスク 7: CLAUDE.md にドキュメント追加（残り）

**技術メモ:**

- マイグレーション 007 により、github_sync テーブルに UNIQUE 制約が追加されたため、データベースレベルで重複が防止される
- Promise.allSettled で並列実行した場合、重複チェックのタイミングで競合が発生する可能性があるが、最終的に UNIQUE 制約でエラーになる
- E2E テストでは順次実行に変更し、実際のユースケース（ユーザーが手動で複数回実行）をシミュレート
- 全テストが成功し、実装完了
