# /cft:spec-pahse <id> completed の処理見直し

**仕様書 ID:** 394bf0cc-13ac-454a-ad52-d8dbeb753b31
**フェーズ:** completed
**作成日時:** 2025/11/24 22:58:28
**更新日時:** 2025/11/24 23:30:34

---

## 1. 背景と目的

### 背景

現在、多くの部分がスクリプトで実現されていて、なかなか仕様通りに動作していない。プロンプト指示だと簡単にできることができていない。PR の作成は、プロンプト指示の方が上手くいく。カスタムスラッシュコマンド→スキル→サブエージェントの構成が上手く実現できていない。改めて、Claude Code のカスタムスラッシュコマンド、スキル、サブエージェントの各機能の仕様についてよく考えて、スクリプトを使わずに仕様を実現できるか再設計して欲しい。スクリプトは最終手段です。

### 目的

`/cft:spec-phase <id> completed` コマンドの PR 自動作成処理を、スクリプト実装からプロンプト指示ベースの実装に再設計し、Claude Code の「プロンプトファースト原則」に従った形に改善する。

---

## 2. 対象ユーザー

**cc-craft-kit を使用する開発者**

- 仕様駆動開発（SDD）で開発を行うソフトウェアエンジニア
- カスタムスラッシュコマンドを実装・メンテナンスする開発者
- プロンプトファースト原則に基づいた開発フローを理解したい開発者

---

## 3. 受け入れ基準

### 必須要件

- [ ] `/cft:spec-phase <id> completed` 実行時、PR が自動作成されること
- [ ] PR 作成処理はプロンプト指示ベース（`spec-phase.md` に記述）で実現されること
- [ ] スクリプト実装は最小限（データベース操作、イベント発火のみ）に留めること

### 機能要件

- [ ] Git 状態確認（未コミット変更検出）がプロンプト指示で実現されること
- [ ] ブランチプッシュ（リモートにない場合）が Bash ツール経由で実行されること
- [ ] PR タイトル・本文が仕様書内容から自動生成されること
- [ ] PR 作成が GitHub CLI（`gh pr create`）経由で実行されること
- [ ] PR URL が仕様書ファイルに記録されること
- [ ] PR 番号がデータベース（`github_sync` テーブル）に記録されること
- [ ] エラー発生時、適切なエラーメッセージが表示されること

### 非機能要件

- [ ] プロンプト指示が可視化され、メンテナンスしやすいこと
- [ ] イベントハンドラーに依存せず、プロンプト指示で制御可能であること
- [ ] GitHub CLI のインストールが前提条件として明示されていること
- [ ] 既存の成功しているパターン（`spec-create.md` のブランチ復帰処理）を参考にすること

---

## 4. 制約条件

### 技術的制約

1. **データベース操作の制約**
   - プロンプト指示から直接データベース操作は不可
   - Kysely による型安全なデータベース操作はスクリプト経由で実施
   - トランザクション管理が必要な処理はスクリプト実装が必須

2. **GitHub API 呼び出しの制約**
   - Octokit（GitHub SDK）を使用する場合はスクリプト実装が必須
   - GitHub CLI（`gh` コマンド）を使用する場合はプロンプト指示で実現可能
   - GitHub CLI のインストールが前提条件

3. **Claude Code ツールの制約**
   - カスタムスラッシュコマンド (.md): データベース操作・GitHub API 呼び出し不可
   - スキル: 実行可能なコードではなく、知識・手順の記述
   - サブエージェント (Task ツール): データベース操作・GitHub API 呼び出し不可

4. **イベント駆動処理の制約**
   - イベント発火（`eventBus.emit`）はスクリプト経由で実施
   - イベントハンドラー内でのツール起動（Task/Skill）は非推奨（プロンプト指示による制御が困難）

### プロジェクト固有の制約

1. **プロンプトファースト原則**
   - 「プロンプトで済ませられることはプロンプトで済ませる」（CLAUDE.md:109）
   - スクリプト実装は判断基準チェックリストで1つ以上該当する場合のみ

2. **既存の成功パターンの踏襲**
   - `spec-create.md` のブランチ復帰処理（Bash ツール経由）
   - `code-review.md` のサブエージェント起動パターン
   - `lint-check.md` のスキル起動 + 自動修正パターン

3. **後方互換性**
   - 既存の `github_sync` テーブルスキーマを維持
   - 既存のイベントハンドラー（`branch-management.ts`）の削除を伴う可能性
   - PR 作成後の Backlog 同期処理（存在する場合）との整合性

---

## 5. 依存関係

### 既存のコンポーネント

1. **`src/slash-commands/spec-phase.md`**
   - 現在の completed フェーズ移行処理の仕様
   - 再設計対象のファイル

2. **`src/commands/spec/phase.ts`**
   - フェーズ遷移スクリプト
   - データベース更新、イベント発火を担当
   - 再設計後も最小限の役割で維持

3. **`src/core/workflow/branch-management.ts`**
   - 現在の PR 自動作成処理（イベントハンドラー方式）
   - `handlePullRequestCreationOnCompleted()` 関数（114-230 行）
   - 再設計後は削除または大幅に簡素化

4. **`src/integrations/github/pull-request.ts`**
   - 現在の PR 作成処理（Octokit 使用）
   - `createPullRequest()` 関数
   - 再設計後は GitHub CLI に置き換え（削除可能）

5. **`.claude/skills/pr-creator/SKILL.md`**
   - PR 作成スキルの定義
   - 再設計後、プロンプト指示から起動する可能性

### 参考にする成功パターン

1. **`src/slash-commands/spec-create.md`**
   - フェーズ 0〜5 の明確なステップ定義（103-265 行）
   - ブランチ復帰処理（Bash ツール経由、223-265 行）

2. **`src/slash-commands/code-review.md`**
   - Glob ツールでファイルパターン解決
   - Task ツールでサブエージェント起動

3. **`src/slash-commands/lint-check.md`**
   - Skill ツールでスキル起動
   - Bash ツールで自動修正

### 外部依存

1. **GitHub CLI (`gh` コマンド)**
   - PR 作成（`gh pr create`）
   - PR 情報取得（`gh pr view`）
   - インストール必須

2. **Git コマンド**
   - ブランチプッシュ（`git push -u origin <branch-name>`）
   - Git 状態確認（`git status --porcelain`）

3. **データベース (`github_sync` テーブル)**
   - PR 番号の記録
   - スクリプト経由でアクセス

---

## 6. 参考情報

### コードベース解析結果

**Explore サブエージェントによる解析結果**（2025/11/24 実施）:

#### 現在の問題点

- completed フェーズ移行処理がイベントハンドラー方式に依存
- スクリプト層で実装された PR 作成処理（Octokit 使用）
- プロンプト指示が機能しない理由: イベントハンドラー経由で実行されるため、プロンプト指示による制御が困難
- pr-creator スキルが存在するが自動起動されない

#### 再設計の指針

**推奨する構成**: カスタムスラッシュコマンド → スクリプト（最小限） → プロンプト指示（PR 作成フロー）

**実装フロー**:
1. `spec-phase.md` でスクリプト実行（データベース更新、イベント発火）
2. completed フェーズ検出（スクリプト出力から `newPhase: completed` を検出）
3. プロンプト指示で PR 作成フロー開始:
   - Git 状態確認（`git status --porcelain`）
   - 仕様書ファイル読み込み（Read ツール）
   - PR タイトル・本文生成（仕様書から自動生成）
   - ブランチプッシュ（`git push -u origin <branch-name>`）
   - PR 作成（`gh pr create --title "..." --body "..." --base "..."`）
   - PR URL の記録（Edit ツールで仕様書ファイルに追記）
   - PR 番号のデータベース記録（スクリプト経由）

### 関連仕様書

- （今後、関連仕様書が作成された場合に追記）

### 外部リンク

- [Claude Code 公式ドキュメント](https://github.com/anthropics/claude-code)
- [GitHub CLI ドキュメント](https://cli.github.com/manual/)
- [cc-craft-kit ARCHITECTURE.md](../docs/ARCHITECTURE.md)

---

## 7. 設計詳細

### 7.1. アーキテクチャ設計

#### 現状分析

**現在のスクリプトベースアーキテクチャ:**

```
フェーズ移行 (implementation → completed)
  ↓
npx tsx .cc-craft-kit/commands/spec/phase.ts
  ├─ データベース更新 (Kysely)
  ├─ フェーズ遷移バリデーション
  └─ イベント発火: spec.phase_changed
        ↓
eventBus.emit() → registerBranchManagementHandlers()
  ↓
handlePullRequestCreationOnCompleted() [branch-management.ts:114-230]
  ├─ Git リポジトリ確認
  ├─ ブランチ検証
  ├─ リモートプッシュ確認・自動プッシュ
  ├─ createPullRequest() [pull-request.ts] (Octokit 使用)
  │   ├─ 仕様書から受け入れ基準抽出
  │   ├─ PR タイトル・本文生成
  │   └─ GitHub REST API 呼び出し
  └─ github_sync テーブル更新
```

**問題点:**

1. **イベント駆動の制約**:
   - イベントハンドラー内でツール起動（Task/Skill）が困難
   - プロンプト指示による制御が不可能
   - エラー発生時の分岐処理が複雑

2. **スクリプト実装の肥大化**:
   - PR タイトル・本文生成ロジックがスクリプト内に埋め込まれている
   - Octokit の認証・エラーハンドリングがスクリプト内に実装
   - プロンプト指示で簡単にできることがスクリプト実装されている

3. **プロンプトファースト原則の違反**:
   - CLAUDE.md:109 「プロンプトで済ませられることはプロンプトで済ませる」に反する
   - 成功パターン（`spec-create.md`）が活用されていない

#### 設計方針: プロンプトベースアーキテクチャへの移行

**新しいアーキテクチャ:**

```
Layer 1: スクリプト実行（最小限の役割）
/cft:spec-phase <id> completed
  ↓
npx tsx .cc-craft-kit/commands/spec/phase.ts
  ├─ データベース更新 (Kysely) [スクリプト必須]
  ├─ フェーズ遷移バリデーション [スクリプト必須]
  ├─ イベント発火: spec.phase_changed [スクリプト必須]
  └─ 出力: newPhase: completed [プロンプト指示の検出トリガー]

Layer 2: プロンプト指示（spec-phase.md に記述）
completed フェーズ検出
  ↓
自動実行フロー開始（ユーザー確認なし）
  ├─ 1. Git 状態確認 [Bash: git status --porcelain]
  ├─ 2. 未コミット変更検出 → 警告表示
  ├─ 3. 仕様書読み込み [Read: .cc-craft-kit/specs/$1.md]
  ├─ 4. PR タイトル・本文生成 [プロンプト処理]
  ├─ 5. GitHub CLI 確認 [Bash: gh auth status]
  ├─ 6. ブランチリモート確認 [Bash: git branch -vv]
  ├─ 7. リモートプッシュ [Bash: git push -u origin <branch>]
  ├─ 8. PR 作成 [Bash: gh pr create]
  ├─ 9. PR URL 記録 [Edit: 仕様書ファイル]
  └─ 10. github_sync 更新 [スクリプト: spec/update-pr.ts]
```

**責務分離:**

| 処理内容 | 担当レイヤー | 実装方法 | 理由 |
|---------|------------|---------|-----|
| データベース更新 | スクリプト | `phase.ts` | Kysely の型安全性が必要 |
| イベント発火 | スクリプト | `phase.ts` | EventBus がスクリプト実装 |
| Git 状態確認 | プロンプト | Bash ツール | 標準 Git コマンドで実現可能 |
| 仕様書読み込み | プロンプト | Read ツール | ファイル読み込み |
| PR タイトル・本文生成 | プロンプト | Claude 推論 | プロンプト処理で自然に生成可能 |
| PR 作成 | プロンプト | Bash (gh pr create) | GitHub CLI で実現可能 |
| 仕様書ファイル更新 | プロンプト | Edit ツール | ファイル編集 |
| github_sync 更新 | スクリプト | `update-pr.ts` (新規) | データベース操作が必要 |

#### 削除対象コンポーネント

1. **`src/core/workflow/branch-management.ts`**
   - `handlePullRequestCreationOnCompleted()` 関数（114-230 行）削除
   - `registerBranchManagementHandlers()` 関数のイベントハンドラー登録削除

2. **`src/integrations/github/pull-request.ts`**
   - `createPullRequest()` 関数削除（GitHub CLI に置き換え）
   - `generatePullRequestBody()` 関数削除（プロンプト処理に置き換え）

3. **イベントハンドラー登録**
   - `src/core/workflow/event-bus.ts` の `registerBranchManagementHandlers()` 呼び出し削除

#### 新規追加コンポーネント

1. **`src/commands/spec/update-pr.ts`** (新規)
   - PR 番号・URL をデータベース (`github_sync`) に記録
   - 引数: `specId`, `prNumber`, `prUrl`
   - 最小限のスクリプト実装

2. **`src/slash-commands/spec-phase.md`** (更新)
   - completed フェーズ検出時の自動実行フロー追加
   - Bash + Read + Edit ツールを組み合わせた PR 作成フロー

---

### 7.2. データモデル

#### github_sync テーブル（既存、変更なし）

**スキーマ定義** (`src/core/database/schema.ts:82-98`):

```typescript
export interface GithubSync {
  id: string;                // UUID
  entity_type: 'spec';       // エンティティ種別（現在は仕様書のみ）
  entity_id: string;         // 仕様書 ID
  github_issue_id: number | null;  // GitHub Issue 番号
  github_issue_url: string | null; // GitHub Issue URL
  pr_number: number | null;        // PR 番号
  pr_url: string | null;           // PR URL
  pr_merged_at: Date | null;       // PR マージ日時
  sync_status: 'pending' | 'synced' | 'error'; // 同期ステータス
  last_synced_at: Date | null;     // 最終同期日時
  created_at: Date;                // 作成日時
  updated_at: Date;                // 更新日時
}
```

**PR 記録時の更新フィールド:**
- `pr_number`: GitHub PR 番号（例: 42）
- `pr_url`: PR の URL（例: `https://github.com/owner/repo/pull/42`）
- `sync_status`: `'synced'` に更新
- `last_synced_at`: 現在日時
- `updated_at`: 現在日時

#### 仕様書ファイル（Markdown）

**追加セクション**（PR 作成後に Edit ツールで追記）:

```markdown
## Pull Request

**PR 番号:** #42
**PR URL:** https://github.com/owner/repo/pull/42
**PR 作成日時:** 2025/11/24 23:30:00
```

---

### 7.3. API の仕様

#### GitHub CLI (`gh pr create`) の使用

**コマンド形式:**

```bash
gh pr create \
  --title "<PR タイトル>" \
  --body "$(cat <<'EOF'
<PR 本文 (Markdown)>
EOF
)" \
  --base "<ベースブランチ>" \
  --head "<現在のブランチ>"
```

**PR タイトル生成ロジック:**

```plaintext
feat: <仕様書名> を実装完了
```

**例:**
```plaintext
feat: /cft:spec-phase <id> completed の処理見直し を実装完了
```

**PR 本文生成ロジック:**

```markdown
## Summary

<仕様書から「1. 背景と目的」「3. 受け入れ基準」を抽出して要約>

## Test plan

<実装済みのテスト概要を記載>

- [ ] 単体テスト実施
- [ ] 統合テスト実施
- [ ] コードレビュー完了

---

🤖 Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>
```

**GitHub CLI 出力形式:**

```plaintext
https://github.com/owner/repo/pull/42
```

→ この URL をパースして PR 番号（42）を抽出し、データベースに記録

#### 新規スクリプト: `update-pr.ts`

**引数スキーマ** (Zod):

```typescript
const argsSchema = z.object({
  specId: z.string().uuid('Invalid spec ID format'),
  prNumber: z.number().int().positive('PR number must be positive integer'),
  prUrl: z.string().url('Invalid PR URL format'),
});
```

**実行例:**

```bash
npx tsx .cc-craft-kit/commands/spec/update-pr.ts \
  394bf0cc-13ac-454a-ad52-d8dbeb753b31 \
  42 \
  "https://github.com/B16B1RD/cc-craft-kit/pull/42"
```

**実装概要:**

```typescript
export async function updatePullRequest(args: string[]): Promise<void> {
  const parsed = argsSchema.parse({
    specId: args[0],
    prNumber: parseInt(args[1], 10),
    prUrl: args[2],
  });

  const db = getDatabase();

  await db.transaction().execute(async (trx) => {
    const existing = await trx
      .selectFrom('github_sync')
      .where('entity_id', '=', parsed.specId)
      .selectAll()
      .executeTakeFirst();

    if (existing) {
      // 既存レコード更新
      await trx
        .updateTable('github_sync')
        .set({
          pr_number: parsed.prNumber,
          pr_url: parsed.prUrl,
          sync_status: 'synced',
          last_synced_at: new Date(),
          updated_at: new Date(),
        })
        .where('id', '=', existing.id)
        .execute();
    } else {
      // 新規レコード作成
      await trx
        .insertInto('github_sync')
        .values({
          id: randomUUID(),
          entity_type: 'spec',
          entity_id: parsed.specId,
          pr_number: parsed.prNumber,
          pr_url: parsed.prUrl,
          sync_status: 'synced',
          last_synced_at: new Date(),
          created_at: new Date(),
          updated_at: new Date(),
        })
        .execute();
    }
  });

  console.log(`✓ Pull Request #${parsed.prNumber} recorded successfully.`);
}
```

---

### 7.4. セキュリティ考慮事項

#### 認証情報管理

**GitHub CLI 認証:**

```bash
# 初回セットアップ（手動実行）
gh auth login

# 認証状態確認
gh auth status
```

**トークンストレージ:**
- GitHub CLI は `~/.config/gh/hosts.yml` に認証情報を保存
- プロジェクト内には認証情報を保存しない
- `.env` ファイルに `GITHUB_TOKEN` を記載しない（GitHub CLI 認証を使用）

#### 入力検証

**PR タイトル・本文のバリデーション:**

```typescript
// プロンプト処理（spec-phase.md）で実施
- 最大文字数チェック:
  - タイトル: 256 文字以内
  - 本文: 65536 文字以内
- 改行コードの正規化: `\r\n` → `\n`
- 仕様書内容のサニタイゼーション:
  - HTML タグ除去
  - スクリプトタグ除去
```

**GitHub CLI コマンド引数のエスケープ:**

```bash
# HEREDOC を使用して改行・特殊文字を安全に渡す
gh pr create --body "$(cat <<'EOF'
<本文内容>
EOF
)"
```

#### 機密情報の保護

**エラーメッセージ:**

```plaintext
❌ "GitHub API error: token ghp_xxxx is invalid"  # 悪い例（トークン露出）
✅ "GitHub CLI authentication failed. Run 'gh auth login' to authenticate." # 良い例
```

**ログ出力:**

```typescript
// src/core/logging/logger.ts の使用
logger.debug('PR creation request', { specId, branchName }); // トークンを含めない
logger.error('GitHub CLI error', { error: sanitizeError(error) }); // エラー内容をサニタイズ
```

---

### 7.5. テスト戦略

#### 7.5.1. 単体テスト

**対象モジュール:**

1. **`update-pr.ts`**
   - Zod バリデーションの確認
   - データベース更新ロジック
   - トランザクション処理

**テストケース:**

```typescript
// tests/commands/spec/update-pr.test.ts
describe('updatePullRequest()', () => {
  it('should update existing github_sync record', async () => {
    // モック: データベース
    const mockDb = createMockDatabase();

    // テストデータ: 既存レコード
    await mockDb.insertInto('github_sync').values({
      id: 'sync-123',
      entity_id: 'spec-123',
      pr_number: null,
      pr_url: null,
    }).execute();

    // 実行
    await updatePullRequest(['spec-123', '42', 'https://github.com/owner/repo/pull/42']);

    // 検証
    const record = await mockDb
      .selectFrom('github_sync')
      .where('entity_id', '=', 'spec-123')
      .selectAll()
      .executeTakeFirst();

    expect(record?.pr_number).toBe(42);
    expect(record?.pr_url).toBe('https://github.com/owner/repo/pull/42');
    expect(record?.sync_status).toBe('synced');
  });

  it('should create new github_sync record if not exists', async () => {
    // モック: データベース（空）
    const mockDb = createMockDatabase();

    // 実行
    await updatePullRequest(['spec-456', '99', 'https://github.com/owner/repo/pull/99']);

    // 検証
    const record = await mockDb
      .selectFrom('github_sync')
      .where('entity_id', '=', 'spec-456')
      .selectAll()
      .executeTakeFirst();

    expect(record).toBeDefined();
    expect(record?.pr_number).toBe(99);
  });

  it('should throw error for invalid UUID', async () => {
    await expect(
      updatePullRequest(['invalid-uuid', '42', 'https://github.com/owner/repo/pull/42'])
    ).rejects.toThrow('Invalid spec ID format');
  });

  it('should throw error for negative PR number', async () => {
    await expect(
      updatePullRequest(['spec-123', '-1', 'https://github.com/owner/repo/pull/42'])
    ).rejects.toThrow('PR number must be positive integer');
  });
});
```

#### 7.5.2. 統合テスト

**対象フロー:**

```
/cft:spec-phase <id> completed
  → spec-phase.md の自動実行フロー
  → gh pr create
  → update-pr.ts
  → github_sync テーブル更新
```

**テスト環境:**
- `:memory:` データベース
- GitHub CLI のモック（`gh` コマンドをスタブ化）
- Git リポジトリのモック（一時ディレクトリ）

**テストケース:**

```typescript
// tests/integration/spec-phase-completed.test.ts
describe('spec-phase completed フロー統合テスト', () => {
  beforeEach(() => {
    // モック: GitHub CLI
    jest.spyOn(child_process, 'execSync').mockImplementation((cmd) => {
      if (cmd.includes('gh pr create')) {
        return Buffer.from('https://github.com/owner/repo/pull/42');
      }
      if (cmd.includes('gh auth status')) {
        return Buffer.from('✓ Logged in to github.com as user');
      }
      return Buffer.from('');
    });
  });

  it('should complete full workflow: phase → PR → github_sync', async () => {
    // 1. スペック作成
    const spec = await db.insertInto('specs').values({
      id: 'spec-test-123',
      name: 'テスト仕様',
      phase: 'implementation',
    }).returning('*').executeTakeFirst();

    // 2. フェーズ移行
    await phaseUpdate(['spec-test-123', 'completed']);

    // 3. プロンプト指示で PR 作成（モック）
    await updatePullRequest(['spec-test-123', '42', 'https://github.com/owner/repo/pull/42']);

    // 4. github_sync テーブル確認
    const syncRecord = await db
      .selectFrom('github_sync')
      .where('entity_id', '=', 'spec-test-123')
      .selectAll()
      .executeTakeFirst();

    expect(syncRecord?.pr_number).toBe(42);
    expect(syncRecord?.pr_url).toBe('https://github.com/owner/repo/pull/42');
    expect(syncRecord?.sync_status).toBe('synced');
  });

  it('should handle gh cli authentication error', async () => {
    // モック: 認証失敗
    jest.spyOn(child_process, 'execSync').mockImplementation(() => {
      throw new Error('gh: Not logged in');
    });

    // 実行
    await expect(
      // プロンプト指示でのエラーハンドリングをテスト
      // （実際には spec-phase.md の指示で gh auth status を実行）
    ).rejects.toThrow('Not logged in');
  });
});
```

#### 7.5.3. E2E テスト（手動実行）

**前提条件:**
- GitHub リポジトリへのアクセス権限
- GitHub CLI 認証済み (`gh auth login`)
- 開発用ブランチが存在

**テスト手順:**

```bash
# 1. テスト仕様書作成
/cft:spec-create "E2E テスト用仕様書"

# 2. フェーズを completed に移行
/cft:spec-phase <spec-id> completed

# 3. PR 作成フローの自動実行確認
# - Bash ツールで git status 実行
# - Read ツールで仕様書読み込み
# - Bash ツールで gh pr create 実行
# - Edit ツールで仕様書更新

# 4. GitHub で PR が作成されたか確認
gh pr view <pr-number>

# 5. データベース確認
npx tsx .cc-craft-kit/commands/spec/get.ts <spec-id>
# → PR 番号・URL が記録されているか確認
```

#### 7.5.4. テストカバレッジ目標

| モジュール | 対象 | 目標カバレッジ |
|----------|------|--------------|
| `update-pr.ts` | PR 記録スクリプト | 85% |
| `spec-phase.md` | プロンプト指示（手動確認） | N/A（E2E テスト） |
| GitHub CLI 連携 | `gh pr create` 実行 | 75%（モック） |

---

### 7.6. 実装フロー（spec-phase.md の自動実行フロー）

#### completed フェーズ検出時の処理

**自動実行フロー** (`src/slash-commands/spec-phase.md` に記述):

```markdown
## completed フェーズに移行した場合

重要: コマンド実行後、ユーザーに確認を求めずに、以下の処理を**自動的に実行**してください。

### Step 1: Git 状態確認（必須）

1. **未コミット変更検出**: Bash ツールで `git status --porcelain` 実行
2. **警告表示**:
   - 出力が空でない場合: 未コミットファイル一覧と推奨アクション表示
   - 出力が空の場合: 次のステップへ進む

### Step 2: PR 作成準備

1. **仕様書読み込み**: Read ツールで `.cc-craft-kit/specs/$1.md` を読み込む
2. **PR タイトル生成**: 仕様書名から自動生成
   - 形式: `feat: <仕様書名> を実装完了`
3. **PR 本文生成**: 仕様書から抽出
   - Summary: 「1. 背景と目的」「3. 受け入れ基準」を要約
   - Test plan: 実装済みテスト概要
   - 署名: "🤖 Generated with Claude Code"

### Step 3: GitHub CLI 確認

1. **認証状態確認**: Bash ツールで `gh auth status` 実行
2. **エラーハンドリング**:
   - 認証失敗時: `gh auth login` を実行するよう案内
   - 成功時: 次のステップへ進む

### Step 4: ブランチリモートプッシュ

1. **リモート追跡確認**: Bash ツールで `git branch -vv | grep '*'` 実行
2. **リモートプッシュ**:
   - リモート追跡がない場合: `git push -u origin <現在のブランチ>`
   - リモート追跡がある場合: スキップ

### Step 5: PR 作成

1. **PR 作成**: Bash ツールで `gh pr create` 実行
   ```bash
   gh pr create \
     --title "feat: <仕様書名> を実装完了" \
     --body "$(cat <<'EOF'
   <PR 本文>
   EOF
   )" \
     --base "develop"
   ```

2. **PR URL 取得**: コマンド出力から URL を取得
   - 例: `https://github.com/owner/repo/pull/42`

3. **PR 番号抽出**: URL から PR 番号を抽出
   - 正規表現: `/pull/(\d+)$`

### Step 6: PR 情報記録

1. **仕様書ファイル更新**: Edit ツールで仕様書に PR セクション追加
   ```markdown
   ## Pull Request

   **PR 番号:** #42
   **PR URL:** https://github.com/owner/repo/pull/42
   **PR 作成日時:** <現在日時>
   ```

2. **github_sync テーブル更新**: Bash ツールで `update-pr.ts` 実行
   ```bash
   npx tsx .cc-craft-kit/commands/spec/update-pr.ts \
     <spec-id> \
     42 \
     "https://github.com/owner/repo/pull/42"
   ```

### Step 7: 成功メッセージ表示

```plaintext
✓ Pull Request が正常に作成されました！

PR 番号: #42
PR URL: https://github.com/owner/repo/pull/42

次のステップ:
- PR をレビューしてください
- マージ後、/cft:pr-cleanup <spec-id> でブランチ削除
```
```

---

### 7.7. マイグレーション計画

#### フェーズ 1: 新規コンポーネント実装

**タスク:**
1. `src/commands/spec/update-pr.ts` 作成
2. 単体テスト実装 (`tests/commands/spec/update-pr.test.ts`)
3. 型定義・Zod スキーマ作成

**成果物:**
- PR 記録スクリプト
- 単体テスト（カバレッジ 85% 以上）

#### フェーズ 2: spec-phase.md 更新

**タスク:**
1. `src/slash-commands/spec-phase.md` に completed フェーズの自動実行フロー追加
2. Bash + Read + Edit ツールを組み合わせた PR 作成フロー記述
3. エラーハンドリング分岐処理の記述

**成果物:**
- 更新された spec-phase.md
- E2E テスト手順書

#### フェーズ 3: 既存コンポーネント削除

**タスク:**
1. `src/core/workflow/branch-management.ts` から `handlePullRequestCreationOnCompleted()` 削除
2. `src/integrations/github/pull-request.ts` から `createPullRequest()` 削除
3. イベントハンドラー登録削除

**成果物:**
- クリーンアップされたコードベース
- 削減された依存関係（Octokit 削除可能）

#### フェーズ 4: 統合テスト・E2E テスト

**タスク:**
1. 統合テスト実装 (`tests/integration/spec-phase-completed.test.ts`)
2. E2E テスト手動実行
3. GitHub CLI モックの実装

**成果物:**
- 統合テスト（カバレッジ 75% 以上）
- E2E テスト結果レポート

#### フェーズ 5: ドキュメント更新

**タスク:**
1. CLAUDE.md に実装パターン追記
2. README.md にコマンド説明更新
3. 仕様書を completed フェーズに移行

**成果物:**
- 更新されたドキュメント
- ユーザー向けガイド

---

### 7.8. リスクと緩和策

#### リスク 1: GitHub CLI 未インストール

**影響度:** 高
**緩和策:**
- 事前チェック: `gh --version` で確認
- エラーメッセージに明確なインストール手順を記載

#### リスク 2: GitHub CLI 認証失敗

**影響度:** 中
**緩和策:**
- `gh auth status` で認証状態確認
- 認証失敗時、`gh auth login` を実行するよう案内

#### リスク 3: ネットワークエラー（PR 作成失敗）

**影響度:** 中
**緩和策:**
- エラーメッセージを表示
- 手動でのリトライ案内（同じコマンド再実行）

#### リスク 4: データベース更新失敗

**影響度:** 低（PR 自体は作成済み）
**緩和策:**
- トランザクション処理でロールバック
- 手動での `update-pr.ts` 再実行案内

#### リスク 5: プロンプト指示の不明瞭さ

**影響度:** 高
**緩和策:**
- spec-create.md の成功パターンを参考にした明確な指示
- フェーズごとの入出力を明示
- エラー時の分岐処理を詳細に記述

---

## 8. 実装タスクリスト

### フェーズ 1: 新規コンポーネント実装

- [ ] `src/commands/spec/update-pr.ts` を作成
  - Zod スキーマ定義（specId, prNumber, prUrl）
  - データベース更新ロジック実装（既存レコード更新 or 新規作成）
  - トランザクション処理実装
  - エラーハンドリング実装

- [ ] `tests/commands/spec/update-pr.test.ts` を作成
  - 既存レコード更新のテストケース
  - 新規レコード作成のテストケース
  - 無効な UUID のバリデーションテスト
  - 負の PR 番号のバリデーションテスト
  - カバレッジ目標: 85% 以上

### フェーズ 2: spec-phase.md 更新

- [ ] `src/slash-commands/spec-phase.md` を更新
  - completed フェーズ検出時の自動実行フロー追加
  - Step 1: Git 状態確認（`git status --porcelain`）
  - Step 2: PR 作成準備（仕様書読み込み、タイトル・本文生成）
  - Step 3: GitHub CLI 確認（`gh auth status`）
  - Step 4: ブランチリモートプッシュ（`git push -u origin <branch>`）
  - Step 5: PR 作成（`gh pr create`）
  - Step 6: PR 情報記録（仕様書ファイル更新、github_sync 更新）
  - Step 7: 成功メッセージ表示

- [ ] エラーハンドリング分岐処理を記述
  - GitHub CLI 未インストール時のエラーメッセージ
  - 認証失敗時の案内（`gh auth login`）
  - ネットワークエラー時のリトライ案内

### フェーズ 3: 既存コンポーネント削除

- [ ] `src/core/workflow/branch-management.ts` から `handlePullRequestCreationOnCompleted()` を削除（114-230 行）

- [ ] `src/integrations/github/pull-request.ts` から `createPullRequest()` 関数を削除

- [ ] `src/integrations/github/pull-request.ts` から `generatePullRequestBody()` 関数を削除

- [ ] `src/core/workflow/event-bus.ts` から `registerBranchManagementHandlers()` 呼び出しを削除（該当する場合）

- [ ] 未使用の Octokit 依存関係を削除（`package.json`）

### フェーズ 4: 統合テスト・E2E テスト

- [ ] `tests/integration/spec-phase-completed.test.ts` を作成
  - GitHub CLI のモック実装（`gh pr create`, `gh auth status`）
  - フルフロー統合テスト（phase → PR → github_sync）
  - 認証エラーのテスト
  - カバレッジ目標: 75% 以上

- [ ] E2E テスト手動実行
  - テスト仕様書作成
  - `/cft:spec-phase <spec-id> completed` 実行
  - PR 作成フローの自動実行確認
  - GitHub で PR が作成されたか確認
  - データベース確認（PR 番号・URL 記録確認）

### フェーズ 5: ドキュメント更新

- [ ] CLAUDE.md に実装パターン追記
  - プロンプトベース PR 作成パターンを追加
  - 成功事例として記載

- [ ] README.md にコマンド説明更新（必要に応じて）

- [ ] 仕様書を completed フェーズに移行（`/cft:spec-phase 394bf0cc completed`）

## Pull Request

**PR 番号:** #354
**PR URL:** https://github.com/B16B1RD/cc-craft-kit/pull/354
**PR 作成日時:** 2025/11/24 23:32:00
