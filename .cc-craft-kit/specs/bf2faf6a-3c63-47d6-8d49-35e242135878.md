# /cft:spec-phase \<id\> design 完了時、仕様書のコミットがされていない

**仕様書 ID:** bf2faf6a-3c63-47d6-8d49-35e242135878
**フェーズ:** tasks
**作成日時:** 2025/11/22 16:10:01
**更新日時:** 2025/11/22 17:11:43

---

## 1. 背景と目的

### 背景

cc-craft-kit では、`/cft:spec-phase <id> <phase>` コマンドでフェーズを移行する際、自動的に Git コミットを実行する機能が実装されています（Git 自動コミット機能）。しかし、design フェーズへの移行時にコミットが実行されず、仕様書ファイルの変更が未コミット状態のまま残る問題が報告されています。

他のフェーズ（requirements、tasks、implementation）でも同様の問題が発生している可能性があるため、包括的な検証が必要です。

**既知の動作:**

- `spec.phase_changed` イベントが発火し、`handlePhaseChangeCommit()` が呼び出される
- 未コミット変更がない場合、スキップメッセージが表示される
- pre-commit フック失敗時、ステージングがロールバックされる

**問題の症状:**

- design フェーズ移行時、仕様書ファイルが未コミット状態のまま残る
- 自動コミット成功メッセージが表示されない

### 目的

すべてのフェーズ移行時に、仕様書ファイルの変更が適切に Git コミットされることを保証し、開発者がコミット漏れにより発生するバージョン管理の問題を防止します。

---

## 2. 対象ユーザー

- cc-craft-kit を使用する開発者
- 仕様駆動開発（SDD）ワークフローを実践するチーム
- Git でバージョン管理するプロジェクト

---

## 3. 受け入れ基準

### 必須要件

- [ ] `/cft:spec-phase <id> design` 実行時、仕様書ファイルが自動コミットされること
- [ ] `/cft:spec-phase <id> tasks` 実行時、仕様書ファイルが自動コミットされること
- [ ] `/cft:spec-phase <id> implementation` 実行時、仕様書ファイルが自動コミットされること
- [ ] `/cft:spec-phase <id> completed` 実行時、全変更ファイルが自動コミットされること
- [ ] requirements フェーズでも同様にコミットが実行されること

### 機能要件

- [ ] コミットメッセージがフェーズに応じた適切な内容であること（例: `feat: <仕様書名> の設計を完了`）
- [ ] 既存の Git 自動コミット機能（`src/core/workflow/git-integration.ts`）を利用すること
- [ ] コミット失敗時、エラーログを記録し、手動コミット手順をユーザーに案内すること
- [ ] 未コミット変更がない場合、コミットをスキップすること（無駄なコミット防止）
- [ ] pre-commit フック失敗時、ステージングを自動ロールバックすること（`git reset HEAD`）

### 非機能要件

- [ ] Git リポジトリ未初期化時でもエラーで停止せず、警告のみ表示すること
- [ ] コミット失敗時もフェーズ移行は成功すること（ユーザー操作を妨げない）
- [ ] 単体テストで各フェーズ移行時のコミット動作を検証すること
- [ ] E2E テストでフェーズ移行からコミット成功までの一連の動作を検証すること

---

## 4. 制約条件

- `src/core/workflow/git-integration.ts` の既存ロジック（`handlePhaseChangeCommit()`）を再利用すること
- Git コマンド実行は `execSync()` または `spawnSync()` を使用すること（非同期処理は避ける）
- pre-commit フック失敗時は、ステージングをロールバックすること（`git reset HEAD`）
- completed フェーズ以外では、仕様書ファイルのみをコミット対象とすること
- completed フェーズでは、全変更ファイル（`git add .`）をコミット対象とすること
- コミット対象ファイルが `.gitignore` で除外されている場合、コミットをスキップすること

---

## 5. 依存関係

- `src/core/workflow/git-integration.ts` - Git 自動コミット機能の実装
  - `handlePhaseChangeCommit()` - フェーズ変更時の自動コミット処理 (259-344 行目)
  - `generateCommitMessage()` - コミットメッセージ生成 (126-135 行目)
  - `getCommitTargets()` - コミット対象ファイルの決定 (167-184 行目)
  - `gitCommit()` - Git コミット実行 (192-254 行目)
  - `hasUncommittedChanges()` - 未コミット変更のチェック (113-121 行目)
- `src/core/workflow/event-bus.ts` - `spec.phase_changed` イベントのハンドラー登録
- `src/commands/spec/phase.ts` - `/cft:spec-phase` コマンド実装
- `tests/core/workflow/git-integration.test.ts` - 単体テスト

---

## 6. 参考情報

- CLAUDE.md: Git 自動コミット機能のセクション
- `src/core/workflow/git-integration.ts:259-344` - 既存の `handlePhaseChangeCommit()` 実装
- `src/core/workflow/git-integration.ts:126-135` - コミットメッセージ生成ロジック
- GitHub Issue: #277

---

## 7. 設計

### 問題の再調査結果

フェーズ移行テスト（requirements → design）を実施した結果、**Git 自動コミットは正常に動作している**ことが確認されました。

```text
✓ Auto-committed: feat: /cft:spec-phase <id> design 完了時、仕様書のコミットがされていない の設計を完了
```

この結果から、以下の可能性が考えられます。

#### 可能性 1: ユーザーの認識違い

- Git 自動コミット機能は正常に動作しており、問題は存在しない
- ユーザーが自動コミットメッセージを見落としていた可能性

#### 可能性 2: 特定条件下でのみ発生

特定条件下でのみ Git 自動コミットに失敗する可能性があります。

**考えられる特定条件:**

1. **未コミット変更がない場合**:
   - `hasUncommittedChanges()` が `false` を返す
   - 「No uncommitted changes, skipping auto-commit」メッセージが表示される
   - これは正常動作であり、問題ではない

2. **pre-commit フック失敗時**:
   - textlint または markdownlint エラーが発生
   - ステージングが自動ロールバックされる
   - 「You can commit manually with: git add . && git commit」メッセージが表示される
   - これも既知の動作であり、設計通り

3. **Git リポジトリ未初期化**:
   - `isGitRepository()` が `false` を返す
   - 警告メッセージが表示され、コミットがスキップされる
   - これも設計通りの動作

4. **.gitignore でファイルが除外されている場合**:
   - `getIgnoredFiles()` が除外ファイルを検出
   - 「Auto-commit skipped: No files to commit (ignored by .gitignore)」メッセージが表示される
   - これも設計通りの動作

### 結論

**現時点で Git 自動コミット機能に問題は確認されませんでした。**

この仕様書は以下のいずれかの対応を推奨します。

#### 対応案 1: 仕様書をクローズ（問題なし）

Git 自動コミット機能が正常に動作していることを確認したため、仕様書を completed フェーズに移行し、「問題は再現せず」として記録する。

#### 対応案 2: 問題の詳細情報を収集

ユーザーから以下の情報を収集し、問題を再現可能にします。

- 問題が発生した具体的な手順
- 実行時の出力メッセージ（コンソールログ）
- 問題が発生した環境（OS、Git バージョン、cc-craft-kit バージョン）
- `git status` の出力
- `.gitignore` の内容

#### 対応案 3: テストケースの追加（予防保守）

問題が再現しないとしても、将来的な品質保証のため、以下のテストケースを追加します。

1. **各フェーズ移行時の自動コミット検証テスト**:
   - requirements → design
   - design → tasks
   - tasks → implementation
   - implementation → completed

2. **エラーハンドリングのテスト**:
   - pre-commit フック失敗時のロールバック
   - Git リポジトリ未初期化時の警告表示
   - .gitignore 除外ファイルのスキップ

3. **E2E テスト**:
   - フェーズ移行 → 自動コミット → GitHub Issue 更新の一連の流れ

### 推奨する対応

**対応案 3（テストケースの追加）** を推奨します。

理由は以下の通りです。

- Git 自動コミット機能は critical path であり、品質保証が重要である
- 現在、単体テストは存在するが、E2E テストが不足している
- テストケース追加により、将来的な回帰を防止できる
- ユーザーの不安を解消するための客観的なエビデンスとなる

### 実装方針

#### 1. 単体テストの拡充

`tests/core/workflow/git-integration.test.ts` に以下を追加します。

- 各フェーズ（requirements/design/tasks/implementation/completed）でのコミット動作テスト
- コミットメッセージ生成ロジックの検証
- エラーハンドリング（pre-commit フック失敗、Git 未初期化）のテスト

#### 2. E2E テストの追加

`tests/e2e/phase-transition-commit.test.ts` を新規作成します。

- フェーズ移行コマンド実行 → 自動コミット成功 → GitHub Issue 更新の一連の流れを検証
- 実際の Git リポジトリを使用（テスト用の一時ディレクトリを作成）
- コミットログの確認（`git log` の出力を解析）

#### 3. ドキュメント更新

CLAUDE.md の「Git 自動コミット機能」セクションに以下を追加します。

- 自動コミットがスキップされる条件（未コミット変更なし、.gitignore 除外など）
- トラブルシューティングガイド（pre-commit フック失敗時の対処法）
- よくある質問（FAQ）

### アーキテクチャ（変更なし）

既存の Git 統合ハンドラー（`src/core/workflow/git-integration.ts`）に変更は不要です。テストコードとドキュメントのみを追加します。

```text
┌─────────────────────────────────────┐
│  /cft:spec-phase コマンド           │
├─────────────────────────────────────┤
│  spec.phase_changed イベント発火    │
├─────────────────────────────────────┤
│  handlePhaseChangeCommit() 呼び出し │
│  - hasUncommittedChanges()          │
│  - getCommitTargets()               │
│  - generateCommitMessage()          │
│  - gitCommit()                      │
├─────────────────────────────────────┤
│  Git コミット実行                   │
│  - git add <files>                  │
│  - git commit -m "..."              │
├─────────────────────────────────────┤
│  成功/失敗メッセージ表示            │
└─────────────────────────────────────┘
```

### データモデル（変更なし）

既存のデータベーススキーマに変更は不要です。

### API 設計（変更なし）

新しい API は追加されません。既存の関数インターフェースを維持します。
