# 定期的にデータベース不整合となる根本原因の追究

**仕様書 ID:** f1341d15-df2f-48c7-8bbd-ec7fa043749f
**フェーズ:** completed
**作成日時:** 2025/11/20 08:20:04
**更新日時:** 2025/11/20 09:45:29

---

## 1. 背景と目的

### 背景

Claude Code を再起動するたびにデータベース不整合が発生しています。
/cft:create-spec 時に以下のエラーが頻繁に報告されます。

```text
⚠️  Database integrity warnings:
      - Found 1 database record(s) with invalid spec file
```

また、今回は、/cft:status で以下の報告が挙がってきています。

```text
データベース整合性の警告

  ⚠️ データベースに以下の問題が検出されました。
  - 無効な仕様書ファイル: 1 件
  - 無効な仕様書ファイルへの参照レコード: 1 件
```

これは由々しき事態です。早急な解決が望まれます。

### 目的

データベース不整合の根本原因を特定し、恒久的な解決策を実装することで、開発者体験を向上させる。

---

## 2. 対象ユーザー

- cc-craft-kit の開発者
- cc-craft-kit を利用するすべてのユーザー

---

## 3. 受け入れ基準

### 必須要件

- [ ] データベース不整合が発生する具体的なタイミングと条件を特定し、再現手順を文書化する
  - 再現率: 10 回中 8 回以上の頻度で再現できること
  - 再現環境: OS、Claude Code バージョン、データベースサイズを明記
- [ ] 不整合の根本原因を技術的に解明し、原因コードの特定とコードレビューを完了する
  - 根本原因の技術的説明を文書化（ファイルパス、行番号、処理フロー図を含む）
- [ ] 根本原因を解決する恒久的な修正を実装する
  - 単体テストで修正箇所のカバレッジ 100%を達成
  - E2E テストで不整合が発生しないことを検証（100 回連続実行で 0 件）
- [ ] 修正後、Claude Code 再起動を 50 回実行し、不整合が 0 件であることを検証する
  - 検証スクリプトを作成し、自動化すること

### 機能要件

- [ ] データベース整合性チェック機能の動作を詳細に分析する
  - `src/core/database/integrity.ts` の `checkDatabaseIntegrity()` 関数を精査
  - ファイル存在確認の `fs.existsSync()` のタイミングを検証
- [ ] 仕様書作成時のファイル生成・データベース記録処理のトランザクション性を検証する
  - `src/commands/spec/create.ts` の処理順序を分析
  - Kysely トランザクション（`db.transaction()`）の使用状況を確認
  - ファイル書き込み後の `fsync()` 呼び出し有無を確認
- [ ] 複数の Claude Code インスタンス同時起動時の競合状態を調査する
  - 複数インスタンス同時起動テスト（競合状態の検証）
- [ ] WAL モード + busy_timeout の動作を検証する
  - データベース接続ログ（WAL モード、トランザクション開始/終了）を収集
- [ ] 仕様書ファイル削除時のデータベースレコード削除処理を確認する
  - 部分的な成功状態（ファイル作成済み、DB 未記録）の検出

### 非機能要件

- [ ] 修正により既存の仕様書データが失われないこと
  - データベースバックアップを事前に取得
  - 全仕様書ファイル（60 件）のハッシュ値を記録し、修正後に照合
- [ ] パフォーマンスが劣化しないこと
  - 仕様書の作成処理: 修正前後で平均実行時間の差が 10%以内
  - 整合性チェック処理: 修正前後で平均実行時間の差が 10%以内
  - ベンチマークスクリプトを作成し、100 回実行の平均値を比較
- [ ] データベースバックアップ機能が正常に動作すること
  - バックアップファイルが生成されること（`.cc-craft-kit/backups/`）
  - バックアップからの復元が成功すること（テストケース追加）

---

## 4. 制約条件

- 既存の仕様書データ（60 件）を保持すること
  - マイグレーション実行時にデータ損失が発生しないこと
  - ロールバック手順を文書化すること
- データベーススキーマの大幅な変更は避けること
  - 許容される変更: インデックス追加、カラムのデフォルト値変更
  - 非許容の変更: テーブル削除、カラム削除、NOT NULL 制約の追加
  - スキーマ変更が必要な場合はマイグレーションファイルを作成
- GitHub Issue 連携機能に影響を与えないこと
  - `github_sync` テーブルのレコードが保持されること
  - Issue 同期処理（`src/integrations/github/sync.ts`）が正常動作すること
  - E2E テストで Issue 作成・更新を検証
- データベース接続の安全性を維持すること
  - `getDatabase()` の使用パターンを変更しないこと
  - WAL モード + busy_timeout の設定を保持すること

---

## 5. 依存関係

### 関連ファイル

- `src/core/database/connection.ts` - データベース接続管理
  - 調査重点: `createDatabase()` の初期化処理、WAL モード設定
- `src/core/database/integrity.ts` - 整合性チェック機能
  - 調査重点: `checkDatabaseIntegrity()` の判定ロジック、ファイル存在確認のタイミング
- `src/commands/spec/create.ts` - 仕様書の作成処理
  - 調査重点: ファイル作成と DB 記録の順序、トランザクション範囲、エラーハンドリング
- `src/commands/status.ts` - 状態確認処理
  - 調査重点: 整合性チェック実行タイミング、警告表示のロジック
- `src/core/workflow/event-bus.ts` - イベント駆動処理
  - 調査重点: spec.created イベントのハンドラー登録、非同期処理の完了待機
- `src/core/workflow/git-integration.ts` - Git 自動コミット処理
  - 調査重点: コミット実行タイミング、ファイル状態変更の有無

### 調査観点

1. **整合性チェックのロジック**: どのような条件で「無効」と判定されるか
   - `src/core/database/integrity.ts` の `checkDatabaseIntegrity()` 関数を精査
   - ファイル存在確認の `fs.existsSync()` のタイミングを検証
2. **ファイル作成とDB記録の順序**: アトミック性が保証されているか
   - `src/commands/spec/create.ts` の処理順序を分析
   - Kysely トランザクション（`db.transaction()`）の使用状況を確認
   - ファイル書き込み後の `fsync()` 呼び出し有無を確認
3. **イベント駆動処理の副作用**: spec.created イベントでの非同期処理が影響しているか
   - イベントハンドラーの `await` 処理を確認
   - Promise.all() の使用箇所でエラーハンドリングを検証
4. **Git 自動コミット処理**: フェーズ変更時のコミット処理がファイル状態に影響していないか
   - `src/core/workflow/git-integration.ts` のコミットタイミングを分析
   - Git インデックスとワーキングツリーの状態を調査
5. **Claude Code 再起動時の挙動**: プロセス終了時の未完了処理がないか
   - SIGINT/SIGTERM ハンドラーの実装を確認
   - `process.on('exit')` でのクリーンアップ処理を検証
6. **データベーススキーマのトランザクション設計**: ACID 特性が保証されているか
   - SQLite の WAL モード設定を確認
   - トランザクション分離レベルを検証
7. **ファイルシステムの書き込み順序保証**: OS レベルの同期処理が適切か
   - ファイル書き込み後の `fs.fsync()` 呼び出し有無
   - ディレクトリの `fsync()` 呼び出し有無（POSIX セマンティクス）
8. **エラーハンドリングの動作**: 例外発生時のロールバック処理
   - try-catch ブロックでのトランザクションロールバック確認
   - 部分的な成功状態（ファイル作成済み、DB 未記録）の検出

---

## 6. 参考情報

### 観察された現象

- 仕様書の作成直後に不整合カウントが増加（1 件→2 件）
  - 発生日時: 2025/11/20 8:20:04
  - 仕様書 ID: f1341d15-df2f-48c7-8bbd-ec7fa043749f
  - 実行コマンド: `/cft:spec-create`
- Claude Code 再起動時に不整合の報告される頻度が高い
  - 過去の再起動で頻繁に不整合を検出
  - 最終起動: 2025/11/20
- `/cft:status` 実行時に常に同じ警告が表示される
  - 無効な仕様書ファイル: 1 件（同一の spec_id が継続的に報告される可能性）
  - 無効な仕様書ファイルへの参照レコード: 1〜2 件

### CLAUDE.md の関連セクション

- データベース接続の安全性（getDatabase() の使用）
- バックアップ機能（週 1 回自動バックアップ）
- 複数 Claude Code インスタンスでの使用（WAL モード + busy_timeout）

### 想定される原因候補（優先度順）

#### 優先度 High

1. **トランザクション未完了** (可能性: 80%)
   - 理由: ファイル作成と DB 記録が別処理のため、中断時に不整合が発生しやすい
   - 検証方法: `src/commands/spec/create.ts` のトランザクション範囲を確認
   - 修正案: ファイル作成をトランザクション内に含める、または Two-Phase Commit パターンを採用

2. **ファイルシステムとDBの同期タイミング** (可能性: 60%)
   - 理由: ファイル書き込みはバッファリングされるため、DB 記録時点で物理書き込み未完了の可能性
   - 検証方法: `fs.writeFileSync()` 使用箇所を確認、`fsync()` 呼び出し有無を検証
   - 修正案: ファイル書き込み後に明示的な `fsync()` を呼び出す

#### 優先度 Medium

1. **イベントハンドラーの副作用** (可能性: 40%)
   - 理由: spec.created イベントの非同期処理が完了前にプロセス終了の可能性
   - 検証方法: `src/core/workflow/event-bus.ts` のイベントハンドラー登録を確認
   - 修正案: イベント発火を同期的に待機、または処理完了を保証するキュー機構導入

2. **Git 自動コミット処理の影響** (可能性: 30%)
   - 理由: コミット処理中にファイルが一時的に移動・変更される可能性
   - 検証方法: `src/core/workflow/git-integration.ts` のコミット処理を分析
   - 修正案: コミット処理をロック機構で保護

#### 優先度 Low

1. **整合性チェックロジックのバグ** (可能性: 20%)
   - 理由: タイミング依存の誤検知の可能性
   - 検証方法: `src/core/database/integrity.ts` のロジックをコードレビュー
   - 修正案: ファイル存在確認にリトライ機構を追加

---

## 7. テスト戦略

### 単体テスト

- 整合性チェックロジックのテスト（`tests/core/database/integrity.test.ts`）
- 仕様書の作成処理のテスト（`tests/commands/spec/create.test.ts`）
- トランザクション処理のテスト（モック環境で中断をシミュレート）

### 統合テスト

- ファイル作成と DB 記録の一貫性テスト
- イベントハンドラーの完了待機テスト
- Git 自動コミット処理の影響テスト

### E2Eテスト

- Claude Code 再起動シミュレーション（50 回連続実行）
- 複数インスタンス同時起動テスト（競合状態の検証）
- 不整合検出から修復までのフローテスト

---

## 8. ログ収集計画

### デバッグログの有効化

- `LOG_LEVEL=debug` で詳細ログを出力
- ファイル作成、DB 記録、イベント発火のタイムスタンプを記録

### 収集対象ログ

- データベース接続ログ（WAL モード、トランザクション開始/終了）
- ファイルシステム操作ログ（writeFileSync、fsync 呼び出し）
- イベントバスログ（イベント発火、ハンドラー実行開始/終了）
- Git 操作ログ（コミット実行、ファイル追加）

### ログ分析ツール

- タイムスタンプベースの処理フロー可視化
- 不整合発生時のログパターン抽出

---

## 9. 修正アプローチ

### Phase 1: 原因の特定

1. 詳細ログの収集（デバッグモードでの再現テスト）
2. コードレビュー（トランザクション範囲、ファイル書き込み順序）
3. 原因の絞り込み（優先度順に検証）

### Phase 2: 暫定対策の実装

1. 高優先度の原因に対する暫定修正
2. 単体テストの追加
3. 動作検証（10 回の再起動テスト）

### Phase 3: 恒久対策の実装

1. 根本的な修正の実装
2. E2E テストの追加
3. 最終検証（50 回の再起動テスト）

### Phase 4: ドキュメント更新

1. CLAUDE.md の更新（トラブルシューティング項目追加）
2. アーキテクチャドキュメントの更新
3. 修正内容のナレッジベース化

---

## 10. 設計

### アーキテクチャ設計

#### 原因分析のアプローチ

データベース不整合の根本原因を特定するため、以下の段階的アプローチを採用します。

##### Phase 1: 現状把握と再現性確認

1. 整合性チェック処理の詳細分析
   - `src/core/database/integrity.ts` の `checkDatabaseIntegrity()` 関数を精査
   - 判定条件: どのような状態で「無効」と判定されるか
   - ファイル存在確認のタイミング: `fs.existsSync()` の呼び出しタイミング

2. 不整合の再現テスト
   - 仕様書の作成処理を 10 回連続実行
   - Claude Code 再起動後の整合性チェック結果を記録
   - 不整合発生のパターンを分析

##### Phase 2: トランザクション処理の検証

1. 仕様書の作成処理のトランザクション範囲確認
   - `src/commands/spec/create.ts` の処理順序を分析:
     1. データベースレコード作成（`db.insertInto('specs')`）
     2. 仕様書ファイル生成（`fs.writeFileSync()`）
     3. イベント発火（`eventBus.emit('spec.created')`）
   - トランザクション境界の確認
   - ファイル書き込みがトランザクション外の可能性

2. アトミック性の検証
   - ファイル作成と DB 記録が 1 つのトランザクションで処理されているか
   - 中断時のロールバック処理が適切に実装されているか

##### Phase 3: ファイルシステム同期の検証

1. ファイル書き込みの保証確認
   - `fs.writeFileSync()` 使用箇所の特定
   - `fsync()` 呼び出しの有無確認
   - ディレクトリの `fsync()` 呼び出し確認（POSIX セマンティクス）

2. バッファリングの影響調査
   - OS レベルのバッファリング遅延の可能性
   - DB 記録時点でファイルが物理的に書き込まれていない可能性

##### Phase 4: イベント駆動処理の検証

1. spec.created イベントの処理フロー
   - `src/core/workflow/event-bus.ts` のハンドラー登録確認
   - GitHub Issue 自動作成処理の非同期待機
   - Git 自動コミット処理の非同期待機

2. プロセス終了時の未完了処理
   - SIGINT/SIGTERM ハンドラーの実装確認
   - `process.on('exit')` でのクリーンアップ処理
   - 非同期処理の完了待機機構

### データフロー設計

#### 現状のデータフロー（推測）

```text
[仕様書作成コマンド実行]
    ↓
[1. DB レコード作成] ← トランザクション開始
    ↓
[2. ファイル生成] ← トランザクション外？
    ↓
[3. イベント発火: spec.created] ← 非同期処理開始
    ↓                ↓
    |         [GitHub Issue 作成] ← 非同期
    |         [Git 自動コミット] ← 非同期
    ↓
[コマンド終了] ← 非同期処理の完了を待たない？
```

#### 問題点の仮説

1. **トランザクション境界の問題**
   - ファイル生成がトランザクション外で実行される
   - DB 記録成功後、ファイル生成前にプロセスが終了すると不整合が発生

2. **ファイルシステム同期の遅延**
   - `fs.writeFileSync()` は OS バッファに書き込むだけで、物理書き込みは保証しない
   - `fsync()` 呼び出しがない場合、整合性チェック時にファイルが見つからない可能性

3. **非同期処理の未完了**
   - spec.created イベントの非同期ハンドラーが完了前にプロセス終了
   - GitHub Issue 作成や Git コミット処理の途中でプロセスが終了

#### 改善後のデータフロー（提案）

```text
[仕様書作成コマンド実行]
    ↓
[トランザクション開始]
    ↓
[1. DB レコード作成（未コミット）]
    ↓
[2. ファイル生成 + fsync()]
    ↓
[3. ディレクトリ fsync()]
    ↓
[トランザクションコミット] ← ここまでアトミック
    ↓
[イベント発火: spec.created]
    ↓
[非同期処理の完了待機] ← await で同期的に待機
    ↓ (並列実行)
    |→ [GitHub Issue 作成] ← Promise.all() で待機
    |→ [Git 自動コミット] ← Promise.all() で待機
    ↓
[すべての処理完了を確認]
    ↓
[コマンド終了]
```

### 修正設計

#### 修正案 1: Two-Phase Commit パターンの採用

**実装方針:**

1. Phase 1: 準備フェーズ
   - 仕様書ファイルを一時ディレクトリに生成
   - `fsync()` でファイルを物理書き込み
   - DB レコードを作成（status = 'pending'）

2. Phase 2: コミットフェーズ
   - 一時ファイルを正式なディレクトリに移動（`fs.renameSync()` は POSIX でアトミック）
   - ディレクトリの `fsync()` 実行
   - DB レコードの status を 'active' に更新

3. エラーハンドリング
   - Phase 1 で失敗: 一時ファイル削除、DB レコード削除
   - Phase 2 で失敗: 一時ファイル削除、DB レコードロールバック

**メリット:**

- ファイル作成と DB 記録の一貫性を保証
- 中断時のロールバックが確実

**デメリット:**

- 実装が複雑化
- 一時ファイルの管理が必要

#### 修正案 2: トランザクション拡張 + fsync()

**実装方針:**

1. トランザクション範囲の拡張
   - ファイル生成をトランザクション内に含める
   - ただし、SQLite トランザクションはファイルシステムを制御しないため、疑似的な実装

2. ファイル書き込み後の同期処理
   - `fs.writeFileSync()` 後に `fs.fsyncSync()` を呼び出す
   - 親ディレクトリの `fsync()` も実行（POSIX セマンティクス）

3. イベント発火の同期化
   - `await eventBus.emit()` で非同期ハンドラーの完了を待機
   - Promise.all() で GitHub Issue 作成、Git コミットの完了を保証

**メリット:**

- 実装が比較的シンプル
- 既存のコードベースへの影響が小さい

**デメリット:**

- 完全なアトミック性は保証されない（ファイルシステムと DB が別管理）

#### 修正案 3: 整合性チェックロジックの改善

**実装方針:**

1. ファイル存在確認のリトライ機構
   - `fs.existsSync()` で失敗した場合、100ms 後にリトライ（最大 3 回）
   - バッファリング遅延による誤検知を防ぐ

2. 整合性チェックのタイミング変更
   - コマンド実行直後ではなく、一定時間後（1 秒後）に実行
   - ファイルシステムの同期完了を待つ

**メリット:**

- 誤検知を大幅に削減できる
- 既存のコードベースへの影響が最小

**デメリット:**

- 根本的な解決にはならない（遅延により問題を隠蔽）

### 推奨修正案

**修正案 2（トランザクション拡張 + fsync()）** を推奨します。

**理由:**

1. 実装の現実性: 既存のコードベースへの影響が小さく、段階的な修正が可能
2. 効果の高さ: ファイル書き込みの保証と非同期処理の完了待機により、主要な原因をカバー
3. 保守性: Two-Phase Commit より実装がシンプルで、将来的なメンテナンスが容易

### API 設計

#### 修正対象ファイルと関数

**1. `src/commands/spec/create.ts`**

現状の処理順序。

```typescript
// 1. DB レコード作成
const specId = await db.insertInto('specs').values({...}).execute();

// 2. ファイル生成
fs.writeFileSync(specFilePath, specContent);

// 3. イベント発火
eventBus.emit('spec.created', specId);
```

修正後の処理順序。

```typescript
try {
  // 1. DB レコード作成
  const specId = await db.insertInto('specs').values({...}).execute();

  // 2. ファイル生成 + fsync()
  fs.writeFileSync(specFilePath, specContent);
  const fd = fs.openSync(specFilePath, 'r');
  fs.fsyncSync(fd);
  fs.closeSync(fd);

  // 3. ディレクトリ fsync()
  const dirFd = fs.openSync(path.dirname(specFilePath), 'r');
  fs.fsyncSync(dirFd);
  fs.closeSync(dirFd);

  // 4. イベント発火（非同期処理の完了を待機）
  const eventBus = await getEventBusAsync();
  await eventBus.emit('spec.created', specId);

  return specId;
} catch (error) {
  // エラー時はDB レコードを削除
  await db.deleteFrom('specs').where('id', '=', specId).execute();
  throw error;
}
```

**2. `src/core/workflow/event-bus.ts`**

現状の emit 実装。

```typescript
emit(event: AppEvent): void {
  this.eventEmitter.emit(event.type, event);
}
```

修正後の emit 実装。

```typescript
async emit(event: AppEvent): Promise<void> {
  const handlers = this.eventEmitter.listeners(event.type);
  await Promise.all(
    handlers.map(handler => Promise.resolve(handler(event)))
  );
}
```

**3. `src/core/database/integrity.ts`**

現状の整合性チェック。

```typescript
function checkDatabaseIntegrity(): IntegrityResult {
  const specs = db.selectFrom('specs').selectAll().execute();
  const invalidSpecs = specs.filter(spec => !fs.existsSync(spec.file_path));
  return { invalidSpecs };
}
```

修正後の整合性チェック（リトライ機構付き）。

```typescript
function checkDatabaseIntegrity(): IntegrityResult {
  const specs = db.selectFrom('specs').selectAll().execute();
  const invalidSpecs = specs.filter(spec => {
    // リトライ機構（最大 3 回、100ms 間隔）
    for (let i = 0; i < 3; i++) {
      if (fs.existsSync(spec.file_path)) {
        return false; // ファイル存在
      }
      if (i < 2) {
        // 最後の試行では待機しない
        sleep(100);
      }
    }
    return true; // ファイル不在
  });
  return { invalidSpecs };
}
```

### データベース設計

スキーマ変更は不要です。既存の `specs` テーブルをそのまま使用します。

### セキュリティ設計

1. ファイルパスのサニタイゼーション
   - 仕様書ファイルパスがディレクトリトラバーサル攻撃に対して安全であることを確認
   - `path.resolve()` で正規化されたパスを使用

2. トランザクション中の例外処理
   - すべてのエラーを適切にキャッチし、ロールバック処理を実行
   - センシティブ情報（ファイルパス、spec_id）をエラーログに含めない

### パフォーマンス設計

1. fsync() のオーバーヘッド
   - `fsync()` は同期処理のため、パフォーマンスに影響する可能性
   - ベンチマークテストで測定: 平均実行時間の差が 10%以内であることを確認

2. イベント待機のタイムアウト
   - `await eventBus.emit()` に 5 秒のタイムアウトを設定
   - タイムアウト時はエラーログを出力し、処理を継続

3. 整合性チェックのリトライ間隔
   - リトライ間隔を 100ms に設定（短すぎると CPU 負荷、長すぎると応答時間低下）
   - 最大 3 回のリトライで 300ms の遅延（許容範囲）

---

## 11. 実装タスクリスト

### Phase 1: 原因特定と分析

- [ ] **不整合の再現テストと原因特定**
  - 仕様書作成処理を 10 回連続実行し、不整合の発生パターンを記録
  - Claude Code 再起動後の整合性チェック結果を記録
  - 再現率 80%以上を達成し、再現手順を文書化

- [ ] **整合性チェック処理のコードレビュー**
  - `src/core/database/integrity.ts` の `checkDatabaseIntegrity()` 関数を精査
  - ファイル存在確認のタイミングと判定ロジックを分析
  - 問題点を特定し、文書化

- [ ] **仕様書作成処理のトランザクション範囲確認**
  - `src/commands/spec/create.ts` の処理順序を分析
  - トランザクション境界を確認（DB 記録、ファイル生成、イベント発火）
  - トランザクション外で実行されている処理を特定

### Phase 2: 修正実装

- [ ] **ファイル書き込み後の fsync() 実装**
  - `src/commands/spec/create.ts` にファイル fsync() 処理を追加
  - ディレクトリ fsync() 処理を追加（POSIX セマンティクス）
  - エラーハンドリングを実装

- [ ] **イベントバスの非同期待機機構実装**
  - `src/core/workflow/event-bus.ts` の `emit()` を非同期化
  - Promise.all() でハンドラーの完了を待機
  - タイムアウト処理（5 秒）を実装

- [ ] **整合性チェックのリトライ機構実装**
  - `src/core/database/integrity.ts` にリトライ機構を追加（最大 3 回、100ms 間隔）
  - リトライ失敗時のエラーログ出力
  - リトライ成功時のデバッグログ出力

- [ ] **エラーハンドリングとロールバック処理の強化**
  - `src/commands/spec/create.ts` の try-catch ブロックを強化
  - DB レコード削除のロールバック処理を実装
  - エラー時のクリーンアップ処理を実装

### Phase 3: テストと検証

- [ ] **単体テストの追加（カバレッジ 100%）**
  - `tests/core/database/integrity.test.ts` を作成（整合性チェックロジック）
  - `tests/commands/spec/create.test.ts` を作成（仕様書作成処理）
  - `tests/core/workflow/event-bus.test.ts` を作成（イベントバス）
  - トランザクション中断のシミュレーションテスト

- [ ] **E2E テストの追加（100 回連続実行で 0 件）**
  - Claude Code 再起動シミュレーションテスト
  - 複数インスタンス同時起動テスト（競合状態の検証）
  - 不整合検出から修復までのフローテスト

- [ ] **ベンチマークスクリプトの作成とパフォーマンス検証**
  - 仕様書作成処理のベンチマークスクリプト作成（100 回実行）
  - 整合性チェック処理のベンチマークスクリプト作成（100 回実行）
  - 修正前後で平均実行時間の差が 10%以内であることを確認

- [ ] **検証スクリプトの作成（Claude Code 再起動 50 回）**
  - 自動再起動スクリプトの作成
  - 整合性チェック結果の自動記録
  - 不整合発生件数の集計レポート

### Phase 4: ドキュメント更新

- [ ] **CLAUDE.md のトラブルシューティング項目更新**
  - データベース不整合の原因と解決策を追加
  - 再発防止のベストプラクティスを追加
  - リトライ機構の動作説明を追加
