# 定期的にデータベース不整合となる根本原因の追究

**仕様書 ID:** f1341d15-df2f-48c7-8bbd-ec7fa043749f
**フェーズ:** design
**作成日時:** 2025/11/20 8:20:04
**更新日時:** 2025/11/20 8:27:18

---

## 1. 背景と目的

### 背景

Claude Code を再起動するたびにデータベース不整合が発生しています。
/cft:create-spec 時に以下のエラーが頻繁に報告されます。

```text
⚠️  Database integrity warnings:
      - Found 1 database record(s) with invalid spec file
```

また、今回は、/cft:status で以下の報告が挙がってきています。

```text
データベース整合性の警告

  ⚠️ データベースに以下の問題が検出されました。
  - 無効な仕様書ファイル: 1 件
  - 無効な仕様書ファイルへの参照レコード: 1 件
```

これは由々しき事態です。早急な解決が望まれます。

### 目的

データベース不整合の根本原因を特定し、恒久的な解決策を実装することで、開発者体験を向上させる。

---

## 2. 対象ユーザー

- cc-craft-kit の開発者
- cc-craft-kit を利用するすべてのユーザー

---

## 3. 受け入れ基準

### 必須要件

- [ ] データベース不整合が発生する具体的なタイミングと条件を特定し、再現手順を文書化する
  - 再現率: 10 回中 8 回以上の頻度で再現できること
  - 再現環境: OS、Claude Code バージョン、データベースサイズを明記
- [ ] 不整合の根本原因を技術的に解明し、原因コードの特定とコードレビューを完了する
  - 根本原因の技術的説明を文書化（ファイルパス、行番号、処理フロー図を含む）
- [ ] 根本原因を解決する恒久的な修正を実装する
  - 単体テストで修正箇所のカバレッジ 100%を達成
  - E2E テストで不整合が発生しないことを検証（100 回連続実行で 0 件）
- [ ] 修正後、Claude Code 再起動を 50 回実行し、不整合が 0 件であることを検証する
  - 検証スクリプトを作成し、自動化すること

### 機能要件

- [ ] データベース整合性チェック機能の動作を詳細に分析する
  - `src/core/database/integrity.ts` の `checkDatabaseIntegrity()` 関数を精査
  - ファイル存在確認の `fs.existsSync()` のタイミングを検証
- [ ] 仕様書作成時のファイル生成・データベース記録処理のトランザクション性を検証する
  - `src/commands/spec/create.ts` の処理順序を分析
  - Kysely トランザクション（`db.transaction()`）の使用状況を確認
  - ファイル書き込み後の `fsync()` 呼び出し有無を確認
- [ ] 複数の Claude Code インスタンス同時起動時の競合状態を調査する
  - 複数インスタンス同時起動テスト（競合状態の検証）
- [ ] WAL モード + busy_timeout の動作を検証する
  - データベース接続ログ（WAL モード、トランザクション開始/終了）を収集
- [ ] 仕様書ファイル削除時のデータベースレコード削除処理を確認する
  - 部分的な成功状態（ファイル作成済み、DB 未記録）の検出

### 非機能要件

- [ ] 修正により既存の仕様書データが失われないこと
  - データベースバックアップを事前に取得
  - 全仕様書ファイル（60 件）のハッシュ値を記録し、修正後に照合
- [ ] パフォーマンスが劣化しないこと
  - 仕様書の作成処理: 修正前後で平均実行時間の差が 10%以内
  - 整合性チェック処理: 修正前後で平均実行時間の差が 10%以内
  - ベンチマークスクリプトを作成し、100 回実行の平均値を比較
- [ ] データベースバックアップ機能が正常に動作すること
  - バックアップファイルが生成されること（`.cc-craft-kit/backups/`）
  - バックアップからの復元が成功すること（テストケース追加）

---

## 4. 制約条件

- 既存の仕様書データ（60 件）を保持すること
  - マイグレーション実行時にデータ損失が発生しないこと
  - ロールバック手順を文書化すること
- データベーススキーマの大幅な変更は避けること
  - 許容される変更: インデックス追加、カラムのデフォルト値変更
  - 非許容の変更: テーブル削除、カラム削除、NOT NULL 制約の追加
  - スキーマ変更が必要な場合はマイグレーションファイルを作成
- GitHub Issue 連携機能に影響を与えないこと
  - `github_sync` テーブルのレコードが保持されること
  - Issue 同期処理（`src/integrations/github/sync.ts`）が正常動作すること
  - E2E テストで Issue 作成・更新を検証
- データベース接続の安全性を維持すること
  - `getDatabase()` の使用パターンを変更しないこと
  - WAL モード + busy_timeout の設定を保持すること

---

## 5. 依存関係

### 関連ファイル

- `src/core/database/connection.ts` - データベース接続管理
  - 調査重点: `createDatabase()` の初期化処理、WAL モード設定
- `src/core/database/integrity.ts` - 整合性チェック機能
  - 調査重点: `checkDatabaseIntegrity()` の判定ロジック、ファイル存在確認のタイミング
- `src/commands/spec/create.ts` - 仕様書の作成処理
  - 調査重点: ファイル作成と DB 記録の順序、トランザクション範囲、エラーハンドリング
- `src/commands/status.ts` - 状態確認処理
  - 調査重点: 整合性チェック実行タイミング、警告表示のロジック
- `src/core/workflow/event-bus.ts` - イベント駆動処理
  - 調査重点: spec.created イベントのハンドラー登録、非同期処理の完了待機
- `src/core/workflow/git-integration.ts` - Git 自動コミット処理
  - 調査重点: コミット実行タイミング、ファイル状態変更の有無

### 調査観点

1. **整合性チェックのロジック**: どのような条件で「無効」と判定されるか
   - `src/core/database/integrity.ts` の `checkDatabaseIntegrity()` 関数を精査
   - ファイル存在確認の `fs.existsSync()` のタイミングを検証
2. **ファイル作成とDB記録の順序**: アトミック性が保証されているか
   - `src/commands/spec/create.ts` の処理順序を分析
   - Kysely トランザクション（`db.transaction()`）の使用状況を確認
   - ファイル書き込み後の `fsync()` 呼び出し有無を確認
3. **イベント駆動処理の副作用**: spec.created イベントでの非同期処理が影響しているか
   - イベントハンドラーの `await` 処理を確認
   - Promise.all() の使用箇所でエラーハンドリングを検証
4. **Git 自動コミット処理**: フェーズ変更時のコミット処理がファイル状態に影響していないか
   - `src/core/workflow/git-integration.ts` のコミットタイミングを分析
   - Git インデックスとワーキングツリーの状態を調査
5. **Claude Code 再起動時の挙動**: プロセス終了時の未完了処理がないか
   - SIGINT/SIGTERM ハンドラーの実装を確認
   - `process.on('exit')` でのクリーンアップ処理を検証
6. **データベーススキーマのトランザクション設計**: ACID 特性が保証されているか
   - SQLite の WAL モード設定を確認
   - トランザクション分離レベルを検証
7. **ファイルシステムの書き込み順序保証**: OS レベルの同期処理が適切か
   - ファイル書き込み後の `fs.fsync()` 呼び出し有無
   - ディレクトリの `fsync()` 呼び出し有無（POSIX セマンティクス）
8. **エラーハンドリングの動作**: 例外発生時のロールバック処理
   - try-catch ブロックでのトランザクションロールバック確認
   - 部分的な成功状態（ファイル作成済み、DB 未記録）の検出

---

## 6. 参考情報

### 観察された現象

- 仕様書の作成直後に不整合カウントが増加（1 件→2 件）
  - 発生日時: 2025/11/20 8:20:04
  - 仕様書 ID: f1341d15-df2f-48c7-8bbd-ec7fa043749f
  - 実行コマンド: `/cft:spec-create`
- Claude Code 再起動時に不整合の報告される頻度が高い
  - 過去の再起動で頻繁に不整合を検出
  - 最終起動: 2025/11/20
- `/cft:status` 実行時に常に同じ警告が表示される
  - 無効な仕様書ファイル: 1 件（同一の spec_id が継続的に報告される可能性）
  - 無効な仕様書ファイルへの参照レコード: 1〜2 件

### CLAUDE.md の関連セクション

- データベース接続の安全性（getDatabase() の使用）
- バックアップ機能（週 1 回自動バックアップ）
- 複数 Claude Code インスタンスでの使用（WAL モード + busy_timeout）

### 想定される原因候補（優先度順）

#### 優先度 High

1. **トランザクション未完了** (可能性: 80%)
   - 理由: ファイル作成と DB 記録が別処理のため、中断時に不整合が発生しやすい
   - 検証方法: `src/commands/spec/create.ts` のトランザクション範囲を確認
   - 修正案: ファイル作成をトランザクション内に含める、または Two-Phase Commit パターンを採用

2. **ファイルシステムとDBの同期タイミング** (可能性: 60%)
   - 理由: ファイル書き込みはバッファリングされるため、DB 記録時点で物理書き込み未完了の可能性
   - 検証方法: `fs.writeFileSync()` 使用箇所を確認、`fsync()` 呼び出し有無を検証
   - 修正案: ファイル書き込み後に明示的な `fsync()` を呼び出す

#### 優先度 Medium

1. **イベントハンドラーの副作用** (可能性: 40%)
   - 理由: spec.created イベントの非同期処理が完了前にプロセス終了の可能性
   - 検証方法: `src/core/workflow/event-bus.ts` のイベントハンドラー登録を確認
   - 修正案: イベント発火を同期的に待機、または処理完了を保証するキュー機構導入

2. **Git 自動コミット処理の影響** (可能性: 30%)
   - 理由: コミット処理中にファイルが一時的に移動・変更される可能性
   - 検証方法: `src/core/workflow/git-integration.ts` のコミット処理を分析
   - 修正案: コミット処理をロック機構で保護

#### 優先度 Low

1. **整合性チェックロジックのバグ** (可能性: 20%)
   - 理由: タイミング依存の誤検知の可能性
   - 検証方法: `src/core/database/integrity.ts` のロジックをコードレビュー
   - 修正案: ファイル存在確認にリトライ機構を追加

---

## 7. テスト戦略

### 単体テスト

- 整合性チェックロジックのテスト（`tests/core/database/integrity.test.ts`）
- 仕様書の作成処理のテスト（`tests/commands/spec/create.test.ts`）
- トランザクション処理のテスト（モック環境で中断をシミュレート）

### 統合テスト

- ファイル作成と DB 記録の一貫性テスト
- イベントハンドラーの完了待機テスト
- Git 自動コミット処理の影響テスト

### E2Eテスト

- Claude Code 再起動シミュレーション（50 回連続実行）
- 複数インスタンス同時起動テスト（競合状態の検証）
- 不整合検出から修復までのフローテスト

---

## 8. ログ収集計画

### デバッグログの有効化

- `LOG_LEVEL=debug` で詳細ログを出力
- ファイル作成、DB 記録、イベント発火のタイムスタンプを記録

### 収集対象ログ

- データベース接続ログ（WAL モード、トランザクション開始/終了）
- ファイルシステム操作ログ（writeFileSync、fsync 呼び出し）
- イベントバスログ（イベント発火、ハンドラー実行開始/終了）
- Git 操作ログ（コミット実行、ファイル追加）

### ログ分析ツール

- タイムスタンプベースの処理フロー可視化
- 不整合発生時のログパターン抽出

---

## 9. 修正アプローチ

### Phase 1: 原因の特定

1. 詳細ログの収集（デバッグモードでの再現テスト）
2. コードレビュー（トランザクション範囲、ファイル書き込み順序）
3. 原因の絞り込み（優先度順に検証）

### Phase 2: 暫定対策の実装

1. 高優先度の原因に対する暫定修正
2. 単体テストの追加
3. 動作検証（10 回の再起動テスト）

### Phase 3: 恒久対策の実装

1. 根本的な修正の実装
2. E2E テストの追加
3. 最終検証（50 回の再起動テスト）

### Phase 4: ドキュメント更新

1. CLAUDE.md の更新（トラブルシューティング項目追加）
2. アーキテクチャドキュメントの更新
3. 修正内容のナレッジベース化
