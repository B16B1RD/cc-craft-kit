---
id: "9ce6378b-c19d-40ef-a289-747d948e84cf"
name: "/cft:spec-create で GitHub Issue が自動作成されない"
phase: "completed"
branch_name: "main"
github_issue_number: null
pr_url: null
created_at: "2025-11-19T12:33:15Z"
updated_at: "2025-11-19T13:09:26Z"
---

# /cft:spec-create で GitHub Issue が自動作成されない


## 1. 背景と目的

### 背景

現在、`/cft:spec-create` で仕様書を作成すると GitHub Issue は自動作成される実装になっているが、実際には以下の問題が発生している。

1. **Issue 作成漏れの発生**: 何らかの理由（GitHub トークン未設定、API エラー、ネットワーク障害など）で Issue 作成が失敗し、仕様書のみが存在する状態が発生する
2. **過去の仕様書の Issue 未作成**: GitHub 統合機能が実装される前に作成された仕様書には、Issue が紐づいていない
3. **手動リカバリーの負担**: 現在は Issue 作成漏れを発見した場合、手動で `/cft:github-issue-create` を実行する必要がある
4. **リカバリー忘れのリスク**: フェーズが進んでから Issue が未作成であることに気づき、管理が複雑になる

### 目的

**ユーザーの介入なしに、自動的に Issue 作成漏れを検出・修復する仕組みを構築する。**

1. **各種コマンド実行時の自動チェック**: `/cft:spec-phase`, `/cft:spec-get`, `/cft:status` などの実行時に Issue の存在を確認
2. **Issue 未作成の自動検出**: `github_sync` テーブルを参照し、Issue が紐づいていない仕様書を検出
3. **自動リカバリー実行**: Issue 未作成を検出した時点で、ユーザーへの確認なしに自動的に Issue を作成
4. **リカバリーログの記録**: 自動リカバリーが実行されたことをログに記録し、透明性を確保する
---

## 2. 対象ユーザー

- cc-craft-kit を使用する開発者（仕様書作成・管理を行うユーザー）
- GitHub Issues と GitHub Projects を使用してプロジェクト管理を行うチーム
---

## 3. 受け入れ基準

### 必須要件（自動リカバリー機能）

- [ ] `/cft:spec-phase` 実行時に、対象仕様書の GitHub Issue 存在チェックが自動実行される
- [ ] `/cft:spec-get` 実行時に、対象仕様書の GitHub Issue 存在チェックが自動実行される
- [ ] `/cft:status` 実行時に、Issue 未作成の仕様書数が表示される
- [ ] Issue 未作成を検出した時点で、ユーザーへの確認なしに自動的に Issue を作成する
- [ ] 自動作成された Issue が GitHub Project に自動追加される

### 機能要件（自動チェック・リカバリー）

- [ ] `ensureGitHubIssue(specId)` ヘルパー関数を実装する
  - `github_sync` テーブルで Issue の存在を確認
  - Issue が存在しない場合、自動的に Issue を作成
  - Issue を GitHub Project に自動追加
  - リカバリー実行ログを記録
- [ ] `/cft:spec-phase` コマンドで `ensureGitHubIssue` を呼び出す
- [ ] `/cft:spec-get` コマンドで `ensureGitHubIssue` を呼び出す
- [ ] `/cft:status` コマンドで Issue 未作成の仕様書を集計・表示する
- [ ] バックグラウンドで一括チェック・リカバリーを実行する機能を提供する（オプション）

### 非機能要件

- [ ] 自動リカバリーは非同期で実行し、コマンドのレスポンスを遅延させない
- [ ] リカバリー実行中はログに「Auto-recovering GitHub Issue for spec <spec-id>...」と表示
- [ ] リカバリー成功時は「✓ GitHub Issue created automatically: #<issue-number>」と表示
- [ ] リカバリー失敗時はエラーログを記録し、手動作成を案内する
- [ ] GitHub API のレート制限を考慮し、過度なリクエストを避ける
- [ ] 既存の仕様書作成フローに影響を与えない
---

## 4. 制約条件

- GitHub API のレート制限: REST API 5,000 リクエスト/時、GraphQL API 5,000 ポイント/時
- GitHub トークンのスコープ: `repo`, `project` が必要
- GitHub Project は Projects v2 を使用（GraphQL API 経由）
- 既存の `spec.created` イベントハンドラーに影響を与えない設計とする
---

## 5. 依存関係

### 依存コンポーネント

- `src/core/workflow/event-bus.ts` - イベント駆動アーキテクチャ
- `src/integrations/github/sync.ts` - GitHub 同期ロジック
- `src/integrations/github/api.ts` - GitHub API クライアント
- `src/core/database/schema.ts` - `github_sync` テーブル

### 依存する仕様書

- Git 自動コミット機能（イベント駆動の実装パターンを参考）
- GitHub Projects 統合（既存の Projects API 実装を活用）
---

## 6. 参考情報

### GitHub API ドキュメント

- [Create an issue - GitHub REST API](https://docs.github.com/en/rest/issues/issues#create-an-issue)
- [Add an item to a project - GitHub GraphQL API](https://docs.github.com/en/graphql/reference/mutations#addprojectv2itembyid)
- [Best practices for using the REST API](https://docs.github.com/en/rest/using-the-rest-api/best-practices-for-using-the-rest-api)

### 既存実装

- `src/core/workflow/github-integration.ts` - `spec.created` イベントハンドラー（自動 Issue 作成）
- `src/integrations/github/issues.ts` - GitHub Issues API クライアント
- `src/integrations/github/projects.ts` - GitHub Projects API クライアント
- `src/integrations/github/sync.ts` - GitHub 同期ロジック
---

## 7. 実装対象コンポーネント

### 新規作成ファイル

- `src/integrations/github/ensure-issue.ts` - `ensureGitHubIssue` ヘルパー関数の実装

### 修正ファイル

- `src/commands/spec/phase.ts` - `ensureGitHubIssue` の呼び出しを追加
- `src/commands/spec/get.ts` - `ensureGitHubIssue` の呼び出しを追加
- `src/commands/status.ts` - Issue 未作成の仕様書数の集計・表示を追加

### テストファイル

- `tests/integrations/github/ensure-issue.test.ts` - `ensureGitHubIssue` のユニットテスト
- `tests/commands/spec/phase.test.ts` - 自動リカバリー機能の統合テスト
---

## 9. 設計

### 9.1 アーキテクチャ概要

自動リカバリー機能は、**既存の GitHub 統合機能を再利用**し、各コマンドから呼び出せるヘルパー関数として実装します。

```
┌─────────────────────────────────────┐
│  Commands                           │
│  - /cft:spec-phase                  │
│  - /cft:spec-get                    │
│  - /cft:status                      │
└──────────┬──────────────────────────┘
           │ 呼び出し
           ↓
┌─────────────────────────────────────┐
│  ensureGitHubIssue(specId)          │
│  - Issue 存在チェック               │
│  - 自動作成 + Project 追加          │
│  - ログ記録                         │
└──────────┬──────────────────────────┘
           │ 再利用
           ↓
┌─────────────────────────────────────┐
│  既存 GitHub 統合                   │
│  - GitHubIssues                     │
│  - GitHubProjects                   │
│  - GitHubSyncService                │
└─────────────────────────────────────┘
```

### 9.2 データフロー

#### 9.2.1 Issue 存在チェック

```typescript
// 1. github_sync テーブルで Issue の存在確認
const sync = await db
  .selectFrom('github_sync')
  .where('entity_id', '=', specId)
  .where('entity_type', '=', 'spec')
  .selectAll()
  .executeTakeFirst();

// 2. sync.github_issue_id が null または sync が存在しない場合、Issue 未作成と判定
const hasIssue = sync?.github_issue_id != null;
```

#### 9.2.2 自動リカバリー実行

```typescript
// 1. Issue 未作成の場合、GitHubSyncService を使用して作成
if (!hasIssue) {
  console.log(`ℹ Auto-recovering GitHub Issue for spec ${specId}...`);

  const issueNumber = await syncService.syncSpecToIssue({
    specId,
    owner: githubConfig.owner,
    repo: githubConfig.repo,
    createIfNotExists: true,
  });

  // 2. GitHub Project に追加
  await addToProject(issueNumber);

  console.log(`✓ GitHub Issue created automatically: #${issueNumber}`);
}
```

### 9.3 API 設計

#### 9.3.1 `ensureGitHubIssue` 関数

**ファイル**: `src/integrations/github/ensure-issue.ts`

```typescript
/**
 * 仕様書に対応する GitHub Issue が存在するか確認し、
 * 存在しない場合は自動的に作成する
 */
export async function ensureGitHubIssue(
  db: Kysely<Database>,
  specId: string
): Promise<{
  issueNumber: number | null;
  wasCreated: boolean;
}> {
  // 1. GitHub 設定チェック
  const githubToken = process.env.GITHUB_TOKEN;
  if (!githubToken) {
    return { issueNumber: null, wasCreated: false };
  }

  const githubConfig = getGitHubConfig();
  if (!githubConfig) {
    return { issueNumber: null, wasCreated: false };
  }

  // 2. Issue 存在チェック
  const sync = await db
    .selectFrom('github_sync')
    .where('entity_id', '=', specId)
    .where('entity_type', '=', 'spec')
    .selectAll()
    .executeTakeFirst();

  if (sync?.github_issue_id) {
    // 既に Issue が存在する場合は何もしない
    return { issueNumber: sync.github_issue_id, wasCreated: false };
  }

  // 3. Issue 自動作成
  console.log(`ℹ Auto-recovering GitHub Issue for spec ${specId}...`);

  try {
    const syncService = new GitHubSyncService(db, issues, projects);
    const issueNumber = await syncService.syncSpecToIssue({
      specId,
      owner: githubConfig.owner,
      repo: githubConfig.repo,
      createIfNotExists: true,
    });

    // 4. GitHub Project に追加
    await addToProject(specId, issueNumber);

    console.log(`✓ GitHub Issue created automatically: #${issueNumber}`);

    return { issueNumber, wasCreated: true };
  } catch (error) {
    console.error(`✗ Failed to auto-create GitHub Issue for spec ${specId}:`, error);
    console.log(`  Manual creation: /cft:github-issue-create ${specId}`);
    return { issueNumber: null, wasCreated: false };
  }
}
```

#### 9.3.2 各コマンドからの呼び出し

**`src/commands/spec/phase.ts`**

```typescript
// フェーズ更新前に Issue 存在チェック + 自動作成
const { issueNumber, wasCreated } = await ensureGitHubIssue(db, specId);

if (wasCreated) {
  // リカバリー実行ログを記録
  await db.insertInto('logs').values({
    level: 'info',
    message: `Auto-recovered GitHub Issue #${issueNumber} for spec ${specId}`,
    context: JSON.stringify({ specId, issueNumber }),
  }).execute();
}

// フェーズ更新処理を続行
await updatePhase(specId, newPhase);
```

**`src/commands/spec/get.ts`**

```typescript
// 仕様書取得時に Issue 存在チェック + 自動作成
await ensureGitHubIssue(db, specId);

// 仕様書表示処理を続行
const spec = await getSpec(specId);
console.log(spec);
```

**`src/commands/status.ts`**

```typescript
// Issue 未作成の仕様書を集計
const specsWithoutIssue = await db
  .selectFrom('specs')
  .leftJoin('github_sync', (join) =>
    join
      .onRef('specs.id', '=', 'github_sync.entity_id')
      .on('github_sync.entity_type', '=', 'spec')
  )
  .where((eb) =>
    eb.or([
      eb('github_sync.github_issue_id', 'is', null),
      eb('github_sync.id', 'is', null),
    ])
  )
  .select(['specs.id', 'specs.name', 'specs.phase'])
  .execute();

console.log(`\nIssue 未作成の仕様書: ${specsWithoutIssue.length} 件`);

if (specsWithoutIssue.length > 0) {
  console.log('  次回コマンド実行時に自動作成されます');
}
```

### 9.4 データベーススキーマ

既存の `github_sync` テーブルを活用します。

```sql
CREATE TABLE github_sync (
  id TEXT PRIMARY KEY,
  entity_type TEXT NOT NULL,  -- 'spec' | 'task' | 'issue' | 'project' | 'sub_issue'
  entity_id TEXT NOT NULL,    -- 仕様書 ID
  github_issue_id INTEGER,    -- GitHub Issue 番号
  github_project_id TEXT,
  github_project_item_id TEXT,
  synced_at TEXT NOT NULL,
  created_at TEXT NOT NULL
);
```

**Issue 存在判定クエリ:**

```sql
SELECT github_issue_id
FROM github_sync
WHERE entity_type = 'spec' AND entity_id = ?;
```

### 9.5 エラーハンドリング

#### 9.5.1 GitHub トークン未設定

```typescript
if (!githubToken) {
  // 警告を表示せず、静かにスキップ
  return { issueNumber: null, wasCreated: false };
}
```

#### 9.5.2 GitHub API エラー

```typescript
try {
  const issueNumber = await syncService.syncSpecToIssue(...);
  return { issueNumber, wasCreated: true };
} catch (error) {
  // エラーログを記録し、手動作成を案内
  console.error(`✗ Failed to auto-create GitHub Issue for spec ${specId}:`, error);
  console.log(`  Manual creation: /cft:github-issue-create ${specId}`);

  await db.insertInto('logs').values({
    level: 'error',
    message: `Failed to auto-create GitHub Issue for spec ${specId}`,
    context: JSON.stringify({ specId, error: String(error) }),
  }).execute();

  return { issueNumber: null, wasCreated: false };
}
```

#### 9.5.3 レート制限

```typescript
// GitHub API クライアントで既に実装済み
// レート制限に達した場合は RateLimitError をスロー
// ensureGitHubIssue では catch してログ記録 + 手動作成案内
```

### 9.6 パフォーマンス最適化

#### 9.6.1 非同期実行

```typescript
// コマンドのレスポンスを遅延させないため、非同期で実行
ensureGitHubIssue(db, specId).catch((error) => {
  console.error('Auto-recovery failed:', error);
});

// コマンド処理を続行
await updatePhase(specId, newPhase);
```

#### 9.6.2 キャッシング（オプション）

```typescript
// 同一セッション内で重複チェックを避けるため、メモリキャッシュを使用
const checkedSpecs = new Set<string>();

if (checkedSpecs.has(specId)) {
  return; // 既にチェック済み
}

await ensureGitHubIssue(db, specId);
checkedSpecs.add(specId);
```
---

## 8. テスト戦略

### ユニットテスト

- [ ] `ensureGitHubIssue` 関数のユニットテスト
  - Issue が既に存在する場合、何もしない
  - Issue が存在しない場合、自動的に Issue を作成する
  - Issue 作成後、GitHub Project に自動追加される
  - GitHub API エラー時に適切にハンドリングされる
  - `github_sync` テーブルに同期ログが記録される

### 統合テスト

- [ ] `/cft:spec-phase` での自動リカバリー
  - Issue 未作成の仕様書に対してフェーズ変更を実行
  - 自動的に Issue が作成されることを確認
  - フェーズ変更が正常に完了することを確認
- [ ] `/cft:spec-get` での自動リカバリー
  - Issue 未作成の仕様書を取得
  - 自動的に Issue が作成されることを確認
- [ ] `/cft:status` での集計表示
  - Issue 未作成の仕様書が正しくカウントされることを確認

### E2Eテスト

- [ ] 仕様書作成 → Issue 自動作成失敗 → フェーズ変更で自動リカバリー
  1. GitHub トークンを一時的に無効化
  2. `/cft:spec-create` で仕様書を作成（Issue 作成失敗）
  3. GitHub トークンを復元
  4. `/cft:spec-phase` でフェーズ変更（自動リカバリーが実行される）
  5. Issue が正常に作成されることを確認
---

## 10. 実装タスクリスト

### フェーズ 1: コア機能実装

#### タスク 1: `ensureGitHubIssue` ヘルパー関数を実装する

**ファイル**: `src/integrations/github/ensure-issue.ts`

**実装内容**:
- GitHub 設定チェック（トークン、owner/repo）
- `github_sync` テーブルで Issue 存在確認
- Issue 未作成の場合、`GitHubSyncService.syncSpecToIssue` を呼び出し
- GitHub Project への自動追加
- リカバリーログの記録
- エラーハンドリング（トークン未設定、API エラー、レート制限）

**受け入れ基準**:
- [ ] GitHub トークン未設定時は静かにスキップ
- [ ] Issue が既に存在する場合は何もしない
- [ ] Issue 未作成時は自動的に Issue を作成
- [ ] 作成した Issue を GitHub Project に追加
- [ ] リカバリー実行ログを記録
- [ ] エラー時は手動作成を案内

**依存関係**: なし
---

#### タスク 2: `/cft:spec-phase` コマンドに `ensureGitHubIssue` の呼び出しを追加

**ファイル**: `src/commands/spec/phase.ts`

**実装内容**:
- フェーズ更新前に `ensureGitHubIssue(db, specId)` を呼び出し
- `wasCreated` が true の場合、リカバリーログを記録
- フェーズ更新処理を続行

**受け入れ基準**:
- [ ] フェーズ更新前に Issue 存在チェックが実行される
- [ ] Issue 未作成時は自動的に Issue が作成される
- [ ] リカバリー実行ログが記録される
- [ ] フェーズ更新が正常に完了する

**依存関係**: タスク 1
---

#### タスク 3: `/cft:spec-get` コマンドに `ensureGitHubIssue` の呼び出しを追加

**ファイル**: `src/commands/spec/get.ts`

**実装内容**:
- 仕様書取得前に `ensureGitHubIssue(db, specId)` を呼び出し
- 仕様書表示処理を続行

**受け入れ基準**:
- [ ] 仕様書取得時に Issue 存在チェックが実行される
- [ ] Issue 未作成時は自動的に Issue が作成される
- [ ] 仕様書表示が正常に完了する

**依存関係**: タスク 1
---

#### タスク 4: `/cft:status` コマンドに Issue 未作成仕様書の集計・表示機能を追加

**ファイル**: `src/commands/status.ts`

**実装内容**:
- `specs` テーブルと `github_sync` テーブルを LEFT JOIN
- `github_sync.github_issue_id` が null または `github_sync.id` が null の仕様書を集計
- Issue 未作成の仕様書数を表示
- 次回コマンド実行時に自動作成される旨を案内

**受け入れ基準**:
- [ ] Issue 未作成の仕様書が正しくカウントされる
- [ ] 仕様書数が表示される
- [ ] 自動作成の案内メッセージが表示される

**依存関係**: なし
---

### フェーズ 2: テスト実装

#### タスク 5: `ensureGitHubIssue` 関数のユニットテストを作成

**ファイル**: `tests/integrations/github/ensure-issue.test.ts`

**実装内容**:
- GitHub トークン未設定時のテスト
- Issue が既に存在する場合のテスト
- Issue が存在しない場合の自動作成テスト
- GitHub Project への自動追加テスト
- GitHub API エラー時のテスト
- `github_sync` テーブルへの記録テスト

**受け入れ基準**:
- [ ] すべてのテストケースが通過する
- [ ] テストカバレッジが 80% 以上

**依存関係**: タスク 1
---

#### タスク 6: 自動リカバリー機能の統合テストを作成

**ファイル**: `tests/commands/spec/phase.test.ts`

**実装内容**:
- `/cft:spec-phase` での自動リカバリーテスト
- `/cft:spec-get` での自動リカバリーテスト
- `/cft:status` での集計表示テスト
- E2E テスト（Issue 作成失敗 → 自動リカバリー）

**受け入れ基準**:
- [ ] すべてのテストケースが通過する
- [ ] 自動リカバリーが正常に動作することを確認

**依存関係**: タスク 2, タスク 3, タスク 4
---

### 実装順序

1. **タスク 1**: `ensureGitHubIssue` ヘルパー関数の実装（最優先）
2. **タスク 2-4**: 各コマンドへの統合（並行実装可能）
3. **タスク 5-6**: テスト実装（実装完了後）

### 見積もり

- **タスク 1**: 2-3 時間
- **タスク 2**: 30 分
- **タスク 3**: 30 分
- **タスク 4**: 1 時間
- **タスク 5**: 2 時間
- **タスク 6**: 2 時間

**合計**: 約 8-9 時間
