---
description: "新しい仕様書を作成します"
argument-hint: "<spec-name> [description]"
---

# 仕様書作成

新しい仕様書を作成し、Requirements フェーズから開始します。

## 引数

- `$1` (必須): 仕様書名
- `$2` (オプション): 仕様書の説明

## 実行内容

1. データベースに仕様書レコードを作成
2. Requirements フェーズで初期化
3. 仕様書 ID の発行

## 使用例

```bash
/cft:spec-create "ユーザー認証機能" "メール/パスワード認証とOAuth2.0対応"
```

---

## ブランチ名生成

仕様書作成時、以下の手順でブランチ名を生成してください。

1. **仕様書名と説明を分析**
   - ユーザーが指定した仕様書名（`$1`）と説明（`$2`）を確認
   - 仕様書の内容を理解し、適切な英語の説明フレーズを考案

2. **英語ブランチ名の生成規則**
   - 3〜5 単語程度の簡潔な英語フレーズ
   - 小文字のみ使用
   - 単語の区切りはハイフン（`-`）を使用
   - Git 互換文字のみ（英数字、ハイフン、アンダースコア）
   - 最大 40 文字程度（仕様書 ID と組み合わせて 63 文字以内に収める）

3. **ブランチ名の例**
   - 日本語: "ブランチ名が適当な名前になっている" → 英語: "improve-branch-naming"
   - 日本語: "データベース接続エラーを修正" → 英語: "fix-database-connection"
   - 英語: "Add User Authentication" → 英語: "add-user-authentication"

## 自動ブランチ作成の動作（v0.2.0 以降）

保護ブランチ（`main`、`develop`）から仕様書作成時、自動的に `feature/spec-` プレフィックス付きブランチが作成されます。

**ブランチ命名規則:**

| 実行元ブランチ | カスタムブランチ名 | 生成されるブランチ名 |
|---|---|---|
| feature/* | なし | `spec/<短縮ID>` |
| feature/* | あり | `spec/<短縮ID>-<カスタム名>` |
| **develop** | なし | `feature/spec-<短縮ID>` |
| **develop** | あり | `feature/spec-<短縮ID>-<カスタム名>` |
| **main** | なし | `feature/spec-<短縮ID>` |
| **main** | あり | `feature/spec-<短縮ID>-<カスタム名>` |

この機能により、保護ブランチでの直接作業を防ぎつつ、手動でのブランチ作成の手間を削減します。

## ブランチ作成後の動作（v0.3.0 以降）

仕様書作成時にブランチが自動作成されるが、作成後は**元のブランチへ自動的に戻る**。

- ブランチは作成され、データベースへ記録された状態で残る
- 開発者が意図しないブランチで作業するリスクを防止する
- 実装を開始する際は、手動で作成されたブランチへ切り替える

**実装開始時:**

```bash
# 作成されたブランチに切り替え
git checkout feature/spec-910e63ad
```

**注意事項:**

- ブランチ切り替えに失敗した場合、エラーが発生し、仕様書作成が中断される
- エラーメッセージに従って手動でブランチを切り替える
- ブランチ切り替え失敗の主な原因: 未コミット変更、ファイルロック、Git エラー

---

以下のコマンドを実行して仕様書を作成してください。

**重要**: ブランチ名を生成した場合は、`--branch-name` オプションで渡してください。

```bash
# ブランチ名を生成した場合
npx tsx .cc-craft-kit/commands/spec/create.ts "$1" "$2" --branch-name "<生成したブランチ名>"

# ブランチ名を生成しない場合（フォールバック）
npx tsx .cc-craft-kit/commands/spec/create.ts "$1" "$2"
```

作成が完了したら、結果を要約して表示し、以下の処理を実行してください。

## 仕様書の自動完成フロー (v0.4.0 以降)

重要: 仕様書作成時、以下の処理を**自動的に実行**してください。

### フェーズ 0: 仕様書の基本作成

**重要**: この処理は他のフェーズの前に必ず実行してください。

1. **仕様書ファイルの作成**
   - `npx tsx .cc-craft-kit/commands/spec/create.ts "$1" "$2" --branch-name "<生成したブランチ名>"` を実行
   - ブランチ作成、DB レコード作成、テンプレートファイル作成が完了
   - 生成された仕様書 ID を記録

### フェーズ 1: 事前情報収集

1. **コードベース解析** (Task ツール - Explore サブエージェント)
   - 制約条件: プロジェクトの技術スタック、アーキテクチャパターン、命名規則を抽出
   - 依存関係: 関連するモジュール、ライブラリ、データベーススキーマを特定
   - 関連仕様書: 既存の仕様書から類似機能を検索

   **重要**: Explore サブエージェントには以下を指示してください:
   - thoroughness level: "medium"
     - 理由: 仕様書作成の自動完成に必要な最小限の情報を収集するため
     - 想定コンテキスト消費: 約 20,000〜40,000 トークン
   - 検索対象:
     - `src/commands/**/*.ts` - コマンド実装パターンの抽出
     - `src/core/**/*.ts` - コアロジック・アーキテクチャの理解
     - `CLAUDE.md` - プロジェクト規約の確認
     - `.cc-craft-kit/specs/*.md` - 既存仕様書の構造を参照
     - 除外: `tests/**/*`, `node_modules/**/*`, `dist/**/*`
   - 収集情報:
     - 技術スタック (TypeScript, Kysely, EventEmitter2 など)
     - 設計パターン (DI、イベント駆動、モジュラーモノリス)
     - 既存の類似実装
     - 命名規則 (camelCase, PascalCase, kebab-case)

   **エラーハンドリング**: Explore が失敗した場合、仕様書作成は成功として扱い、テンプレートのまま保存する。エラーメッセージを表示し、手動編集を案内すること。

2. **情報の整理**
   - 収集した情報をもとに、仕様書の各セクションの叩き台を作成
   - 不足している情報を特定

### フェーズ 2: 不明情報の確認 (オプション)

1. **対話的な質問** (`AskUserQuestion` ツール)

   **実行条件**: 以下のいずれかに該当する場合のみ質問する:
   - フェーズ 1 のコードベース解析で十分な情報が得られなかった
   - 対象ユーザーが複数候補あり、明確に特定できない
   - 非機能要件が仕様書名・説明から推論できない

   **質問項目 (必要な場合のみ):**
   - 対象ユーザー (B2C/B2B、技術者/非技術者など)
   - 非機能要件 (パフォーマンス、セキュリティ、アクセシビリティ)
   - 優先度 (緊急/通常/低)

   **質問パターン例:**

   ```markdown
   question: "この機能の対象ユーザーは誰か?"
   note: "コードベース解析では明確に特定できませんでした。"
   options:
     - label: "開発者"
       description: "cc-craft-kit を使用する開発者"
     - label: "エンドユーザー"
       description: "アプリケーションの利用者"
     - label: "両方"
       description: "開発者とエンドユーザーの両方"
   ```

   **エラーハンドリング**:
   - `AskUserQuestion` が失敗した場合、コードベース解析の推論結果を使用
   - 推論結果も不十分な場合、テンプレートのプレースホルダーを残す

### フェーズ 3: 仕様書の自動完成

1. **自動完成された内容の反映**
   - 生成された仕様書ファイルを Read ツールで読み込み
   - Edit ツールで以下を更新:
     - 背景と目的: ユーザー入力 (`$1`, `$2`) + コードベース解析結果から生成
     - 対象ユーザー: `AskUserQuestion` の回答または推論結果
     - 受け入れ基準: 機能名から必須要件・機能要件・非機能要件を提案
     - 制約条件: コードベース解析から抽出した技術的制約
     - 依存関係: 既存モジュール・仕様書から抽出

   **エラーハンドリング**: Edit に失敗した場合、仕様書はテンプレート状態で保存される。エラーメッセージを表示し、手動編集を案内すること。

### フェーズ 4: 品質レビュー (オプション)

1. **仕様書の品質レビュー** (Task ツール - code-reviewer サブエージェント)

   **実行条件**: 以下のいずれかに該当する場合のみレビューする:
   - 環境変数 `AUTO_REVIEW_SPEC=1` が設定されている
   - 仕様書名に "重要" "critical" などのキーワードが含まれる

   **レビュー対象**:
   - Edit ツールで自動完成された仕様書ファイル (`.cc-craft-kit/specs/<spec-id>.md`)

   **レビュー項目**:
   - 仕様書の構造: 必須セクション (背景と目的、受け入れ基準など) が存在するか
   - 明確さ: プレースホルダー ("(記述してください)" など) が残っていないか
   - 完全性: 各セクションに具体的な内容が記載されているか
   - 受け入れ基準の具体性: 曖昧な表現 ("適切に" など) がないか

   **改善提案の処理**:
   - code-reviewer の提案を確認
   - 重大な問題 (プレースホルダーが残っている、受け入れ基準が不明確など) がある場合のみ、Edit ツールで修正
   - 軽微な提案は仕様書のコメントとして記録し、後で手動修正を案内

   **エラーハンドリング**:
   - code-reviewer が失敗した場合、レビューをスキップし、仕様書は自動完成された状態で保存
   - ユーザーに `/cft:code-review .cc-craft-kit/specs/<spec-id>.md` での手動レビューを案内

2. **次のアクションを案内**:
   - 仕様書の詳細確認: `/cft:spec-get <spec-id>`
   - デザインフェーズに移行: `/cft:spec-phase <spec-id> design`
   - (レビューをスキップした場合) 手動レビュー: `/cft:code-review .cc-craft-kit/specs/<spec-id>.md`

---

## フェーズ 5: ブランチ復帰 (v0.5.0 以降)

**重要**: 自動完成フロー（フェーズ 1〜4）が完了したら、元のブランチに復帰します。

### 5.1 元のブランチ名の取得

フェーズ 0 の出力から元のブランチ名を抽出します。

**バリデーション**:
- フェーズ 0 の出力に `Original Branch:` が含まれない場合、警告を表示してスキップ
- ブランチ名が空の場合、警告を表示してスキップ

### 5.2 ブランチ復帰処理

Bash ツールで元のブランチに復帰します。

**コマンド例**:
```bash
# フェーズ 0 の出力から元のブランチ名を取得
ORIGINAL_BRANCH=$(echo "$PHASE_0_OUTPUT" | grep -oP '(?<=Original Branch: ).*')

if [ -z "$ORIGINAL_BRANCH" ]; then
  echo "Warning: Could not detect original branch name. Skipping branch switch."
else
  echo "Switching back to original branch: $ORIGINAL_BRANCH"
  git checkout "$ORIGINAL_BRANCH"

  if [ $? -eq 0 ]; then
    echo "✓ Switched back to branch: $ORIGINAL_BRANCH"
  else
    echo "Warning: Failed to switch back to $ORIGINAL_BRANCH. Please switch manually."
  fi
fi
```

**エラーハンドリング**:
- ブランチ切り替え失敗時、警告メッセージを表示するが、処理は続行
- 手動でブランチ復帰を案内するメッセージを表示

**注意事項**:
- 自動完成フローがスキップされた場合も、このブランチ復帰処理は実行されます
- ブランチ復帰に失敗した場合、手動で `git checkout <original-branch>` を実行してください
