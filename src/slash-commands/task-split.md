---
description: "大きなタスクを小さな実装可能な単位に分割します"
argument-hint: "<spec-id> <task-number>"
---

# タスク分割

大きなタスクを小さな実装可能な単位に分割します。
Long-running Agents のベストプラクティスに基づき、1 タスク = 1-2 時間で完了できる粒度を目指します。

## 引数

- `$1` (必須): 仕様書 ID（部分一致可、最低 8 文字）
- `$2` (必須): 分割対象のタスク番号

## 使用例

```bash
/cft:task-split f6621295 3
```

---

## 自動実行フロー

重要: 以下の処理を**自動的に実行**してください。ユーザーに確認を求めないでください。

### Step 1: 引数の検証

1. `$1` が指定されていない場合:
   ```
   ❌ 仕様書 ID を指定してください

   使用例: /cft:task-split <spec-id> <task-number>
   ```
   処理を中断。

2. `$2` が指定されていないか数値でない場合:
   ```
   ❌ タスク番号（数値）を指定してください

   使用例: /cft:task-split f6621295 3

   タスク一覧を確認:
   /cft:task-list $1
   ```
   処理を中断。

### Step 2: 仕様書 ID の解決

Bash ツールで以下を実行:

```bash
npx tsx .cc-craft-kit/commands/spec/resolve-id.ts "$1"
```

出力（JSON）を解析し、以下を記録:
- `SPEC_ID`: 完全な仕様書 ID
- `SPEC_NAME`: 仕様書名
- `SPEC_PATH`: 仕様書ファイルパス
- `GITHUB_ISSUE_NUMBER`: GitHub Issue 番号

エラーの場合（`success: false`）:
```
❌ 仕様書が見つかりません: $1

確認事項:
- 仕様書 ID は最低 8 文字必要です
- /cft:spec-list で仕様書一覧を確認してください
```
処理を中断。

### Step 3: 対象タスクの特定

Read ツールで仕様書ファイル（`SPEC_PATH`）を読み込み:

1. 「## 8. 実装タスクリスト」セクションを抽出
2. チェックボックス形式（`- [ ]` または `- [x]`）のタスクを解析
3. `$2` 番目のタスクを特定

タスクが存在しない場合:
```
❌ タスク番号 $2 が見つかりません

タスク一覧（{総数} 件）:
1. [ステータス] タスク内容1
2. [ステータス] タスク内容2
...
```
処理を中断。

対象タスクを記録:
- `TARGET_TASK_NUMBER`: タスク番号
- `TARGET_TASK_CONTENT`: タスク内容
- `TARGET_TASK_STATUS`: ステータス（`- [ ]` = 未完了, `- [x]` = 完了）

完了済みタスクの場合:
```
⚠️ タスク #{TARGET_TASK_NUMBER} は既に完了しています

完了済みタスクを分割する意味はありますか？
通常は未完了のタスクを分割します。
```
AskUserQuestion ツールで確認:
- **続行**: 分割を続行
- **中断**: 処理を中断

### Step 4: コードベース解析

Task ツールで Explore サブエージェント（thoroughness: "medium"）を実行:

```
タスク「{TARGET_TASK_CONTENT}」を小さな実装単位に分割するため、以下を解析してください:

## 解析対象
- 仕様書「{SPEC_NAME}」の設計詳細セクション
- 関連するコードファイル
- 既存の類似実装

## 解析観点
1. タスクで実装すべき具体的な機能・処理
2. 依存関係（先に実装すべき部分）
3. 独立して実装・テスト可能な単位
4. 見積もり作業量（各サブタスク）

## 出力形式
以下の形式でサブタスクを提案:
1. [サブタスク1]: 具体的な実装内容（見積: X時間）
2. [サブタスク2]: 具体的な実装内容（見積: X時間）
...

分割の指針:
- 各サブタスクは 1-2 時間で完了できる粒度
- 依存関係がある場合は順序を明示
- 最低 2 個、最大 5 個のサブタスクに分割
```

### Step 5: 分割案の提示

Explore サブエージェントの結果に基づき、分割案を生成:

```markdown
## タスク分割案

### 元のタスク
#{TARGET_TASK_NUMBER}: {TARGET_TASK_CONTENT}

### 分割後のサブタスク

1. [ ] {サブタスク1内容}
   - 見積: {時間}
   - 依存: なし / #{依存タスク番号}

2. [ ] {サブタスク2内容}
   - 見積: {時間}
   - 依存: なし / 1

3. [ ] {サブタスク3内容}
   - 見積: {時間}
   - 依存: なし / 1, 2

### 合計見積
{合計時間}（元タスクの {X} 倍に細分化）
```

AskUserQuestion ツールで確認:

```
この分割案で進めますか？
```

オプション:
- **承認**: 分割を適用
- **修正**: 分割内容を調整
- **キャンセル**: 分割を中止

「修正」の場合:
- AskUserQuestion で修正内容を確認
- 分割案を調整して再提示

「キャンセル」の場合:
```
分割をキャンセルしました。

元のタスクはそのまま残ります:
#{TARGET_TASK_NUMBER}: {TARGET_TASK_CONTENT}
```
処理を中断。

### Step 6: 仕様書の更新

Edit ツールで仕様書ファイルを更新:

1. 元のタスク行を削除（または残してコメントアウト）
2. サブタスクを挿入

```markdown
## 8. 実装タスクリスト

### Phase X

- [x] 完了済みタスク
- [ ] {サブタスク1内容}
- [ ] {サブタスク2内容}
- [ ] {サブタスク3内容}
- [ ] 次のタスク
```

> **注意**: 元タスクの位置にサブタスクを挿入し、タスク番号は再割り当てされます。

### Step 7: GitHub Sub Issue の作成（任意）

`GITHUB_ISSUE_NUMBER` が存在し、元タスクに対応する Sub Issue がある場合:

```
ℹ️ GitHub Sub Issue の更新が必要な場合があります

元の Sub Issue をクローズして、新しいサブタスク用の Sub Issue を作成しますか？
```

AskUserQuestion ツールで確認:
- **作成**: 新しい Sub Issue を作成
- **スキップ**: Sub Issue は手動で管理

「作成」の場合:

```bash
# 元の Sub Issue をクローズ（存在する場合）
gh issue close <元issue番号> --repo "$REPO" --comment "タスクを分割しました"

# 新しい Sub Issue を作成
npx tsx .cc-craft-kit/commands/github/create-sub-issues.ts "$SPEC_ID" --tasks "{サブタスク1},{サブタスク2},..."
```

### Step 8: 自動コミット

Bash ツールで以下を実行:

```bash
git add "$SPEC_PATH" && git commit -m "refactor: タスク #{TARGET_TASK_NUMBER} を {サブタスク数} 個に分割"
```

### Step 9: 結果の表示

```markdown
# タスク分割完了

## 分割結果

### 元のタスク
#{TARGET_TASK_NUMBER}: {TARGET_TASK_CONTENT}

### 分割後のサブタスク
{サブタスク数} 個のサブタスクに分割しました:

| # | タスク | 見積 | 依存 |
|---|--------|------|------|
| {新番号1} | {サブタスク1} | {時間} | - |
| {新番号2} | {サブタスク2} | {時間} | {新番号1} |
| {新番号3} | {サブタスク3} | {時間} | {新番号1}, {新番号2} |

## タスク進捗

```
[████████░░░░░░░░░░░░] {完了率}% ({完了数}/{新総数} タスク完了)
```

## 次のアクション

- タスク一覧を確認: `/cft:task-list {SPEC_ID}`
- 最初のサブタスクを開始: `/cft:task-start <issue-number>`
- GitHub Issue を同期: `/cft:github-sync to-github {SPEC_ID}`
```

---

## エラーハンドリング

### 実装タスクリストがない場合

```
❌ 実装タスクリストが見つかりません

仕様書に「## 8. 実装タスクリスト」セクションがありません。

対処法:
- design フェーズを完了: /cft:spec-phase $SPEC_ID design
```

### Explore サブエージェントが失敗した場合

```
⚠️ 自動分割案の生成に失敗しました

手動でサブタスクを入力してください:

現在のタスク: {TARGET_TASK_CONTENT}

以下の形式で入力（1行1タスク）:
```

AskUserQuestion ツールで手動入力を受け付け。

### Git コミットに失敗した場合

```
⚠️ 自動コミットに失敗しました

仕様書は更新されましたが、コミットされていません。

手動でコミット:
git add {SPEC_PATH}
git commit -m "refactor: タスク分割"
```

---

## 分割のベストプラクティス

### 良い分割の例

**元タスク**: 「ユーザー認証機能を実装」

**分割後**:
1. ログインフォームの UI コンポーネント作成
2. パスワードバリデーションロジック実装
3. JWT トークン生成・検証処理
4. セッション管理（リフレッシュトークン）
5. ログアウト機能実装

### 悪い分割の例

**元タスク**: 「ユーザー認証機能を実装」

**悪い分割**:
1. 認証機能の前半を実装
2. 認証機能の後半を実装

→ 「前半」「後半」は具体的でなく、分割の意味がない

### 分割の判断基準

| 基準 | 良い例 | 悪い例 |
|------|--------|--------|
| 具体性 | 「JWT トークン生成」 | 「認証の一部」 |
| 独立性 | 「UI コンポーネント」 | 「前半部分」 |
| テスト可能性 | 「バリデーション」 | 「その他の処理」 |
| 作業量 | 「1-2時間」 | 「半日〜1日」 |

---

## 参考: Long-running Agents ベストプラクティス

> 「一度に完成させる」誘惑を排除し、単一機能ずつの実装に限定する

参照:
- https://www.anthropic.com/engineering/effective-harnesses-for-long-running-agents
