---
description: "test-generator サブエージェントで単体テストを自動生成"
argument-hint: "<file-pattern>"
---

# テスト生成

`test-generator` サブエージェントを実行して、単体テストを自動生成します。

## 引数

- `$1` (必須): 対象ファイルのパターン (例: `src/commands/spec/create.ts`)

## 実行内容

1. 指定されたファイルパターンに一致するファイルを検索
2. **実装を解析**して、テスト対象の関数・クラスの挙動を理解
3. `test-generator` サブエージェントを実行してテストを自動生成
4. 以下のテストケースを網羅：
   - 正常系のテストケース
   - エッジケース（境界値、null、undefined など）
   - エラーケース（例外処理の検証）
   - モック・スタブの作成

## テスト生成の原則

### 実装解析ベースのテスト生成

> **重要**: テスト生成は「ボイラープレート生成」ではなく「実装解析ベース」で行います。

1. **実装コードを読み込んで挙動を理解**
   - 関数の入力・出力を特定
   - 分岐条件（if/switch/三項演算子）を抽出
   - エラーハンドリングパターンを確認
   - 外部依存（DB、API、ファイルシステム）を特定

2. **テストケースの設計**
   - 各分岐をカバーするテストを設計
   - 境界値を特定してテストを追加
   - エラーケースを網羅

3. **モック戦略の決定**
   - 外部依存は必ずモック化
   - モックの戻り値は実際の挙動に基づく

### AAA パターン（Arrange-Act-Assert）

すべてのテストは AAA パターンに従って記述します：

```typescript
it('should [期待される動作]', () => {
  // Arrange（準備）: テストデータとモックを準備
  const input = { ... };
  const mockDep = jest.fn().mockReturnValue({ ... });

  // Act（実行）: テスト対象の関数を実行
  const result = targetFunction(input);

  // Assert（検証）: 期待値と実際の結果を比較
  expect(result).toEqual(expected);
  expect(mockDep).toHaveBeenCalledWith(...);
});
```

## 使用例

```bash
# 特定のファイルのテストを生成
/cft:test-generate "src/commands/spec/create.ts"

# 複数ファイルのテストを生成
/cft:test-generate "src/commands/**/*.ts"
```

---

## 自動実行フロー

重要: コマンド実行後、ユーザーに確認を求めずに、以下の処理を**自動的に実行**してください。

1. **ファイルパターンの解決**:
   - Glob ツールで `$1` パターンに一致するファイルを検索
   - 対象ファイルが存在しない場合はエラーメッセージを表示

2. **test-generator サブエージェントの実行**:
   - Task ツールで `test-generator` サブエージェントを起動
   - 対象ファイルごとに以下を実行：
     - Read ツールで対象ファイルを読み込む
     - 関数、クラス、メソッドの構造を解析
     - テストケースを設計（正常系、エッジケース、エラーケース）

3. **テストファイルの生成**:
   - テストファイルのパスを決定（`tests/` ディレクトリに配置）
   - Write ツールでテストファイルを作成
   - テストフレームワーク（Jest）の構文に従う
   - AAA パターン（Arrange-Act-Assert）で記述
   - モック・スタブが必要な場合は `jest.fn()` / `jest.spyOn()` を使用

4. **テストの実行とカバレッジ確認**:
   - Bash ツールで `npm test` を実行
   - カバレッジレポートを確認
   - テストが失敗した場合は、修正案を提示
